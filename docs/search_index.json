[["index.html", "Black Hills Experimental Forest UAS Mission Data Summary Section 1 Introduction", " Black Hills Experimental Forest UAS Mission Data Summary George Woolsey 05 July, 2024 Section 1 Introduction This project summarizes processed point cloud data created using structure from motion (SfM) photogrammetry methods on imagery collected from Unmanned Aircraft System (UAS) flights completed in June 2023. UAS imagery was collected using a DJI Phantom 4 Pro equipped with a 20 megapixel metal oxide semiconductor red-green-blue camera at a fixed 8.8 mm focal length. Flights followed a pre-programmed serpentine flight paths at an altitude of 120 m above ground level, using a nadir camera orientation, with 80% forward and side image overlap.The UAV imagery was processed in Agisoft Metashape using the routine outlined by Tinkham and Swayze (2021) to produce an SfM point cloud for optimized tree detection. The SfM-derived point cloud was processed using the methods outlined by Swayze and Tinkham (2022). Specifically, this script which is outlined in detail at it’s parent Github repository was used to process the raw point cloud data. UAS point cloud files (laz files) for this project were processed in two batches with the outputs combined using this script from the same repository. SfM techniques using UAS data reliably identify most tree locations and heights in open-canopied forests. However, their ability to characterize diameter at breast height (DBH) is limited to estimates of a fraction of trees within the area. SfM-derived DBH was estimated at the tree level following the methods outlined by Tinkham et al. (2022). "],["objective.html", "Section 2 Objective", " Section 2 Objective The objective of this analysis is to summarize forest stand characteristics using the UAS-derived tree list which includes tree location, height, and DBH measurements. Forest stands in this analysis include stands which were harvested in 2021 using single-tree and group-selection silvicultural prescriptions. The Forest Activity Tracking System (FACTS) database maintained by the U.S. Department of Agriculture, Forest Service (USFS) was used to delineate georeferenced boundaries of forest harvest activities. "],["data_prep.html", "Section 3 Data Preparation 3.1 Data Load 3.2 Load orthomosaic rasters", " Section 3 Data Preparation 3.1 Data Load Data loaded includes outputs from the UAS point cloud processing script: raw_las_ctg_info.gpkg, final_detected_crowns.gpkg, final_detected_tree_tops.gpkg. Also, loaded are experimental forest boundaries and timber harvest boundaries from the USFS FACTS database. # where is the processed data from point_cloud_processing_run_combine.R ? input_dir = &quot;../data/point_cloud_processing_BHEF_202306_combined&quot; # set output directory delivery_dir = &quot;../data/delivery&quot; dir.create(delivery_dir, showWarnings = FALSE) ### read data from point_cloud_processing #rasters dtm_rast = terra::rast(paste0(input_dir, &quot;/dtm_1m.tif&quot;)) chm_rast = terra::rast(paste0(input_dir, &quot;/chm_0.25m.tif&quot;)) # crowns = terra::rast(paste0(input_dir, &quot;/top_down_detected_tree_crowns.tif&quot;)) # las extent las_ctg_dta = sf::st_read(paste0(input_dir, &quot;/raw_las_ctg_info.gpkg&quot;)) # vectors # crown polygons crowns_sf_with_dbh = sf::st_read(paste0(input_dir, &quot;/final_detected_crowns.gpkg&quot;)) %&gt;% dplyr::select(-c(basal_area_ft2)) %&gt;% dplyr::rename( reg_est_lower_dbh_cm = reg_est_dbh_cm_lower , reg_est_upper_dbh_cm = reg_est_dbh_cm_upper ) # tree top points treetops_sf_with_dbh = sf::st_read(paste0(input_dir, &quot;/final_detected_tree_tops.gpkg&quot;)) %&gt;% dplyr::select(-c(basal_area_ft2)) %&gt;% dplyr::rename( reg_est_lower_dbh_cm = reg_est_dbh_cm_lower , reg_est_upper_dbh_cm = reg_est_dbh_cm_upper ) # height range for use in estimation height_range = dplyr::tibble( tree_height_m = seq( from = 0 , to = round(max(treetops_sf_with_dbh$tree_height_m)*1.05,0) , by = 0.1 # by 0.1 m increments ) ) # set crs proj_crs = sf::st_crs(las_ctg_dta) # read data from FACTS # harvests harvests = sf::st_read(&quot;../data/bhef_harvests.gpkg&quot;) %&gt;% dplyr::filter( year_id == 2021 # year_id &gt;= year(Sys.time()) - 15 &amp; !(treatment_type_grp %in% c(&quot;Improvement/Liberation Cut&quot;, &quot;Other&quot;, &quot;Sanitation Cut&quot;)) ) %&gt;% sf::st_transform(proj_crs) # bhef bounds bhef_boundary = sf::st_read(&quot;../data/bhef_boundary.gpkg&quot;) %&gt;% sf::st_transform(proj_crs) Define a function to convert columns in data frame from metric to imperial calc_imperial_units_fn &lt;- function(df) { df %&gt;% # convert to imperial units dplyr::mutate( dplyr::across( .cols = tidyselect::ends_with(&quot;_cm&quot;) , ~ .x * 0.394 , .names = &quot;{.col}_in&quot; ) , dplyr::across( .cols = tidyselect::ends_with(&quot;_m&quot;) , ~ .x * 3.28 , .names = &quot;{.col}_ft&quot; ) , dplyr::across( .cols = tidyselect::ends_with(&quot;_m2_per_ha&quot;) , ~ .x * 4.359 , .names = &quot;{.col}_ftac&quot; ) , dplyr::across( .cols = tidyselect::ends_with(&quot;_per_ha&quot;) &amp; !tidyselect::ends_with(&quot;_m2_per_ha&quot;) , ~ .x * 0.405 , .names = &quot;{.col}_ac&quot; ) , dplyr::across( .cols = tidyselect::ends_with(&quot;_area_ha&quot;) , ~ .x * 2.471 , .names = &quot;{.col}_ac&quot; ) , dplyr::across( .cols = tidyselect::ends_with(&quot;_m2&quot;) , ~ .x * 10.764 , .names = &quot;{.col}_ft2&quot; ) ) %&gt;% dplyr::rename_with( .fn = function(x){dplyr::case_when( stringr::str_ends(x,&quot;_cm_in&quot;) ~ stringr::str_replace(x,&quot;_cm_in&quot;,&quot;_in&quot;) , stringr::str_ends(x,&quot;_m_ft&quot;) ~ stringr::str_replace(x,&quot;_m_ft&quot;,&quot;_ft&quot;) , stringr::str_ends(x,&quot;_m2_per_ha_ftac&quot;) ~ stringr::str_replace(x,&quot;_m2_per_ha_ftac&quot;,&quot;_ft2_per_ac&quot;) , stringr::str_ends(x,&quot;_per_ha_ac&quot;) ~ stringr::str_replace(x,&quot;_per_ha_ac&quot;,&quot;_per_ac&quot;) , stringr::str_ends(x,&quot;_area_ha_ac&quot;) ~ stringr::str_replace(x,&quot;_area_ha_ac&quot;,&quot;_area_ac&quot;) , stringr::str_ends(x,&quot;_m2_ft2&quot;) ~ stringr::str_replace(x,&quot;_m2_ft2&quot;,&quot;_ft2&quot;) , TRUE ~ x )} ) } 3.2 Load orthomosaic rasters Orthomosaic tif files from the UAS flight imagery that were created in Agisoft Metashape are loaded and stitched together via terra::mosaic. if(!file.exists(paste0(delivery_dir,&quot;/BHEF_202306_Full_RBG.tif&quot;))){ # read list of orthos ortho_list_temp = list.files(&quot;../data/ortho/&quot;, pattern = &quot;.*\\\\.(tif|tiff)$&quot;, full.names = T)[] %&gt;% purrr::map(function(x){terra::rast(x)}) # ortho_list_temp[[1]] %&gt;% # terra::aggregate(20) %&gt;% # terra::plotRGB(r = 1, g = 2, b = 3, stretch = &quot;hist&quot;, colNA = &quot;transparent&quot;) ####### ensure the resolution of the rasters matches # terra::res(ortho_list_temp[[1]]) ## function change_res_fn = function(r, my_res=1){ r2 = r terra::res(r2) = my_res r2 = terra::resample(r, r2) return(r2) } ## apply the function ortho_list_temp = 1:length(ortho_list_temp) %&gt;% purrr::map(function(x){change_res_fn(ortho_list_temp[[x]], my_res=0.25)}) # terra::res(ortho_list_temp[[1]]) # ortho_list_temp[[1]] %&gt;% # terra::aggregate(2) %&gt;% # terra::plotRGB(r = 1, g = 2, b = 3, stretch = &quot;hist&quot;, colNA = &quot;transparent&quot;) ######## mosaic the raster list ortho_rast = terra::mosaic( terra::sprc(ortho_list_temp) , fun = &quot;min&quot; # min only thing that works ) ## write the mosaic terra::writeRaster(ortho_rast, filename = paste0(delivery_dir,&quot;/BHEF_202306_Full_RBG.tif&quot;), overwrite = T) }else{ ortho_rast = terra::rast(paste0(delivery_dir,&quot;/BHEF_202306_Full_RBG.tif&quot;)) } # ortho_rast %&gt;% # terra::aggregate(4) %&gt;% # terra::plotRGB(r = 1, g = 2, b = 3, stretch = &quot;lin&quot;, colNA = &quot;transparent&quot;) "],["local_mod.html", "Section 4 Local DBH to Height Model 4.1 Random Forest Model 4.2 Linear Model 4.3 Quadratic Model 4.4 No Intercept Quadratic Model 4.5 Nonlinear Power Model 4.6 Nonlinear Weibull Model 4.7 Model Comparison 4.8 Update DBH to best model 4.9 Combine harvest units with tree locations", " Section 4 Local DBH to Height Model 4.1 Random Forest Model The UAS point cloud processing script used a random forest model to estimate tree DBH based on the sample of DBH values extracted from the point cloud (outlined in detail here. This random forest model included tree height (m), crown area (m2), minimum crown height (m), and local tree competition metrics to estimate missing DBH values. Using methods outlined by Tinkham et al. (2022), local competition metrics included the distance to the nearest neighbor, trees ha−1 within a 5 m radius, and the relative tree height within a 5 m radius. A 5 m radius was selected as it represents a distance slightly less than the point at which two mature ponderosa pine trees in the region would begin to have interlocking crowns, representing a proxy for direct competition. The relative tree height within a 5 m radius was estimated using: \\[ \\textrm{Relative Height} = \\frac{\\textrm{Height}}{\\textrm{Height}_\\textrm{max}} \\times 100 \\] , where \\(\\textrm{Height}\\) is the height of the subject tree and \\(\\textrm{Height}_\\textrm{max}\\) is the height of the tallest tree within a 5 m radius of the subject tree. 4.1.1 Training vs Non-Training DBH ### plot plt_rf = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) %&gt;% dplyr::bind_rows( treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==F) %&gt;% dplyr::slice_sample(prop = 0.15) ) %&gt;% ggplot( mapping = aes( x=tree_height_m, y = dbh_cm , color = is_training_data , fill = is_training_data , group = is_training_data ) ) + geom_point( alpha = 0.6 , size = 0.7 , color = &quot;transparent&quot; , shape = 21 , show.legend = F ) + geom_smooth( method = &quot;loess&quot; , se = F , span = 1 , lwd = 1.5 , show.legend = T ) + scale_color_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_fill_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_y_continuous(limits = c(0,max(treetops_sf_with_dbh$dbh_cm)*1.02)) + scale_x_continuous(limits = c(0,max(treetops_sf_with_dbh$tree_height_m)*1.02)) + labs( y = &quot;DBH (cm)&quot; , x = &quot;Tree Ht. (m)&quot; , title = &quot;Random Forest Model&quot; , subtitle = &quot;SfM-derived tree height and DBH relationship&quot; , color = &quot;Training Data&quot; , fill = &quot;Training Data&quot; ) + theme_light() + theme( legend.position = &quot;bottom&quot; , legend.direction = &quot;horizontal&quot; ) + guides( color = guide_legend(override.aes = list(shape = 15, lwd = 6, size = 6, alpha = 1)) ) # plot plt_rf 4.2 Linear Model Tinkham et al. (2022) found the simple linear form resulted in the best estimates for both tree and stand level summarizations: \\[\\begin{align*} DBH_{i} &amp;\\sim {\\sf Gamma} \\bigl(g(\\beta_0, \\beta_1, Height_{i}), shape \\bigr) \\\\ g(\\beta_0, \\beta_1, Height_{i}) &amp;= {\\exp \\bigl(\\beta_0 + \\beta_1 \\cdot Height_{i}\\bigr)} \\\\ \\beta_{0} &amp;\\sim {\\sf Normal} (0,10) \\\\ \\beta_{1} &amp;\\sim {\\sf Normal} (0,10) \\\\ shape &amp;\\sim {\\sf Gamma} (0.01,0.01) \\end{align*}\\] , where \\(i\\) is the individual tree estimate from UAS SfM data. The \\(\\sf Gamma\\) response distribution represents \\(DBH_{i}\\) as strictly non-negative. # population model with no random effects (i.e. no group-level variation) # Gamma distribution for strictly positive response variable dbh mod_lin = brms::brm( formula = dbh_cm ~ 1 + tree_height_m , data = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) , family = brms::brmsfamily(&quot;Gamma&quot;, link = &quot;identity&quot;) , prior = c(prior(gamma(0.01, 0.01), class = shape)) , iter = 3000 , file = &quot;../data/mod_lin&quot; ) # plot(mod_lin) # summary(mod_lin) # plot(brms::conditional_effects(mod_lin), points = T) # compute and save the WAIC information for the next three models mod_lin = brms::add_criterion(mod_lin, c(&quot;loo&quot;, &quot;waic&quot;)) # predict values over range pred_mod_lin = predict( mod_lin , newdata = height_range , probs = c(.05, .95) ) %&gt;% dplyr::as_tibble() %&gt;% dplyr::rename( lower_b = 3, upper_b = 4 ) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::select(-c(est.error)) %&gt;% dplyr::bind_cols(height_range) %&gt;% dplyr::mutate(tree_height_m_tnth = round(tree_height_m,1) %&gt;% as.character()) # attach predicted values to original data treetops_sf_with_dbh = treetops_sf_with_dbh %&gt;% dplyr::mutate(tree_height_m_tnth = round(tree_height_m,1) %&gt;% as.character()) %&gt;% dplyr::left_join( pred_mod_lin %&gt;% dplyr::select(tree_height_m_tnth, estimate) , by = dplyr::join_by(tree_height_m_tnth) ) %&gt;% dplyr::mutate( mod_lin_est_dbh_cm = ifelse(is_training_data == T, dbh_cm, estimate) ) %&gt;% dplyr::select(-c(estimate, tree_height_m_tnth)) gc() 4.2.1 Model Parameter Estimates Simple linear form: \\[ DBH_i = \\beta_0 + \\beta_1 \\cdot Height_i \\] , where \\(i\\) is the individual tree estimate from UAS SfM data # parameter estimates mod_lin_sum_temp = brms::posterior_summary(mod_lin) %&gt;% as.data.frame() %&gt;% tibble::rownames_to_column(var = &quot;parameter&quot;) %&gt;% dplyr::filter(stringr::str_starts(parameter, &quot;b_&quot;)) %&gt;% # | parameter == &quot;shape&quot;) %&gt;% dplyr::rename_with(tolower) # table mod_lin_sum_temp %&gt;% kableExtra::kbl(digits = 4) %&gt;% kableExtra::kable_styling() parameter estimate est.error q2.5 q97.5 b_Intercept -3.7689 0.4497 -4.6500 -2.8868 b_tree_height_m 2.3505 0.0312 2.2907 2.4120 4.2.2 SfM-derived Height to DBH Allometry # plot predictions with data ggplot( data = pred_mod_lin, mapping = aes(x = tree_height_m) ) + geom_point( data = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) , mapping = aes(y = dbh_cm) , color = &quot;firebrick&quot; ) + geom_ribbon( mapping = aes(ymin = lower_b, ymax = upper_b) , fill = &quot;gray88&quot; , alpha = 0.5 ) + geom_line( aes(y = estimate) , color = &quot;gray33&quot; , lwd = 1 ) + labs( y = &quot;DBH (cm)&quot; , x = &quot;Tree Ht. (m)&quot; , title = &quot;Local height to DBH allometry from SfM-extracted DBH samples&quot; , subtitle = latex2exp::TeX(paste0( &quot;$DBH = &quot; , mod_lin_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_Intercept&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot; + &quot; , mod_lin_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_tree_height_m&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height&quot; )) ) + theme_light() + theme(legend.position = &quot;none&quot;) 4.2.3 Training vs Non-Training DBH ### plot plt_lin = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) %&gt;% dplyr::bind_rows( treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==F) %&gt;% dplyr::slice_sample(prop = 0.15) ) %&gt;% ggplot( mapping = aes( x=tree_height_m, y = mod_lin_est_dbh_cm , color = is_training_data , fill = is_training_data , group = is_training_data ) ) + geom_smooth( method = &quot;loess&quot; , se = F , span = 1 , lwd = 1.5 , show.legend = T ) + geom_point( alpha = 0.6 , size = 0.7 , color = &quot;transparent&quot; , shape = 21 , show.legend = F ) + annotate( &quot;text&quot;, x = 0, y = max(treetops_sf_with_dbh$dbh_cm) , label = latex2exp::TeX(paste0( &quot;$DBH = &quot; , mod_lin_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_Intercept&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot; + &quot; , mod_lin_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_tree_height_m&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height&quot; )) , parse = T , hjust = 0 ) + scale_color_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_fill_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_y_continuous(limits = c(0,max(treetops_sf_with_dbh$dbh_cm)*1.02)) + scale_x_continuous(limits = c(0,max(treetops_sf_with_dbh$tree_height_m)*1.02)) + labs( y = &quot;DBH (cm)&quot; , x = &quot;Tree Ht. (m)&quot; , title = &quot;Linear Model&quot; , subtitle = &quot;SfM-derived tree height and DBH relationship&quot; , color = &quot;Training Data&quot; , fill = &quot;Training Data&quot; ) + theme_light() + theme( legend.position = &quot;bottom&quot; , legend.direction = &quot;horizontal&quot; ) + guides( color = guide_legend(override.aes = list(shape = 15, lwd = 6, size = 6, alpha = 1)) ) # plot plt_lin 4.3 Quadratic Model A quadratic linear model with the inclusion of \\(Height_{i}^{2}\\) in the model allows us to account for a nonlinear (e.g. parabolic) relationship between DBH and tree height. \\[\\begin{align*} DBH_{i} &amp;\\sim {\\sf Gamma} \\bigl(g(\\beta_0, \\beta_1, \\beta_2, Height_{i}), shape \\bigr) \\\\ g(\\beta_0, \\beta_1, \\beta_2, Height_{i}) &amp;= {\\exp \\bigl(\\beta_0 + \\beta_1 \\cdot Height_{i} + \\beta_2 \\cdot Height_{i}^{2}\\bigr)} \\\\ \\beta_{0} &amp;\\sim {\\sf Normal} (0,10) \\\\ \\beta_{1} &amp;\\sim {\\sf Normal} (0,10) \\\\ \\beta_{2} &amp;\\sim {\\sf Normal} (0,10) \\\\ shape &amp;\\sim {\\sf Gamma} (0.01,0.01) \\end{align*}\\] , where \\(i\\) is the individual tree estimate from UAS SfM data. The \\(\\sf Gamma\\) response distribution represents \\(DBH_{i}\\) as strictly non-negative. # population model with no random effects (i.e. no group-level variation) # Gamma distribution for strictly positive response variable dbh mod_quad = brms::brm( formula = dbh_cm ~ 1 + tree_height_m + I(tree_height_m^2) , data = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) , family = brms::brmsfamily(&quot;Gamma&quot;, link = &quot;log&quot;) , prior = c(prior(gamma(0.01, 0.01), class = shape)) , iter = 3000 , file = &quot;../data/mod_quad&quot; ) # plot(mod_quad) # summary(mod_quad) # plot(brms::conditional_effects(mod_quad), points = T) # compute and save the WAIC information for the next three models mod_quad = brms::add_criterion(mod_quad, c(&quot;loo&quot;, &quot;waic&quot;)) # predict values over range pred_mod_quad = predict( mod_quad , newdata = height_range , probs = c(.05, .95) ) %&gt;% dplyr::as_tibble() %&gt;% dplyr::rename( lower_b = 3, upper_b = 4 ) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::select(-c(est.error)) %&gt;% dplyr::bind_cols(height_range) %&gt;% dplyr::mutate(tree_height_m_tnth = round(tree_height_m,1) %&gt;% as.character()) # attach predicted values to original data treetops_sf_with_dbh = treetops_sf_with_dbh %&gt;% dplyr::mutate(tree_height_m_tnth = round(tree_height_m,1) %&gt;% as.character()) %&gt;% dplyr::left_join( pred_mod_quad %&gt;% dplyr::select(tree_height_m_tnth, estimate) , by = dplyr::join_by(tree_height_m_tnth) ) %&gt;% dplyr::mutate( mod_quad_est_dbh_cm = ifelse(is_training_data == T, dbh_cm, estimate) ) %&gt;% dplyr::select(-c(estimate, tree_height_m_tnth)) gc() 4.3.1 Model Parameter Estimates Quadratic linear model form: \\[ DBH_{i} = \\exp\\bigl(\\beta_0 + \\beta_1 \\cdot Height_{i} + \\beta_2 \\cdot Height_{i}^{2} \\bigr) \\] , where \\(i\\) is the individual tree estimate from UAS SfM data # parameter estimates mod_quad_sum_temp = brms::posterior_summary(mod_quad) %&gt;% as.data.frame() %&gt;% tibble::rownames_to_column(var = &quot;parameter&quot;) %&gt;% dplyr::filter(stringr::str_starts(parameter, &quot;b_&quot;)) %&gt;% # | parameter == &quot;shape&quot;) %&gt;% dplyr::rename_with(tolower) # dplyr::mutate( # dplyr::across(.cols = tidyselect::where(is.numeric), .fns = exp) # ) # table mod_quad_sum_temp %&gt;% kableExtra::kbl(digits = 4) %&gt;% kableExtra::kable_styling() parameter estimate est.error q2.5 q97.5 b_Intercept 1.8837 0.6399 1.4717 3.8981 b_tree_height_m 0.1298 0.0793 -0.1194 0.1807 b_Itree_height_mE2 -0.0018 0.0024 -0.0033 0.0057 4.3.2 SfM-derived Height to DBH Allometry # predict and put estimates in a data frame predict( mod_quad , newdata = height_range , probs = c(.05, .95) ) %&gt;% dplyr::as_tibble() %&gt;% dplyr::rename( lower_b = 3, upper_b = 4 ) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::select(-c(est.error)) %&gt;% dplyr::bind_cols(height_range) %&gt;% # plot predictions with data ggplot( mapping = aes(x = tree_height_m) ) + geom_point( data = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) , mapping = aes(y = dbh_cm) , color = &quot;firebrick&quot; ) + geom_ribbon( mapping = aes(ymin = lower_b, ymax = upper_b) , fill = &quot;gray88&quot; , alpha = 0.5 ) + geom_line( aes(y = estimate) , color = &quot;gray33&quot; , lwd = 1 ) + labs( y = &quot;DBH (cm)&quot; , x = &quot;Tree Ht. (m)&quot; , title = &quot;Local height to DBH allometry from SfM-extracted DBH samples&quot; , subtitle = latex2exp::TeX(paste0( &quot;$DBH = \\\\exp(&quot; , mod_quad_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_Intercept&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot; + &quot; , mod_quad_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_tree_height_m&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height&quot; , &quot; + &quot; , mod_quad_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_Itree_height_mE2&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height^2)$&quot; )) ) + theme_light() + theme(legend.position = &quot;none&quot;) 4.3.3 Training vs Non-Training DBH ### plot plt_quad = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) %&gt;% dplyr::bind_rows( treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==F) %&gt;% dplyr::slice_sample(prop = 0.15) ) %&gt;% ggplot( mapping = aes( x=tree_height_m, y = mod_quad_est_dbh_cm , color = is_training_data , fill = is_training_data , group = is_training_data ) ) + geom_smooth( method = &quot;loess&quot; , se = F , span = 1 , lwd = 1.5 , show.legend = T ) + geom_point( alpha = 0.6 , size = 0.7 , color = &quot;transparent&quot; , shape = 21 , show.legend = F ) + annotate( &quot;text&quot;, x = 0, y = max(treetops_sf_with_dbh$dbh_cm) , label = latex2exp::TeX(paste0( &quot;$DBH = \\\\exp(&quot; , mod_quad_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_Intercept&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot; + &quot; , mod_quad_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_tree_height_m&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height&quot; , &quot; + &quot; , mod_quad_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_Itree_height_mE2&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height^2)$&quot; )) , parse = T , hjust = 0 ) + scale_color_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_fill_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_y_continuous(limits = c(0,max(treetops_sf_with_dbh$dbh_cm)*1.02)) + scale_x_continuous(limits = c(0,max(treetops_sf_with_dbh$tree_height_m)*1.02)) + labs( y = &quot;DBH (cm)&quot; , x = &quot;Tree Ht. (m)&quot; , title = &quot;Quadratic Model&quot; , subtitle = &quot;SfM-derived tree height and DBH relationship&quot; , color = &quot;Training Data&quot; , fill = &quot;Training Data&quot; ) + theme_light() + theme( legend.position = &quot;bottom&quot; , legend.direction = &quot;horizontal&quot; ) + guides( color = guide_legend(override.aes = list(shape = 15, lwd = 6, size = 6, alpha = 1)) ) # plot plt_quad 4.4 No Intercept Quadratic Model A quadratic linear model with the inclusion of \\(Height_{i}^{2}\\) in the model allows us to account for a nonlinear (e.g. parabolic) relationship between DBH and tree height. Forcing the intercept to \\(0\\) allows for the model to better account for the minimum tree height threshold set at 2 m in the point cloud processing workflow. \\[\\begin{align*} DBH_{i} &amp;\\sim {\\sf Gamma} \\bigl(g(\\beta_1, \\beta_2, Height_{i}), shape \\bigr) \\\\ g(\\beta_1, \\beta_2, Height_{i}) &amp;= {\\exp \\bigl(0 + \\beta_1 \\cdot Height_{i} + \\beta_2 \\cdot Height_{i}^{2}\\bigr)} \\\\ \\beta_{1} &amp;\\sim {\\sf Normal} (0,10) \\\\ \\beta_{2} &amp;\\sim {\\sf Normal} (0,10) \\\\ shape &amp;\\sim {\\sf Gamma} (0.01,0.01) \\end{align*}\\] , where \\(i\\) is the individual tree estimate from UAS SfM data. The \\(\\sf Gamma\\) response distribution represents \\(DBH_{i}\\) as strictly non-negative. # population model with no random effects (i.e. no group-level variation) # Gamma distribution for strictly positive response variable dbh mod_quad_noint = brms::brm( formula = dbh_cm ~ 0 + tree_height_m + I(tree_height_m^2) , data = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) , family = brms::brmsfamily(&quot;Gamma&quot;, link = &quot;log&quot;) , prior = c(prior(gamma(0.01, 0.01), class = shape)) , iter = 3000 , file = &quot;../data/mod_quad_noint&quot; ) # plot(mod_quad_noint) # summary(mod_quad_noint) # plot(brms::conditional_effects(mod_quad_noint), points = T) # compute and save the WAIC information for the next three models mod_quad_noint = brms::add_criterion(mod_quad_noint, c(&quot;loo&quot;, &quot;waic&quot;)) # predict values over range pred_mod_quad_noint = predict( mod_quad_noint , newdata = height_range , probs = c(.05, .95) ) %&gt;% dplyr::as_tibble() %&gt;% dplyr::rename( lower_b = 3, upper_b = 4 ) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::select(-c(est.error)) %&gt;% dplyr::bind_cols(height_range) %&gt;% dplyr::mutate(tree_height_m_tnth = round(tree_height_m,1) %&gt;% as.character()) # attach predicted values to original data treetops_sf_with_dbh = treetops_sf_with_dbh %&gt;% dplyr::mutate(tree_height_m_tnth = round(tree_height_m,1) %&gt;% as.character()) %&gt;% dplyr::left_join( pred_mod_quad_noint %&gt;% dplyr::select(tree_height_m_tnth, estimate) , by = dplyr::join_by(tree_height_m_tnth) ) %&gt;% dplyr::mutate( mod_quad_noint_est_dbh_cm = ifelse(is_training_data == T, dbh_cm, estimate) ) %&gt;% dplyr::select(-c(estimate, tree_height_m_tnth)) gc() 4.4.1 Model Parameter Estimates No intercept quadratic linear model form: \\[ DBH_{i} = \\exp\\bigl( 0 + \\beta_1 \\cdot Height_{i} + \\beta_2 \\cdot Height_{i}^{2} \\bigr) \\] , where \\(i\\) is the individual tree estimate from UAS SfM data # parameter estimates mod_quad_noint_sum_temp = brms::posterior_summary(mod_quad_noint) %&gt;% as.data.frame() %&gt;% tibble::rownames_to_column(var = &quot;parameter&quot;) %&gt;% dplyr::filter(stringr::str_starts(parameter, &quot;b_&quot;)) %&gt;% # | parameter == &quot;shape&quot;) %&gt;% dplyr::rename_with(tolower) # dplyr::mutate( # dplyr::across(.cols = tidyselect::where(is.numeric), .fns = exp) # ) # table mod_quad_noint_sum_temp %&gt;% kableExtra::kbl(digits = 4) %&gt;% kableExtra::kable_styling() parameter estimate est.error q2.5 q97.5 b_tree_height_m 0.3561 0.0013 0.3536 0.3587 b_Itree_height_mE2 -0.0082 0.0001 -0.0084 -0.0081 4.4.2 SfM-derived Height to DBH Allometry # predict and put estimates in a data frame predict( mod_quad_noint , newdata = height_range , probs = c(.05, .95) ) %&gt;% dplyr::as_tibble() %&gt;% dplyr::rename( lower_b = 3, upper_b = 4 ) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::select(-c(est.error)) %&gt;% dplyr::bind_cols(height_range) %&gt;% # plot predictions with data ggplot( mapping = aes(x = tree_height_m) ) + geom_point( data = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) , mapping = aes(y = dbh_cm) , color = &quot;firebrick&quot; ) + geom_ribbon( mapping = aes(ymin = lower_b, ymax = upper_b) , fill = &quot;gray88&quot; , alpha = 0.5 ) + geom_line( aes(y = estimate) , color = &quot;gray33&quot; , lwd = 1 ) + labs( y = &quot;DBH (cm)&quot; , x = &quot;Tree Ht. (m)&quot; , title = &quot;Local height to DBH allometry from SfM-extracted DBH samples&quot; , subtitle = latex2exp::TeX(paste0( &quot;$DBH = \\\\exp(0&quot; , &quot; + &quot; , mod_quad_noint_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_tree_height_m&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height&quot; , &quot; + &quot; , mod_quad_noint_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_Itree_height_mE2&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height^2)$&quot; )) ) + theme_light() + theme(legend.position = &quot;none&quot;) 4.4.3 Training vs Non-Training DBH ### plot plt_quad_noint = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) %&gt;% dplyr::bind_rows( treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==F) %&gt;% dplyr::slice_sample(prop = 0.15) ) %&gt;% ggplot( mapping = aes( x=tree_height_m, y = mod_quad_noint_est_dbh_cm , color = is_training_data , fill = is_training_data , group = is_training_data ) ) + geom_smooth( method = &quot;loess&quot; , se = F , span = 1 , lwd = 1.5 , show.legend = T ) + geom_point( alpha = 0.6 , size = 0.7 , color = &quot;transparent&quot; , shape = 21 , show.legend = F ) + annotate( &quot;text&quot;, x = 0, y = max(treetops_sf_with_dbh$dbh_cm) , label = latex2exp::TeX(paste0( &quot;$DBH = \\\\exp(0&quot; , &quot; + &quot; , mod_quad_noint_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_tree_height_m&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height&quot; , &quot; + &quot; , mod_quad_noint_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_Itree_height_mE2&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height^2)$&quot; )) , parse = T , hjust = 0 ) + scale_color_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_fill_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_y_continuous(limits = c(0,max(treetops_sf_with_dbh$dbh_cm)*1.02)) + scale_x_continuous(limits = c(0,max(treetops_sf_with_dbh$tree_height_m)*1.02)) + labs( y = &quot;DBH (cm)&quot; , x = &quot;Tree Ht. (m)&quot; , title = &quot;No Intercept Quadratic Model&quot; , subtitle = &quot;SfM-derived tree height and DBH relationship&quot; , color = &quot;Training Data&quot; , fill = &quot;Training Data&quot; ) + theme_light() + theme( legend.position = &quot;bottom&quot; , legend.direction = &quot;horizontal&quot; ) + guides( color = guide_legend(override.aes = list(shape = 15, lwd = 6, size = 6, alpha = 1)) ) # plot plt_quad_noint 4.5 Nonlinear Power Model A power-law function model allows us to account for a nonlinear relationship between DBH and tree height: \\[\\begin{align*} DBH_{i} &amp;\\sim {\\sf Gamma} \\bigl(g(\\alpha, \\kappa, Height_{i}), shape \\bigr) \\\\ g(\\alpha, \\kappa, Height_{i}) &amp;= {\\exp \\bigl(\\alpha \\cdot Height_{i}^{\\kappa}\\bigr)} \\\\ \\alpha &amp;\\sim {\\sf Normal} (0,10) \\\\ \\kappa &amp;\\sim {\\sf Normal} (0,10) \\\\ shape &amp;\\sim {\\sf Gamma} (0.01,0.01) \\end{align*}\\] , where \\(i\\) is the individual tree estimate from UAS SfM data. The \\(\\sf Gamma\\) response distribution represents \\(DBH_{i}\\) as strictly non-negative. # population model with no random effects (i.e. no group-level variation) # Gamma distribution for strictly positive response variable dbh mod_pwr = brms::brm( formula = brms::bf( formula = dbh_cm ~ a * (tree_height_m^k) , a + k ~ 1 , nl = TRUE # !! specify non-linear ) , data = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) , family = brms::brmsfamily(&quot;Gamma&quot;, link = &quot;log&quot;) , prior = c(prior(gamma(0.01, 0.01), class = shape)) , iter = 3000 , file = &quot;../data/mod_pwr&quot; ) # plot(mod_pwr) # summary(mod_pwr) # plot(brms::conditional_effects(mod_pwr), points = T) # compute and save the WAIC information for the next three models mod_pwr = brms::add_criterion(mod_pwr, c(&quot;loo&quot;, &quot;waic&quot;)) # predict values over range pred_mod_pwr = predict( mod_pwr , newdata = height_range , probs = c(.05, .95) ) %&gt;% dplyr::as_tibble() %&gt;% dplyr::rename( lower_b = 3, upper_b = 4 ) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::select(-c(est.error)) %&gt;% dplyr::bind_cols(height_range) %&gt;% dplyr::mutate(tree_height_m_tnth = round(tree_height_m,1) %&gt;% as.character()) # attach predicted values to original data treetops_sf_with_dbh = treetops_sf_with_dbh %&gt;% dplyr::mutate(tree_height_m_tnth = round(tree_height_m,1) %&gt;% as.character()) %&gt;% dplyr::left_join( pred_mod_pwr %&gt;% dplyr::select(tree_height_m_tnth, estimate) , by = dplyr::join_by(tree_height_m_tnth) ) %&gt;% dplyr::mutate( mod_pwr_est_dbh_cm = ifelse(is_training_data == T, dbh_cm, estimate) ) %&gt;% dplyr::select(-c(estimate, tree_height_m_tnth)) gc() 4.5.1 Model Parameter Estimates Power-law function model form: \\[ DBH_{i} = \\exp\\bigl(\\alpha \\cdot Height_{i}^{\\kappa}\\bigr) \\] , where \\(i\\) is the individual tree estimate from UAS SfM data # parameter estimates mod_pwr_sum_temp = brms::posterior_summary(mod_pwr) %&gt;% as.data.frame() %&gt;% tibble::rownames_to_column(var = &quot;parameter&quot;) %&gt;% dplyr::filter(stringr::str_starts(parameter, &quot;b_&quot;)) %&gt;% # | parameter == &quot;shape&quot;) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::mutate( parameter = stringr::str_remove_all(tolower(parameter), &quot;_intercept&quot;) # , dplyr::across(.cols = tidyselect::where(is.numeric), .fns = exp) ) # table mod_pwr_sum_temp %&gt;% kableExtra::kbl(digits = 4) %&gt;% kableExtra::kable_styling() parameter estimate est.error q2.5 q97.5 b_a 1.4022 0.0205 1.3610 1.4424 b_k 0.3310 0.0052 0.3208 0.3416 4.5.2 SfM-derived Height to DBH Allometry # predict and put estimates in a data frame predict( mod_pwr , newdata = height_range , probs = c(.05, .95) ) %&gt;% dplyr::as_tibble() %&gt;% dplyr::rename( lower_b = 3, upper_b = 4 ) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::select(-c(est.error)) %&gt;% dplyr::bind_cols(height_range) %&gt;% # plot predictions with data ggplot( mapping = aes(x = tree_height_m) ) + geom_point( data = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) , mapping = aes(y = dbh_cm) , color = &quot;firebrick&quot; ) + geom_ribbon( mapping = aes(ymin = lower_b, ymax = upper_b) , fill = &quot;gray88&quot; , alpha = 0.5 ) + geom_line( aes(y = estimate) , color = &quot;gray33&quot; , lwd = 1 ) + labs( y = &quot;DBH (cm)&quot; , x = &quot;Tree Ht. (m)&quot; , title = &quot;Local height to DBH allometry from SfM-extracted DBH samples&quot; , subtitle = latex2exp::TeX(paste0( &quot;$DBH = \\\\exp(&quot; , mod_pwr_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_a&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height^{&quot; , mod_pwr_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_k&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;})$&quot; )) ) + theme_light() + theme(legend.position = &quot;none&quot;) 4.5.3 Training vs Non-Training DBH ### plot plt_pwr = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) %&gt;% dplyr::bind_rows( treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==F) %&gt;% dplyr::slice_sample(prop = 0.15) ) %&gt;% ggplot( mapping = aes( x=tree_height_m, y = mod_pwr_est_dbh_cm , color = is_training_data , fill = is_training_data , group = is_training_data ) ) + geom_smooth( method = &quot;loess&quot; , se = F , span = 1 , lwd = 1.5 , show.legend = T ) + geom_point( alpha = 0.6 , size = 0.7 , color = &quot;transparent&quot; , shape = 21 , show.legend = F ) + annotate( &quot;text&quot;, x = 0, y = max(treetops_sf_with_dbh$dbh_cm) , label = latex2exp::TeX(paste0( &quot;$DBH = \\\\exp(&quot; , mod_pwr_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_a&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height^{&quot; , mod_pwr_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_k&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;})$&quot; )) , parse = T , hjust = 0 ) + scale_color_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_fill_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_y_continuous(limits = c(0,max(treetops_sf_with_dbh$dbh_cm)*1.02)) + scale_x_continuous(limits = c(0,max(treetops_sf_with_dbh$tree_height_m)*1.02)) + labs( y = &quot;DBH (cm)&quot; , x = &quot;Tree Ht. (m)&quot; , title = &quot;Nonlinear Power Model&quot; , subtitle = &quot;SfM-derived tree height and DBH relationship&quot; , color = &quot;Training Data&quot; , fill = &quot;Training Data&quot; ) + theme_light() + theme( legend.position = &quot;bottom&quot; , legend.direction = &quot;horizontal&quot; ) + guides( color = guide_legend(override.aes = list(shape = 15, lwd = 6, size = 6, alpha = 1)) ) # plot plt_pwr 4.6 Nonlinear Weibull Model Pilli et al. (2006) suggest a Weibull function for estimating DBH to height allometric relationships to allow for a nonlinear relationship: \\[\\begin{align*} DBH_{i} &amp;\\sim {\\sf Gamma} \\bigl(g(a, b, Height_{i}), shape \\bigr) \\\\ g(a, b, Height_{i}) &amp;= {\\exp\\biggl(a \\cdot \\bigl(1-\\exp(-Height_{i}/b)\\bigr)\\biggr)} \\\\ a &amp;\\sim {\\sf Normal} (0,10) \\\\ b &amp;\\sim {\\sf Normal} (0,10) \\\\ shape &amp;\\sim {\\sf Gamma} (0.01,0.01) \\end{align*}\\] , where \\(i\\) is the individual tree estimate from UAS SfM data. The \\(\\sf Gamma\\) response distribution represents \\(DBH_{i}\\) as strictly non-negative. # population model with no random effects (i.e. no group-level variation) # Gamma distribution for strictly positive response variable dbh # a × (1−exp(−DBH/b)) mod_weib = brms::brm( formula = brms::bf( formula = dbh_cm ~ a * (1-exp(-tree_height_m/b)) , a + b ~ 1 , nl = TRUE # !! specify non-linear ) , data = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) , family = brms::brmsfamily(&quot;Gamma&quot;, link = &quot;log&quot;) , prior = c(prior(gamma(0.01, 0.01), class = shape)) , iter = 3000 , file = &quot;../data/mod_weib&quot; ) # plot(mod_weib) # summary(mod_weib) # plot(brms::conditional_effects(mod_weib), points = T) # compute and save the WAIC information for the next three models mod_weib = brms::add_criterion(mod_weib, c(&quot;loo&quot;, &quot;waic&quot;)) # predict values over range pred_mod_weib = predict( mod_weib , newdata = height_range , probs = c(.05, .95) ) %&gt;% dplyr::as_tibble() %&gt;% dplyr::rename( lower_b = 3, upper_b = 4 ) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::select(-c(est.error)) %&gt;% dplyr::bind_cols(height_range) %&gt;% dplyr::mutate(tree_height_m_tnth = round(tree_height_m,1) %&gt;% as.character()) # attach predicted values to original data treetops_sf_with_dbh = treetops_sf_with_dbh %&gt;% dplyr::mutate(tree_height_m_tnth = round(tree_height_m,1) %&gt;% as.character()) %&gt;% dplyr::left_join( pred_mod_weib %&gt;% dplyr::select(tree_height_m_tnth, estimate) , by = dplyr::join_by(tree_height_m_tnth) ) %&gt;% dplyr::mutate( mod_weib_est_dbh_cm = ifelse(is_training_data == T, dbh_cm, estimate) ) %&gt;% dplyr::select(-c(estimate, tree_height_m_tnth)) gc() 4.6.1 Model Parameter Estimates Weibull function model form: \\[ DBH_{i} = \\exp\\biggl(a \\cdot \\bigl(1-\\exp(-Height_{i}/b)\\bigr)\\biggr) \\] , where \\(i\\) is the individual tree estimate from UAS SfM data # parameter estimates mod_weib_sum_temp = brms::posterior_summary(mod_weib) %&gt;% as.data.frame() %&gt;% tibble::rownames_to_column(var = &quot;parameter&quot;) %&gt;% dplyr::filter(stringr::str_starts(parameter, &quot;b_&quot;)) %&gt;% # | parameter == &quot;shape&quot;) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::mutate( parameter = stringr::str_remove_all(tolower(parameter), &quot;_intercept&quot;) # , dplyr::across(.cols = tidyselect::where(is.numeric), .fns = exp) ) # table mod_weib_sum_temp %&gt;% kableExtra::kbl(digits = 4) %&gt;% kableExtra::kable_styling() parameter estimate est.error q2.5 q97.5 b_a 4.0870 0.0172 4.0549 4.1214 b_b 7.9347 0.1050 7.7372 8.1441 4.6.2 SfM-derived Height to DBH Allometry # predict and put estimates in a data frame predict( mod_weib , newdata = height_range , probs = c(.05, .95) ) %&gt;% dplyr::as_tibble() %&gt;% dplyr::rename( lower_b = 3, upper_b = 4 ) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::select(-c(est.error)) %&gt;% dplyr::bind_cols(height_range) %&gt;% # plot predictions with data ggplot( mapping = aes(x = tree_height_m) ) + geom_point( data = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) , mapping = aes(y = dbh_cm) , color = &quot;firebrick&quot; ) + geom_ribbon( mapping = aes(ymin = lower_b, ymax = upper_b) , fill = &quot;gray88&quot; , alpha = 0.5 ) + geom_line( aes(y = estimate) , color = &quot;gray33&quot; , lwd = 1 ) + labs( y = &quot;DBH (cm)&quot; , x = &quot;Tree Ht. (m)&quot; , title = &quot;Local height to DBH allometry from SfM-extracted DBH samples&quot; , subtitle = latex2exp::TeX(paste0( &quot;$DBH = \\\\exp(&quot; , mod_weib_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_a&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot (1-\\\\exp(-Height/&quot; , mod_weib_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_b&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;)))$&quot; )) ) + theme_light() + theme(legend.position = &quot;none&quot;) 4.6.3 Training vs Non-Training DBH ### plot plt_weib = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) %&gt;% dplyr::bind_rows( treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==F) %&gt;% dplyr::slice_sample(prop = 0.15) ) %&gt;% ggplot( mapping = aes( x=tree_height_m, y = mod_weib_est_dbh_cm , color = is_training_data , fill = is_training_data , group = is_training_data ) ) + geom_smooth( method = &quot;loess&quot; , se = F , span = 1 , lwd = 1.5 , show.legend = T ) + geom_point( alpha = 0.6 , size = 0.7 , color = &quot;transparent&quot; , shape = 21 , show.legend = F ) + annotate( &quot;text&quot;, x = 0, y = max(treetops_sf_with_dbh$dbh_cm) , label = latex2exp::TeX(paste0( &quot;$DBH = \\\\exp(&quot; , mod_weib_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_a&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot (1-\\\\exp(-Height/&quot; , mod_weib_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_b&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;)))$&quot; )) , parse = T , hjust = 0 ) + scale_color_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_fill_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_y_continuous(limits = c(0,max(treetops_sf_with_dbh$dbh_cm)*1.02)) + scale_x_continuous(limits = c(0,max(treetops_sf_with_dbh$tree_height_m)*1.02)) + labs( y = &quot;DBH (cm)&quot; , x = &quot;Tree Ht. (m)&quot; , title = &quot;Nonlinear Weibull Model&quot; , subtitle = &quot;SfM-derived tree height and DBH relationship&quot; , color = &quot;Training Data&quot; , fill = &quot;Training Data&quot; ) + theme_light() + theme( legend.position = &quot;bottom&quot; , legend.direction = &quot;horizontal&quot; ) + guides( color = guide_legend(override.aes = list(shape = 15, lwd = 6, size = 6, alpha = 1)) ) # plot plt_weib 4.7 Model Comparison The pointwise log-likelihood can be used, among others, to calculate the leave-one-out cross-validation (LOO; Vehtari, Gelman, and Gabry 2015) allowing for comparison of different models applied to the same data (lower LOOs indicate better model fit). brms::loo_compare(mod_lin, mod_quad, mod_quad_noint, mod_pwr, mod_weib, criterion = &quot;loo&quot;) %&gt;% kableExtra::kbl(digits = 3) %&gt;% kableExtra::kable_styling() elpd_diff se_diff elpd_loo se_elpd_loo p_loo se_p_loo looic se_looic mod_lin 0.000 0.000 -9143.944 32.486 2.557 0.109 18287.89 64.972 mod_pwr -15.256 5.003 -9159.200 32.598 2.671 0.092 18318.40 65.196 mod_weib -27.266 8.488 -9171.210 32.204 2.820 0.093 18342.42 64.409 mod_quad -164.854 16.991 -9308.798 35.442 146.992 17.286 18617.60 70.885 mod_quad_noint -405.877 36.401 -9549.820 39.550 5.555 0.918 19099.64 79.101 # # can also check model weights # brms::model_weights(mod_lin, mod_quad, mod_quad_noint, mod_pwr, mod_weib, weights = &quot;loo&quot;) %&gt;% # round(3) Based on these results, the linear model \\(DBH_i = \\beta_0 + \\beta_1 \\cdot Height_i\\) has the best fit among models tested. DBH estimates based on this model for trees where DBH could not be extracted from the UAS SfM data will be used in the following analysis and stand-level summaries 4.8 Update DBH to best model # update treetops treetops_sf_with_dbh = treetops_sf_with_dbh %&gt;% dplyr::mutate( mod_rf_est_dbh_cm = dbh_cm , dbh_cm = mod_lin_est_dbh_cm , dbh_m = dbh_cm/100 , radius_m = dbh_m/2 , basal_area_m2 = pi * (radius_m)^2 ) %&gt;% # convert to imperial units calc_imperial_units_fn() ########## # update crowns crowns_sf_with_dbh = crowns_sf_with_dbh %&gt;% dplyr::select(-c( dbh_cm , dbh_m , radius_m , basal_area_m2 )) %&gt;% dplyr::inner_join( treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select( treeID , dbh_cm , dbh_m , radius_m , basal_area_m2 , (tidyselect::starts_with(&quot;mod_&quot;) &amp; tidyselect::ends_with(&quot;_cm&quot;)) ) , by = dplyr::join_by(treeID) ) %&gt;% # convert to imperial units calc_imperial_units_fn() ## write data sf::st_write(treetops_sf_with_dbh, paste0(delivery_dir,&quot;/dbh_updated_detected_tree_tops.gpkg&quot;), append = F) sf::st_write(crowns_sf_with_dbh, paste0(delivery_dir,&quot;/dbh_updated_detected_crowns.gpkg&quot;), append = F) ## keep the best model mod_best = mod_lin pred_mod_best = pred_mod_lin 4.9 Combine harvest units with tree locations Spatially combine harvest units with tree locations. One tree can be located in multiple harvest units if the harvest units spatially overlap; I’ll allow it. Trees are matched to a harvest unit based on the location of the tree top which may or may not align with the location of the tree bole at DBH. ################################################################################# ################################################################################# # Join tree tops with forest stands ################################################################################# ################################################################################# harvests_trees = harvests %&gt;% dplyr::mutate( stand_area_m2 = sf::st_area(.) %&gt;% as.numeric() , stand_area_ha = stand_area_m2/10000 ) %&gt;% sf::st_intersection(las_ctg_dta) %&gt;% dplyr::mutate( intrsct_stand_area_m2 = sf::st_area(.) %&gt;% as.numeric() ) %&gt;% dplyr::filter(round(intrsct_stand_area_m2, 0) == round(stand_area_m2, 0)) %&gt;% dplyr::select( suid, forest_commonname, admin_region_code, activity_name , treatment_type, treatment_type_grp, date_compl, year_id , stand_area_m2, stand_area_ha ) %&gt;% sf::st_intersection(treetops_sf_with_dbh) # filter harvests harvests = harvests %&gt;% dplyr::filter(suid %in% unique(harvests_trees$suid)) "],["exploratory-analysis.html", "Section 5 Exploratory Analysis 5.1 Study Location Map 5.2 Digital Terrain Model (DTM) Map 5.3 Canopy height model (CHM) Map 5.4 DBH Distribution 5.5 Height Distribution 5.6 Relationship between height and DBH", " Section 5 Exploratory Analysis High-level summaries of the data. 5.1 Study Location Map Map of the BHEF, 2021 harvest boundaries, and 2023-06 UAS flight boundaries. The UAS flights covered 719.9 acres (291.3 ha). There are 6 stands harvested in 2021 that are entirely within the UAS flight boundaries. The harvested stands range in size from 9.6 acres (3.9 ha) to 167.8 acres (67.9 ha). # map mapview::mapview( bhef_boundary , color = &quot;black&quot; , lwd = 3 , alpha.regions = 0 , layer.name = &quot;BHEF&quot; , label = FALSE , legend = FALSE , popup = FALSE ) + mapview::mapview( las_ctg_dta , color = &quot;firebrick&quot; , lwd = 2 , col.regions = c(&quot;firebrick&quot;) , alpha.regions = 0.3 , layer.name = &quot;UAS Flight Boundaries&quot; , label = FALSE , legend = T , popup = FALSE ) + mapview::mapview( harvests , zcol = &quot;treatment_type_grp&quot; , col.regions = viridis::turbo(n=length(unique(harvests$treatment_type_grp))) , alpha.regions = 0.6 , layer.name = &quot;Harvests (2021)&quot; , legend = T , popup = leafpop::popupTable( harvests , zcol = c( &quot;year_id&quot; , &quot;treatment_type_grp&quot; , &quot;activity_name&quot; ) , row.numbers = FALSE , feature.id = FALSE ) ) 5.2 Digital Terrain Model (DTM) Map Map the SfM-derived digital terrain model (DTM) (sometimes called Digital Elevation Models [DEM]) which is a topographic model of the bare Earth containing the elevation data of the terrain. mapview::mapview( bhef_boundary , color = &quot;black&quot; , lwd = 3 , alpha.regions = 0 , layer.name = &quot;BHEF&quot; , label = FALSE , legend = FALSE , popup = FALSE ) + # aggregate raster and map mapview::mapview( dtm_rast %&gt;% terra::aggregate(fact=2) %&gt;% `*`(3.28) %&gt;% # transform to feet stars::st_as_stars() , layer.name = &quot;elev. (ft)&quot; , col.regions = viridis::viridis(n=100) , alpha.regions = 0.7 , na.color = &quot;transparent&quot; ) 5.3 Canopy height model (CHM) Map Map the SfM-derived canopy height model which is a measurement of the height of trees above the ground topography. mapview::mapview( bhef_boundary , color = &quot;black&quot; , lwd = 3 , alpha.regions = 0 , layer.name = &quot;BHEF&quot; , label = FALSE , legend = FALSE , popup = FALSE ) + # aggregate raster and map mapview::mapview( chm_rast_temp , layer.name = &quot;canopy ht. (ft)&quot; , col.regions = viridis::plasma(n=50) , alpha.regions = 0.7 , na.color = &quot;transparent&quot; ) # # tree_tops # mapview::mapview( # treetops_sf_with_dbh # , cex = 0.5 # , layer.name = &quot;tree tops&quot; # , label = F # , legend = F # , popup = F # ) 5.4 DBH Distribution DBH distribution of trees that are in a harvested unit. Trees within harvest unit boundaries have a DBH range from 0.1 in (0.2 cm) to 28.3 in (71.8 cm) with a median of 3.2 in (8.2 cm). harvests_trees %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(treeID, dbh_in) %&gt;% dplyr::distinct() %&gt;% ggplot( mapping = aes(x = dbh_in) ) + geom_density(alpha = 0.8, fill = &quot;navy&quot;, color = NA) + labs( x = &quot;DBH (in)&quot; , y = &quot;density&quot; , title = &quot;SfM-derived tree DBH distribution&quot; ) + scale_x_continuous(breaks = scales::extended_breaks(n=20)) + theme_light() + theme( legend.position = &quot;none&quot; ) 5.5 Height Distribution Height distribution of trees that are in a harvested unit. Trees within harvest unit boundaries have a height range from 4.5 ft (1.4 m) to 90.9 ft (27.7 m) with a median of 16.8 ft (5.1 m). harvests_trees %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(treeID, tree_height_ft) %&gt;% dplyr::distinct() %&gt;% ggplot( mapping = aes(x = tree_height_ft) ) + geom_density(alpha = 0.8, fill = &quot;steelblue&quot;, color = NA) + labs( x = &quot;Height (ft)&quot; , y = &quot;density&quot; , title = &quot;SfM-derived tree height distribution&quot; ) + scale_x_continuous(breaks = scales::extended_breaks(n=10)) + theme_light() + theme( legend.position = &quot;none&quot; ) 5.6 Relationship between height and DBH ### plot harvests_trees %&gt;% sf::st_drop_geometry() %&gt;% dplyr::slice_sample(prop = 0.2) %&gt;% dplyr::select(treeID, tree_height_ft, dbh_in) %&gt;% dplyr::distinct() %&gt;% ggplot( mapping = aes(y=tree_height_ft, x = dbh_in) ) + geom_point( alpha = 0.6 , size = 0.6 , color = &quot;gray&quot; ) + geom_smooth( method = &quot;loess&quot; , se = F , span = 1 , color = &quot;gray33&quot; , alpha = 0.7 ) + labs( x = &quot;DBH (in)&quot; , y = &quot;Tree Ht. (ft)&quot; , title = &quot;SfM-derived tree height and DBH relationship&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; ) "],["ostory_valid.html", "Section 6 Overstory Field Validation Data 6.1 Load Field Data 6.2 Build UAS-Field Validation Data 6.3 Summary of Validation Data 6.4 Commission and Omission Locations", " Section 6 Overstory Field Validation Data Tinkham and Swayze (2021; p.6) describe a methodology for matching UAS detected trees with stem mapped trees identified via traditional field survey methods. Note, detected trees in the excerpt below references UAS detected trees while survey trees references field-based stem mapped trees: Each of the detected tree outputs was matched with survey tree locations through an iterative process. Iteratively, a detected tree was selected, and all survey trees within a 3 m radius and 10% height of the detected tree were identified. If a survey tree met both the location and height precision requirements, it was considered a true positive (TP) detection, and both the survey and detected trees were removed from further matching. However, if no match was made, the detected tree was considered a commission (Co) and removed from further matching. This process was repeated until all detected trees were classified as true positive or commission, with all unmatched survey trees classified as omission (Om). Overall tree detection performance was described using the F-score metric. The F-score incorporates true positive, commission, and omission rates to determine how well the UAS detected trees represent the field-based stem mapped trees. As a measure of predictive performance, the highest possible value of an F-score is 1.0, indicating perfect precision and recall, and the lowest possible value is 0, if either precision or recall are zero. \\[ \\textrm{F-score} = 2 \\times \\frac{\\bigl(\\frac{TP}{TP+Om} \\times \\frac{TP}{TP+Co} \\bigr)}{\\bigl(\\frac{TP}{TP+Om} + \\frac{TP}{TP+Co} \\bigr)} \\] The process to match UAS detected trees to field stem mapped trees implemented here is slightly different than the process described above. To match the data parametrization from the UAS point cloud processing workflow, only stem-mapped trees above 1.4 m were considered for analysis. Each UAS detected tree was matched with stem-mapped tree locations that were within a 3 m radius and 2 m height of the UAS detected tree. The matched UAS and stem-mapped tree pairs were jointly compared (rather than iteratively) to select the pair that minimized the height difference for both the stem-mapped tree and the UAS detected tree to ensure that only one UAS detected tree was selected for each stem-mapped tree. If more than one UAS detected tree had the same height difference to a stem-mapped tree, the UAS detected tree spatially nearest to the stem-mapped tree was selected as the match. These UAS detected trees with a paired stem-mapped tree after this filtering process were considered true positive (\\(TP\\)) detections. To determine UAS detected tree commissions (i.e. UAS detected trees within the overstory plot for which there was no stem-mapped tree pair; \\(Co\\)) this analysis used the 2023-06 BHEF overstory field survey plot center and plot radius with a minimum DBH of 5 in (12.69 cm) as only trees above this size were sampled as part of the overstory survey. UAS detected trees within this radius with an estimated DBH over 5 in (12.69 cm) that did not have a matched stem-mapped tree pair were considered commissions (\\(Co\\)). The 2023-06 BHEF field surveys used \\(\\frac{1}{10}\\) acre (404.686 m2) plots with a 37.24 ft (11.35 m) radius for overstory sampling and \\(\\frac{1}{400}\\) acre (10.117 m2) plots with a 5.89 ft (1.795 m) radius for regeneration sampling. All unmatched stem-mapped survey trees were classified as omissions (\\(Om\\)). 6.1 Load Field Data Load the overstory data, set parameters for processing, and map ################################################################################################## ## USER DEFINED PARAMETERS ################################################################################################## ### Only include trees above a specific height # e.g., set to match the minimum height used in point cloud processing min_tree_height_m = min(chm_rast %&gt;% terra::values(), na.rm = T) ### Only include trees above a specific DBH # e.g., set to match the minimum tree DBH for field sampling of overstory trees min_tree_dbh_cm = 5*2.54 # 3 in = 7.62 cm ### Find all nearest neighbors within maximum distance and then filter them based on ### distance and height error max_dist_m = 3 max_height_error_m = 2 ################################################################################################## ## USER DEFINED PARAMETERS ################################################################################################## # load Field Validation Data field_overstory = readr::read_csv( file = &quot;../data/field_data/Voodoo_overstory_data.csv&quot; ) %&gt;% dplyr::rename_with(~ .x %&gt;% # replace all non alphanumeric with _ stringr::str_replace_all(&quot;[^[:alnum:] ]+&quot;, &quot;_&quot;) %&gt;% # remove any _ at the end of the string stringr::str_remove(&quot;[_]$&quot;) %&gt;% tolower() ) %&gt;% dplyr::filter( !is.na(tree_diameter_inches) &amp; !is.na(tree_height_feet) &amp; !is.na(tree_utm_x) &amp; !is.na(tree_utm_y) ) %&gt;% dplyr::mutate( field_dbh_cm = tree_diameter_inches/0.394 , field_tree_height_m = tree_height_feet/3.281 , field_plottree_id = paste0( stringr::str_pad(plot_id, width = 4, side = &quot;left&quot;, pad = &quot;0&quot;) , &quot;-&quot; , stringr::str_pad(tree_id, width = 4, side = &quot;left&quot;, pad = &quot;0&quot;) ) ) %&gt;% dplyr::filter( field_tree_height_m &gt;= min_tree_height_m &amp; field_dbh_cm &gt;= min_tree_dbh_cm ) %&gt;% dplyr::rename( field_dbh_in = tree_diameter_inches , field_tree_height_ft = tree_height_feet ) %&gt;% sf::st_as_sf( coords = c(&quot;tree_utm_x&quot;, &quot;tree_utm_y&quot;) , crs = sf::st_crs(treetops_sf_with_dbh) , remove=F ) %&gt;% # keep only tree points that are within the uas flight boundary sf::st_intersection(las_ctg_dta) # field_overstory %&gt;% # sf::st_drop_geometry() %&gt;% # dplyr::summarize(n = dplyr::n(), unique_tree = dplyr::n_distinct(field_plottree_id)) field_overstory %&gt;% dplyr::glimpse() ## Rows: 362 ## Columns: 26 ## $ plot_id &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1,… ## $ observers_on_plot &lt;chr&gt; &quot;WT&quot;, &quot;WT&quot;, &quot;WT&quot;, &quot;WT&quot;, &quot;W… ## $ collection_date &lt;chr&gt; &quot;6/8/2023 18:00&quot;, &quot;6/8/202… ## $ comments_on_plot_condition_or_abnormalities &lt;chr&gt; NA, &quot;Azimuth changed 180&quot;,… ## $ x &lt;dbl&gt; -103.6439, -103.6439, -103… ## $ y &lt;dbl&gt; 44.14773, 44.14773, 44.147… ## $ tree_id &lt;dbl&gt; 5, 1, 8, 3, 7, 9, 6, 4, 2,… ## $ species &lt;chr&gt; &quot;Pinus ponderosa&quot;, &quot;Pinus … ## $ tree_condition &lt;chr&gt; &quot;Live&quot;, &quot;Live&quot;, &quot;Live&quot;, &quot;L… ## $ field_dbh_in &lt;dbl&gt; 6.3, 7.1, 9.8, 10.9, 12.7,… ## $ tree_distance_from_plot_center_ft &lt;dbl&gt; 19.0, 30.3, 15.7, 25.9, 32… ## $ azimuth_to_tree_degrees &lt;dbl&gt; 172, 211, 298, 49, 270, 30… ## $ field_tree_height_ft &lt;dbl&gt; 26.1, 44.0, 46.9, 61.0, 50… ## $ tree_crown_base_height_feet &lt;dbl&gt; 8.3, 19.5, 23.7, 26.3, 23.… ## $ tree_remarks &lt;chr&gt; NA, NA, NA, NA, NA, &quot;Broke… ## $ parentglobalid &lt;chr&gt; &quot;c353aaf9-de68-4a61-8d39-4… ## $ uniqueid &lt;chr&gt; &quot;c353aaf9-de68-4a61-8d39-4… ## $ ba &lt;dbl&gt; 0.2164693, 0.2749361, 0.52… ## $ utm_x &lt;dbl&gt; 608461.1, 608461.1, 608461… ## $ utm_y &lt;dbl&gt; 4889177, 4889177, 4889177,… ## $ tree_utm_y &lt;dbl&gt; 4889171, 4889169, 4889179,… ## $ tree_utm_x &lt;dbl&gt; 608461.9, 608456.4, 608456… ## $ field_dbh_cm &lt;dbl&gt; 15.98985, 18.02030, 24.873… ## $ field_tree_height_m &lt;dbl&gt; 7.954892, 13.410546, 14.29… ## $ field_plottree_id &lt;chr&gt; &quot;0001-0005&quot;, &quot;0001-0001&quot;, … ## $ geometry &lt;POINT [m]&gt; POINT (608461.9 4889… Overstory field data map field_overstory %&gt;% sf::st_drop_geometry() %&gt;% dplyr::distinct(plot_id, utm_x, utm_y) %&gt;% sf::st_as_sf(coords = c(&quot;utm_x&quot;, &quot;utm_y&quot;), crs = sf::st_crs(treetops_sf_with_dbh)) %&gt;% sf::st_buffer(11.35) %&gt;% dplyr::mutate(x=1) %&gt;% mapview::mapview(col.regions = &quot;blue&quot;, layer.name = &quot;plot&quot;, alpha.regions = 0.6) + mapview::mapview(field_overstory, col.regions = &quot;orange&quot;, cex = 2, layer.name = &quot;trees&quot;) + mapview::mapview( harvests , color = &quot;black&quot; , lwd = 3 , alpha.regions = 0 , label = FALSE , legend = FALSE , popup = FALSE ) 6.2 Build UAS-Field Validation Data 6.2.1 True Positive Identification The UAS detected and stem-mapped tree pairs identified in this filtering process (detailed above) were considered true positive (\\(TP\\)) detections. ## BUFFER THE UAS TREES AND SPATIALLY MATCH FIELD TREES BASED ON THAT BUFFER ## get FIELD trees within radius OF UAS TREES potential_tree_pairs_temp = treetops_sf_with_dbh %&gt;% dplyr::select(treeID, tree_height_m) %&gt;% # buffer point sf::st_buffer(max_dist_m) %&gt;% # spatial join with all FIELD tree points sf::st_join( field_overstory %&gt;% dplyr::filter( field_tree_height_m &gt;= min_tree_height_m &amp; field_dbh_cm &gt;= min_tree_dbh_cm ) %&gt;% dplyr::select( field_plottree_id, field_tree_height_m , tree_utm_x, tree_utm_y ) , join = st_intersects , left = F # performs inner join to only keep uas trees with a match ) %&gt;% # calculate height difference dplyr::mutate( height_diff_m = abs(tree_height_m-field_tree_height_m) , height_diff_pct = height_diff_m/field_tree_height_m ) %&gt;% # removes tree pairs that are outside of the allowable error # dplyr::filter(height_diff_pct &lt;= max_height_error_pct) %&gt;% dplyr::filter(height_diff_m &lt;= max_height_error_m) %&gt;% dplyr::select(-c(height_diff_m)) %&gt;% dplyr::relocate(treeID, field_plottree_id) ## apply pair selection criteria if there are potential tree pairs if(nrow(potential_tree_pairs_temp)&gt;0){ ## calculate row by row distances and height differences potential_tree_pairs_temp = potential_tree_pairs_temp %&gt;% # this is the position of the uas tree sf::st_centroid() %&gt;% sf::st_set_geometry(&quot;geom1&quot;) %&gt;% dplyr::bind_cols( potential_tree_pairs_temp %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(&quot;tree_utm_x&quot;, &quot;tree_utm_y&quot;) %&gt;% # this is the position of the field tree sf::st_as_sf( coords = c(&quot;tree_utm_x&quot;, &quot;tree_utm_y&quot;), crs = sf::st_crs(treetops_sf_with_dbh) ) %&gt;% sf::st_set_geometry(&quot;geom2&quot;) ) %&gt;% dplyr::mutate( distance_m = sf::st_distance(geom1, geom2, by_element = T) %&gt;% as.numeric() ) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(-c(tree_utm_x, tree_utm_y, geom2)) ## define function to select the best tree pair select_best_tree_pair_fn &lt;- function(df) { df %&gt;% dplyr::group_by(field_plottree_id) %&gt;% dplyr::arrange(field_plottree_id, height_diff_pct, distance_m, desc(tree_height_m), treeID) %&gt;% dplyr::mutate( # at the field tree level...the number of uas trees n_uas_trees = dplyr::n() # at the field tree level... # the closest uas tree in height tie breaker distance, uas_tree_height_m, id , rank_within_field_tree = dplyr::row_number() ) %&gt;% dplyr::group_by(treeID) %&gt;% dplyr::arrange(treeID, height_diff_pct, distance_m, desc(field_tree_height_m), field_plottree_id) %&gt;% dplyr::mutate( # at the uas tree level...the number of field trees n_field_trees = dplyr::n() # at the field tree level... # the closest field tree in height tie breaker distance, uas_tree_height_m, id , rank_within_uas_tree = dplyr::row_number() ) %&gt;% dplyr::ungroup() %&gt;% # select the uas-field tree pair with the minimum height difference dplyr::filter( rank_within_field_tree == 1 &amp; rank_within_uas_tree == 1 ) %&gt;% # remove columns dplyr::select( -c(tidyselect::starts_with(&quot;rank_&quot;), tidyselect::starts_with(&quot;n_&quot;)) ) } ## first filter for tree pairs true_positive_trees = select_best_tree_pair_fn(potential_tree_pairs_temp) ##remove matches from potential tree pairs potential_tree_pairs_temp = potential_tree_pairs_temp %&gt;% dplyr::filter( !(treeID %in% true_positive_trees$treeID) &amp; !(field_plottree_id %in% true_positive_trees$field_plottree_id) ) ## keep filtering for best pair until no unique pairs remain while(nrow(potential_tree_pairs_temp)&gt;0) { # keep filtering for best pair until no unique pairs remain true_positive_trees = true_positive_trees %&gt;% dplyr::bind_rows( select_best_tree_pair_fn(potential_tree_pairs_temp) ) #remove matches from potential tree pairs potential_tree_pairs_temp = potential_tree_pairs_temp %&gt;% dplyr::filter( !(treeID %in% true_positive_trees$treeID) &amp; !(field_plottree_id %in% true_positive_trees$field_plottree_id) ) } ## rename columns and flag true_positive_trees = true_positive_trees %&gt;% dplyr::rename( uas_tree_height_m = tree_height_m , uas_tree_id = treeID , field_uas_distance_m = distance_m ) %&gt;% dplyr::mutate( field_uas_group = &quot;true positive&quot; ) }else{ # if there are spatially matched trees true_positive_trees = dplyr::tibble( uas_tree_id = as.character(NA) , field_plottree_id = as.character(NA) , uas_tree_height_m = as.numeric(NA) , field_tree_height_m = as.numeric(NA) , height_diff_pct = as.numeric(NA) , field_uas_distance_m = as.numeric(NA) , field_uas_group = as.character(NA) ) } remove(potential_tree_pairs_temp) gc() True positive detections #check data true_positive_trees %&gt;% dplyr::summarise( n_rows = n() , unique_uas_trees = n_distinct(uas_tree_id) , unique_field_trees = n_distinct(field_plottree_id) , unique_pairs = n_distinct(field_plottree_id, uas_tree_id) ) %&gt;% kableExtra::kbl(caption = &quot;results of true positive stem-uas tree matching&quot;) %&gt;% kableExtra::kable_styling() Table 6.1: results of true positive stem-uas tree matching n_rows unique_uas_trees unique_field_trees unique_pairs 41 41 41 41 6.2.2 Combine with Commission and Omission To determine UAS detected tree commissions (i.e. UAS detected trees within the overstory plot for which there was no stem-mapped tree pair; \\(Co\\)) this analysis used the 2023-06 BHEF overstory field survey plot center and plot radius of 11.35 m. UAS detected trees within this radius with an estimated DBH over 5 in (12.69 cm) that did not have a matched stem-mapped tree pair were considered commissions (\\(Co\\)). Omissions (\\(Om\\)) are stem-mapped trees without a UAS detected tree match. field_uas_comparison = dplyr::bind_rows( ## true positive true_positive_trees ## omission , field_overstory %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select( plot_id, field_plottree_id, field_tree_height_m ) %&gt;% dplyr::anti_join( true_positive_trees , by = dplyr::join_by(field_plottree_id) ) %&gt;% dplyr::mutate( field_uas_group = &quot;omission&quot; ) ## commission , field_overstory %&gt;% sf::st_drop_geometry() %&gt;% # get field plot center locations dplyr::distinct(plot_id, utm_x, utm_y) %&gt;% sf::st_as_sf(coords = c(&quot;utm_x&quot;, &quot;utm_y&quot;), crs = sf::st_crs(treetops_sf_with_dbh)) %&gt;% # buffer plot center with plot area 11.35m radius + mean error in true positive trees # sf::st_buffer(11.35+mean(true_positive_trees$field_uas_distance_m, na.rm = T)) %&gt;% # buffer plot center with plot area 11.35m radius sf::st_buffer(11.35) %&gt;% # join with uas tree points sf::st_join( treetops_sf_with_dbh %&gt;% dplyr::filter( !treeID %in% true_positive_trees$uas_tree_id &amp; dbh_cm &gt;= min_tree_dbh_cm &amp; tree_height_m &gt;= min_tree_height_m ) %&gt;% dplyr::select(treeID) %&gt;% dplyr::rename(uas_tree_id=treeID) , join = st_intersects , left = F # performs inner join to only keep uas trees and plots with a match ) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::mutate( field_uas_group = &quot;commission&quot; ) ) %&gt;% # attach uas data dplyr::left_join( treetops_sf_with_dbh %&gt;% sf::st_set_geometry(&quot;geometry&quot;) %&gt;% dplyr::mutate( uas_tree_utm_x = sf::st_coordinates(geometry)[,1] #lon , uas_tree_utm_y = sf::st_coordinates(geometry)[,2] #lat ) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(treeID, tree_height_m, dbh_cm, uas_tree_utm_x, uas_tree_utm_y) %&gt;% dplyr::rename( uas_tree_id = treeID , uas_tree_height_m = tree_height_m , uas_dbh_cm = dbh_cm ) , by = dplyr::join_by(uas_tree_id) ) %&gt;% # attach field data dplyr::left_join( field_overstory %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select( field_plottree_id, field_tree_height_m, field_dbh_cm, plot_id , tree_utm_x, tree_utm_y ) %&gt;% dplyr::rename( field_tree_utm_x = tree_utm_x , field_tree_utm_y = tree_utm_y ) , by = dplyr::join_by(field_plottree_id) ) %&gt;% # update data dplyr::mutate( uas_tree_height_m = uas_tree_height_m.y , field_tree_height_m = field_tree_height_m.y , plot_id = dplyr::coalesce(plot_id.x, plot_id.y) , field_uas_group = factor( field_uas_group , ordered = T , levels = c( &quot;true positive&quot; , &quot;commission&quot; , &quot;omission&quot; ) ) %&gt;% forcats::fct_rev() , dbh_diff_cm = uas_dbh_cm - field_dbh_cm , tree_height_diff_m = uas_tree_height_m - field_tree_height_m , dbh_diff_pct = dbh_diff_cm/field_dbh_cm , height_diff_pct = tree_height_diff_m/field_tree_height_m , abs_dbh_diff_pct = abs(dbh_diff_pct) , abs_height_diff_pct = abs(height_diff_pct) , plot_lab = stringr::str_pad(plot_id, width = 4, side = &quot;left&quot;, pad = &quot;0&quot;) ) %&gt;% dplyr::relocate(field_uas_group) %&gt;% dplyr::select(-c(tidyselect::ends_with(&quot;.x&quot;), tidyselect::ends_with(&quot;.y&quot;))) %&gt;% # convert to imperial units calc_imperial_units_fn() ## write write.csv(field_uas_comparison, paste0(delivery_dir,&quot;/field_uas_comparison_data.csv&quot;), row.names = F) ## aggregate data to plot level field_uas_comparison_plot = field_uas_comparison %&gt;% dplyr::count(plot_id, plot_lab, field_uas_group) %&gt;% dplyr::group_by(plot_id, plot_lab) %&gt;% dplyr::mutate( pct = n/sum(n) , tot = sum(n) , tp_pct=max(ifelse(field_uas_group==&quot;true positive&quot;,pct,0)) ) %&gt;% dplyr::ungroup() %&gt;% # attach f score dplyr::inner_join( field_uas_comparison %&gt;% dplyr::count(plot_id, field_uas_group) %&gt;% dplyr::mutate(field_uas_group = dplyr::case_when( field_uas_group == &quot;true positive&quot; ~ &quot;tp&quot; , field_uas_group == &quot;commission&quot; ~ &quot;co&quot; , field_uas_group == &quot;omission&quot; ~ &quot;om&quot; )) %&gt;% tidyr::pivot_wider( names_from = field_uas_group , values_from = n , values_fill = 0 ) %&gt;% dplyr::mutate( plot_f_score = dplyr::coalesce( 2 * ( (tp/(tp+om)) * (tp/(tp+co)) ) / ( (tp/(tp+om)) + (tp/(tp+co)) ) , 0 ) ) %&gt;% dplyr::select(plot_id, plot_f_score) , by = dplyr::join_by(plot_id) ) 6.3 Summary of Validation Data 6.3.1 True Positive, Commission, Ommission Summary of tree true positive (\\(TP\\)), commission (\\(Co\\)), and omission (\\(Om\\)) detection by BHEF overstory plot. field_uas_comparison_plot %&gt;% ggplot( mapping = aes(x = pct, y = reorder(plot_lab, tp_pct), fill=field_uas_group, group=field_uas_group) ) + geom_col( width = 0.7, alpha=0.8 ) + geom_text( mapping = aes( label = scales::percent(ifelse(pct&gt;=0.12,pct,NA), accuracy = 1) , fontface = &quot;bold&quot; ) , position = position_stack(vjust = 0.5) , color = &quot;black&quot;, size = 2.3 ) + scale_fill_viridis_d(option = &quot;cividis&quot;) + scale_x_continuous(labels = scales::percent_format()) + labs( fill = &quot;&quot; , y = &quot;&quot; , x = &quot;Percent of Trees&quot; , title = &quot;UAS and Stem-Mapped Tree Validation Summary&quot; , subtitle = &quot;by overstory plot&quot; ) + theme_light() + theme( legend.position = &quot;top&quot; , legend.direction = &quot;horizontal&quot; , legend.title = element_text(size=7) , axis.title.x = element_text(size=10, face = &quot;bold&quot;) , axis.title.y = element_blank() , axis.text.x = element_blank() , axis.text.y = element_text(color = &quot;black&quot;,size=10, face = &quot;bold&quot;) , axis.ticks.x = element_blank() ) + guides( fill = guide_legend(reverse = T, override.aes = list(alpha = 0.9)) ) 6.3.2 F-score field_uas_comparison_plot %&gt;% dplyr::distinct(plot_lab, plot_f_score) %&gt;% ggplot( mapping = aes(x = plot_f_score, y = reorder(plot_lab, plot_f_score), fill=plot_f_score, label = scales::comma(plot_f_score, accuracy = 0.01)) ) + geom_vline( xintercept = field_uas_comparison_plot %&gt;% dplyr::distinct(plot_lab, plot_f_score) %&gt;% dplyr::pull(plot_f_score) %&gt;% median() , color = &quot;gray44&quot; , linetype = &quot;dashed&quot; ) + geom_col( width = 0.7, alpha=0.8 ) + geom_text( color = &quot;black&quot;, size = 3.5 , hjust = -0.1 ) + annotate( &quot;text&quot; , x = field_uas_comparison_plot %&gt;% dplyr::distinct(plot_lab, plot_f_score) %&gt;% dplyr::pull(plot_f_score) %&gt;% median() , y = 0 , label = paste0( &quot;median: &quot; , field_uas_comparison_plot %&gt;% dplyr::distinct(plot_lab, plot_f_score) %&gt;% dplyr::pull(plot_f_score) %&gt;% median() %&gt;% scales::comma(accuracy = 0.01) ) , hjust = -0.1 , vjust = -1 ) + scale_fill_viridis_c(option = &quot;mako&quot;, direction = -1) + labs( fill = &quot;&quot; , y = &quot;&quot; , x = &quot;F-Score&quot; , title = &quot;UAS and Stem-Mapped Tree F-Score Summary&quot; , subtitle = &quot;by overstory plot&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.title.x = element_text(size=10, face = &quot;bold&quot;) , axis.title.y = element_blank() , axis.text.x = element_blank() , axis.text.y = element_text(color = &quot;black&quot;,size=10, face = &quot;bold&quot;) , axis.ticks.x = element_blank() ) 6.3.3 Height vs. DBH of \\(Tp\\), \\(Co\\), \\(Om\\) field_uas_comparison %&gt;% dplyr::mutate( dbh_temp = dplyr::coalesce(field_dbh_in, uas_dbh_in) , ht_temp = dplyr::coalesce(field_tree_height_ft, uas_tree_height_ft) ) %&gt;% ggplot( mapping = aes(x = ht_temp, y = dbh_temp, color = field_uas_group) ) + geom_point( mapping = aes(shape = field_uas_group) , alpha=0.8 , size=2 ) + scale_color_viridis_d(option = &quot;cividis&quot;) + scale_x_continuous(breaks = scales::extended_breaks(n=8)) + scale_y_continuous(breaks = scales::extended_breaks(n=8)) + labs( color = &quot;detection&quot; , shape = &quot;detection&quot; , y = &quot;DBH (in)&quot; , x = &quot;Tree Ht. (ft)&quot; , title = &quot;UAS and Stem-Mapped Tree Validation Summary&quot; , subtitle = &quot;height and DBH relationship&quot; ) + theme_light() + theme( legend.position = &quot;top&quot; , legend.direction = &quot;horizontal&quot; , legend.title = element_blank() ) + guides( color = guide_legend(reverse = T, override.aes = list(alpha = 0.9, size = 5)) , shape = guide_legend(reverse = T, override.aes = list(alpha = 0.9, size = 5)) ) 6.3.4 Height and DBH Distribution \\(Tp\\), \\(Co\\), \\(Om\\) field_uas_comparison %&gt;% dplyr::mutate( dbh = dplyr::coalesce(field_dbh_in, uas_dbh_in) , height = dplyr::coalesce(field_tree_height_ft, uas_tree_height_ft) ) %&gt;% dplyr::select(dbh, height, field_uas_group) %&gt;% tidyr::pivot_longer(cols = -c(field_uas_group), names_to = &quot;metric&quot;, values_to = &quot;value&quot;) %&gt;% dplyr::group_by(field_uas_group,metric) %&gt;% dplyr::mutate( metric = dplyr::case_when( metric == &quot;dbh&quot; ~ &quot;DBH (in)&quot; , metric == &quot;height&quot; ~ &quot;Height (ft)&quot; ) , n_rows = dplyr::n() , plot_lab = paste0( field_uas_group ,&quot; (n=&quot;, scales::comma(n_rows,accuracy=1),&quot;)&quot; ) ) %&gt;% ggplot(mapping = aes(x = value, y = plot_lab, fill = field_uas_group)) + geom_violin(outlier.shape = NA) + geom_boxplot(width = 0.1, outlier.shape = NA, color = &quot;gray66&quot;) + facet_grid(cols = vars(metric), scales = &quot;free_x&quot;) + scale_fill_viridis_d(option = &quot;cividis&quot;) + scale_x_continuous(breaks = scales::extended_breaks(n=8)) + labs( fill = &quot;&quot; , y = &quot;&quot; , x = &quot;&quot; , title = &quot;UAS and Stem-Mapped Tree Validation Summary&quot; , subtitle = &quot;height and DBH distribution comparison&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.title.x = element_text(size=10, face = &quot;bold&quot;) , axis.title.y = element_blank() , axis.text.y = element_text(color = &quot;black&quot;,size=10, face = &quot;bold&quot;, hjust = 0) , strip.text = element_text(color = &quot;black&quot;, size = 12) , strip.background = element_rect(fill = &quot;gray88&quot;) ) 6.3.5 Detected Overstory (\\(TP\\)) Height Difference Detected overstory tree (\\(TP\\)) height reliability. Where overstory trees considered in this analysis had a tree height &gt;= 4.5 ft and a tree DBH &gt;= 5.0 in. field_uas_comparison %&gt;% dplyr::filter(field_uas_group == &quot;true positive&quot;) %&gt;% dplyr::group_by(plot_lab) %&gt;% dplyr::mutate( reorder_y = median(height_diff_pct, na.rm=T) , color_box = reorder_y&lt;0 , n_rows = dplyr::n() , plot_lab = paste0( plot_lab ,&quot; (n=&quot;, scales::comma(n_rows,accuracy=1),&quot;)&quot; ) ) %&gt;% ggplot(mapping = aes(x = height_diff_pct, y = reorder(plot_lab, reorder_y) )) + # height_diff_pct geom_vline(xintercept = 0, color = &quot;gray22&quot;) + geom_boxplot(mapping = aes(fill = color_box), alpha = 0.8, width = 0.7, outlier.shape = NA) + scale_fill_manual(values = c(&quot;steelblue&quot;, &quot;coral&quot;)) + geom_point(color = &quot;black&quot;, shape = &quot;.&quot;) + scale_x_continuous( labels = scales::percent_format() , breaks = scales::extended_breaks(n=8) , limits = c( -max(field_uas_comparison$abs_height_diff_pct, na.rm = T) , max(field_uas_comparison$abs_height_diff_pct, na.rm = T) ) ) + labs( fill = &quot;&quot; , y = &quot;&quot; , x = &quot;Percent Difference in Height&quot; , title = &quot;Detected Overstory Height Difference&quot; , subtitle = &quot;by overstory plot&quot; , caption = &quot;-values = UAS&lt;field | +values = UAS&gt;field&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.title.x = element_text(size=10, face = &quot;bold&quot;) , axis.title.y = element_blank() , axis.text.y = element_text(color = &quot;black&quot;,size=10, face = &quot;bold&quot;, hjust = 0) ) 6.3.6 Detected Overstory (\\(TP\\)) DBH Difference Detected overstory tree (\\(TP\\)) DBH reliability. Where overstory trees considered in this analysis had a tree height &gt;= 4.5 ft and a tree DBH &gt;= 5.0 in. field_uas_comparison %&gt;% dplyr::filter(field_uas_group == &quot;true positive&quot;) %&gt;% dplyr::group_by(plot_lab) %&gt;% dplyr::mutate( reorder_y = median(dbh_diff_pct, na.rm=T) , color_box = reorder_y&lt;0 , n_rows = dplyr::n() , plot_lab = paste0( plot_lab ,&quot; (n=&quot;, scales::comma(n_rows,accuracy=1),&quot;)&quot; ) ) %&gt;% ggplot(mapping = aes(x = dbh_diff_pct, y = reorder(plot_lab, reorder_y) )) + # dbh_diff_pct geom_vline(xintercept = 0, color = &quot;gray22&quot;) + geom_boxplot(mapping = aes(fill = color_box), alpha = 0.8, width = 0.7, outlier.shape = NA) + scale_fill_manual(values = c(&quot;steelblue&quot;, &quot;coral&quot;)) + geom_point(color = &quot;black&quot;, shape = &quot;.&quot;) + scale_x_continuous( labels = scales::percent_format() , breaks = scales::extended_breaks(n=8) , limits = c( -max(field_uas_comparison$abs_dbh_diff_pct, na.rm = T) , max(field_uas_comparison$abs_dbh_diff_pct, na.rm = T) ) ) + labs( fill = &quot;&quot; , y = &quot;&quot; , x = &quot;Percent Difference in DBH&quot; , title = &quot;Detected Overstory DBH Difference&quot; , subtitle = &quot;by overstory plot&quot; , caption = &quot;-values = UAS&lt;field | +values = UAS&gt;field&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.title.x = element_text(size=10, face = &quot;bold&quot;) , axis.title.y = element_blank() , axis.text.y = element_text(color = &quot;black&quot;,size=10, face = &quot;bold&quot;, hjust = 0) ) 6.3.7 Detected Overstory (\\(TP\\)) Reliability Overstory trees considered in this analysis had a tree height &gt;= 4.5 ft and a tree DBH &gt;= 5.0 in. dbh_f_temp = field_uas_comparison %&gt;% dplyr::filter(field_uas_group==&quot;true positive&quot;) %&gt;% dplyr::pull(field_dbh_in) dbh_u_temp = field_uas_comparison %&gt;% dplyr::filter(field_uas_group==&quot;true positive&quot;) %&gt;% dplyr::pull(uas_dbh_in) ht_f_temp = field_uas_comparison %&gt;% dplyr::filter(field_uas_group==&quot;true positive&quot;) %&gt;% dplyr::pull(field_tree_height_ft) ht_u_temp = field_uas_comparison %&gt;% dplyr::filter(field_uas_group==&quot;true positive&quot;) %&gt;% dplyr::pull(uas_tree_height_ft) data.frame( mae_dbh = Metrics::mae( dbh_f_temp , dbh_u_temp ) , mape_dbh = Metrics::mape( dbh_f_temp , dbh_u_temp ) , rmse_dbh = Metrics::rmse( dbh_f_temp , dbh_u_temp ) ## height , mae_height = Metrics::mae( ht_f_temp , ht_u_temp ) , mape_height = Metrics::mape( ht_f_temp , ht_u_temp ) , rmse_height = Metrics::rmse( ht_f_temp , ht_u_temp ) ) %&gt;% tidyr::pivot_longer(dplyr::everything()) %&gt;% tidyr::separate_wider_delim(cols = name, delim = &quot;_&quot;, names = c(&quot;error&quot;, &quot;metric&quot;)) %&gt;% tidyr::pivot_wider(names_from = error, values_from = value) %&gt;% dplyr::mutate( metric = dplyr::case_when( metric == &quot;dbh&quot; ~ &quot;DBH (in)&quot; , metric == &quot;height&quot; ~ &quot;Height (ft)&quot; ) , n = field_uas_comparison %&gt;% dplyr::filter(field_uas_group==&quot;true positive&quot;) %&gt;% nrow() ) %&gt;% kableExtra::kbl( caption = &quot;Detected overstory tree height and DBH prediction performance&quot; , col.names = c( &quot; &quot; , &quot;Mean Abs. Error&quot; , &quot;Mean Abs. Percent Error&quot; , &quot;Root Mean Squared Error&quot; , &quot;N&quot; ) , digits = 2 ) %&gt;% kableExtra::kable_styling() Table 6.2: Detected overstory tree height and DBH prediction performance Mean Abs. Error Mean Abs. Percent Error Root Mean Squared Error N DBH (in) 2.05 0.24 3.18 41 Height (ft) 2.69 0.09 3.22 41 6.3.8 Detected Overstory (\\(TP\\)) Distribution Comparison field_uas_comparison %&gt;% dplyr::filter(field_uas_group==&quot;true positive&quot;) %&gt;% dplyr::select(c( tidyselect::ends_with(&quot;_dbh_in&quot;) , tidyselect::ends_with(&quot;_height_ft&quot;) )) %&gt;% dplyr::rename_with( .fn = function(x){dplyr::case_when( stringr::str_ends(x,&quot;_dbh_in&quot;) ~ stringr::str_replace(x,&quot;_dbh_in&quot;,&quot;_dbh&quot;) , stringr::str_ends(x,&quot;_tree_height_ft&quot;) ~ stringr::str_replace(x,&quot;_tree_height_ft&quot;,&quot;_height&quot;) , TRUE ~ x )} ) %&gt;% tidyr::pivot_longer(dplyr::everything()) %&gt;% tidyr::separate_wider_delim( cols = name , delim = &quot;_&quot; , names = c(&quot;source&quot;, &quot;metric&quot;) ) %&gt;% dplyr::mutate( metric = dplyr::case_when( metric == &quot;dbh&quot; ~ &quot;DBH (in)&quot; , metric == &quot;height&quot; ~ &quot;Height (ft)&quot; ) , source = dplyr::case_when( source == &quot;uas&quot; ~ &quot;UAS&quot; , source == &quot;field&quot; ~ &quot;Stem Map&quot; ) , n = field_uas_comparison %&gt;% dplyr::filter(field_uas_group==&quot;true positive&quot;) %&gt;% nrow() ) %&gt;% ggplot(mapping = aes(x = value, y = source )) + geom_boxplot(mapping = aes(fill = source), alpha = 0.8, width = 0.7, outlier.shape = NA) + # geom_point(color = &quot;black&quot;, shape = &quot;.&quot;) + facet_grid(cols = vars(metric), scales = &quot;free_x&quot;) + scale_fill_manual(values = c(&quot;seagreen&quot;, &quot;slateblue&quot;)) + labs( fill = &quot;&quot; , y = &quot;&quot; , x = &quot;&quot; , title = &quot;Detected Overstory Distribution Comparison&quot; , subtitle = paste0( &quot;tree height &gt;= &quot; , scales::comma(min_tree_height_m*3.28, accuracy = 0.1) , &quot; ft and tree DBH &gt;= &quot; , scales::comma(min_tree_dbh_cm*0.394, accuracy = 0.1) , &quot; in&quot; ) ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.title.x = element_text(size=10, face = &quot;bold&quot;) , axis.title.y = element_blank() , axis.text.y = element_text(color = &quot;black&quot;,size=10, face = &quot;bold&quot;, hjust = 0) , strip.text = element_text(color = &quot;black&quot;, size = 12) , strip.background = element_rect(fill = &quot;gray88&quot;) ) 6.4 Commission and Omission Locations field_uas_comparison = field_uas_comparison %&gt;% dplyr::mutate( x = ifelse(!is.na(uas_tree_utm_x), uas_tree_utm_x, field_tree_utm_x) , y = ifelse(!is.na(uas_tree_utm_x), uas_tree_utm_y, field_tree_utm_y) ) %&gt;% sf::st_as_sf( coords = c(&quot;x&quot;, &quot;y&quot;) , crs = sf::st_crs(treetops_sf_with_dbh) , remove=T ) View omissions and commissions on satellite imagery field_overstory %&gt;% sf::st_drop_geometry() %&gt;% dplyr::distinct(plot_id, utm_x, utm_y) %&gt;% sf::st_as_sf(coords = c(&quot;utm_x&quot;, &quot;utm_y&quot;), crs = sf::st_crs(treetops_sf_with_dbh)) %&gt;% sf::st_buffer(11.35) %&gt;% dplyr::mutate(x=1) %&gt;% mapview::mapview( col.regions = &quot;blue&quot;, layer.name = &quot;plot&quot;, alpha.regions = 0.6 , popup = F ) + mapview::mapview( field_uas_comparison %&gt;% dplyr::filter(field_uas_group %in% c(&quot;commission&quot;, &quot;omission&quot;)) , zcol = &quot;field_uas_group&quot; , col.regions = viridis::cividis(n=3)[1:2] , cex = 2 , alpha.regions = 0.8 , layer.name = &quot;validation&quot; ) + mapview::mapview( harvests , color = &quot;black&quot; , lwd = 3 , alpha.regions = 0 , label = FALSE , legend = FALSE , popup = FALSE ) 6.4.1 Othomosaic Commission and Omission Locations Define function to plot orthomosaic + CHM + tree points + plot ###################################################################################### # function to plot ortho + chm + points + stand ###################################################################################### ortho_plt_fn = function(my_plotid){ # plot vector plot_temp = field_overstory %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(plot_id == my_plotid) %&gt;% dplyr::group_by(plot_id) %&gt;% dplyr::summarise( utm_x = dplyr::first(utm_x, na_rm = T), utm_y = dplyr::first(utm_y, na_rm = T) ) %&gt;% dplyr::mutate( plot_lab = stringr::str_pad(plot_id, width = 4, side = &quot;left&quot;, pad = &quot;0&quot;) ) %&gt;% sf::st_as_sf(coords = c(&quot;utm_x&quot;, &quot;utm_y&quot;), crs = sf::st_crs(treetops_sf_with_dbh)) %&gt;% sf::st_buffer(11.35) # convert to stars ortho_st = ortho_rast %&gt;% terra::subset(subset = c(1,2,3)) %&gt;% terra::crop( # stand %&gt;% plot_temp %&gt;% sf::st_buffer(5) %&gt;% sf::st_bbox() %&gt;% sf::st_as_sfc() %&gt;% terra::vect() ) %&gt;% # terra::aggregate(fact = 2, fun = &quot;mean&quot;, na.rm = T) %&gt;% stars::st_as_stars() # convert to rgb ortho_rgb &lt;- stars::st_rgb( ortho_st[,,,1:3] , dimension = 3 , use_alpha = FALSE # , stretch = &quot;histogram&quot; , probs = c(0.005, 0.995) , stretch = &quot;percent&quot; ) # ggplot plt_rgb &lt;- ggplot() + stars::geom_stars(data = ortho_rgb[]) + scale_fill_identity(na.value = &quot;transparent&quot;) + # !!! don&#39;t take this out or RGB plot will kill your computer scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + labs( x = &quot;&quot; , y = &quot;&quot; ) + theme_void() # return(plt_rgb) ## combine all plot elements plt_combine = plt_rgb + ggnewscale::new_scale_fill() + geom_tile( data = chm_rast %&gt;% terra::crop( plot_temp %&gt;% terra::vect() ) %&gt;% terra::mask( plot_temp %&gt;% terra::vect() ) %&gt;% `*`(3.28) %&gt;% # transform to feet as.data.frame(xy=T) %&gt;% rename(f=3) , mapping = aes(x=x,y=y,fill=f) ) + scale_fill_viridis_c( option=&quot;plasma&quot;, alpha = 0.6, name = &quot;canopy ht. (ft)&quot; , limits = c( min(terra::values(chm_rast), na.rm = T)*3.28 , max(terra::values(chm_rast), na.rm = T)*3.28 ) ) + geom_sf( data = plot_temp , alpha = 0 , lwd = 1.2 , color = &quot;blue&quot; ) + ggnewscale::new_scale_fill() + geom_sf( data = field_uas_comparison %&gt;% dplyr::filter(plot_id == my_plotid) , mapping = aes(fill = field_uas_group) , color = &quot;black&quot; , shape = 21 , size = 2 ) + # scale_fill_manual(values = viridis::cividis(n=3)[1:2], name = &quot;trees&quot;) + scale_fill_viridis_d(option = &quot;cividis&quot;, name = &quot;trees&quot;, drop = F) + labs( title = paste0( &quot;Plot ID: &quot; , field_uas_comparison %&gt;% dplyr::filter(plot_id == my_plotid) %&gt;% dplyr::pull(plot_lab) %&gt;% unique() ) ) + theme( legend.position = &quot;top&quot; , legend.direction = &quot;horizontal&quot; , legend.margin = margin(0,0,-1,0) , legend.text = element_text(size = 8) , legend.title = element_text(size = 8, face = &quot;bold&quot;) , plot.title = ggtext::element_markdown(size = 10, hjust = 0.5) ) + guides( fill = guide_legend(override.aes = list(size = c(5,NULL))) ) return(plt_combine) } # ortho_plt_fn(2) Plot orthomosaic + CHM + tree points + plot for all plots with at least one omisson or commission # map over plots with omissions and commisssions field_uas_plts = field_uas_comparison %&gt;% dplyr::filter(field_uas_group %in% c(&quot;commission&quot;, &quot;omission&quot;)) %&gt;% dplyr::pull(plot_id) %&gt;% unique() %&gt;% sort() %&gt;% purrr::map(ortho_plt_fn) Combine plots patchwork::wrap_plots( field_uas_plts[] , ncol = 4 ) + patchwork::plot_layout(guides=&quot;collect&quot;) &amp; theme( legend.position = &quot;bottom&quot; , legend.direction = &quot;horizontal&quot; ) "],["ustory_valid.html", "Section 7 Regeneration Field Validation Data 7.1 Load Field Data 7.2 Create Data to Compare to UAS 7.3 UAS Estimated Regeneration", " Section 7 Regeneration Field Validation Data The 2023-06 BHEF field surveys used \\(\\frac{1}{400}\\) acre (10.117 m2) plots with a 5.89 ft (1.795 m) radius for regeneration sampling. 7.1 Load Field Data Load the regeneration data, set parameters for processing, and map # load Field Validation Data field_regen = readr::read_csv( file = &quot;../data/field_data/Voodoo_regen_data.csv&quot; ) %&gt;% dplyr::rename_with(~ .x %&gt;% # replace all non alphanumeric with _ stringr::str_replace_all(&quot;[^[:alnum:] ]+&quot;, &quot;_&quot;) %&gt;% # remove any _ at the end of the string stringr::str_remove(&quot;[_]$&quot;) %&gt;% tolower() ) %&gt;% dplyr::filter( !is.na(plot_id) &amp; !is.na(utm_x) &amp; !is.na(utm_y) &amp; !is.na(regen_size_class) &amp; regen_size_class != &quot;&quot; ) %&gt;% dplyr::mutate( plot_dir_id = paste0( stringr::str_pad(plot_id, width = 4, side = &quot;left&quot;, pad = &quot;0&quot;) , &quot;-&quot; , tolower(select_the_regen_plot_center_north_or_south) ) , regen_size_class = regen_size_class %&gt;% stringr::str_squish() %&gt;% tolower() , regen_size_class_diam = dplyr::case_when( stringr::str_detect(regen_size_class, &quot;inch&quot;) ~ regen_size_class %&gt;% stringr::word(1, sep = &quot;inch&quot;) %&gt;% stringr::str_squish() , T ~ as.character(NA) ) ) %&gt;% dplyr::relocate(plot_dir_id) %&gt;% # remove duplicates dplyr::group_by(plot_dir_id, regen_size_class) %&gt;% dplyr::filter(dplyr::row_number()==1) %&gt;% dplyr::ungroup() %&gt;% # separate diameter size class inches tidyr::separate_wider_delim( cols = regen_size_class_diam , delim = &quot;-&quot; , names = c( &quot;diam_inch_class_lower&quot; , &quot;diam_inch_class_upper&quot; ) , too_few = &quot;align_start&quot; , cols_remove = F ) %&gt;% sf::st_as_sf( coords = c(&quot;utm_x&quot;, &quot;utm_y&quot;) , crs = sf::st_crs(treetops_sf_with_dbh) , remove=F ) %&gt;% # keep only points that are within the uas flight boundary sf::st_intersection(las_ctg_dta) # data structure field_regen %&gt;% dplyr::glimpse() ## Rows: 298 ## Columns: 20 ## $ plot_dir_id &lt;chr&gt; &quot;0045-north&quot;, &quot;0045-north&quot;… ## $ plot_id &lt;dbl&gt; 45, 45, 45, 45, 45, 45, 45… ## $ mainid &lt;chr&gt; &quot;48815e9d-39ba-4978-bab4-8… ## $ subid &lt;chr&gt; &quot;d388d460-3d15-454c-ac9c-d… ## $ observers_on_plot &lt;chr&gt; &quot;WT,HK,TD,CM,VH&quot;, &quot;WT,HK,T… ## $ collection_date &lt;chr&gt; &quot;6/6/2023 18:00&quot;, &quot;6/6/202… ## $ comments_on_plot_condition_or_abnormalities &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA… ## $ x &lt;dbl&gt; -103.6228, -103.6228, -103… ## $ y &lt;dbl&gt; 44.14282, 44.14282, 44.142… ## $ select_the_regen_plot_center_north_or_south &lt;chr&gt; &quot;North&quot;, &quot;North&quot;, &quot;South&quot;,… ## $ regen_size_class &lt;chr&gt; &quot;&lt; 4.5 ft tall&quot;, &quot;1-2 inch… ## $ number_of_trees_in_size_class &lt;dbl&gt; 13, 1, 6, 18, 9, 3, 9, 2, … ## $ average_tree_height_feet &lt;dbl&gt; 2.0, 6.0, 2.0, 5.5, 6.0, 1… ## $ regen_remarks &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA… ## $ utm_x &lt;dbl&gt; 610342.6, 610342.6, 610342… ## $ utm_y &lt;dbl&gt; 4888774, 4888774, 4888756,… ## $ diam_inch_class_lower &lt;chr&gt; NA, &quot;1&quot;, NA, &quot;0&quot;, &quot;1&quot;, &quot;2&quot;… ## $ diam_inch_class_upper &lt;chr&gt; NA, &quot;2&quot;, NA, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;… ## $ regen_size_class_diam &lt;chr&gt; NA, &quot;1-2&quot;, NA, &quot;0-1&quot;, &quot;1-2… ## $ geometry &lt;POINT [m]&gt; POINT (610342.6 4888… # count by regen class field_regen %&gt;% sf::st_drop_geometry() %&gt;% dplyr::count(regen_size_class, regen_size_class_diam) %&gt;% kableExtra::kbl() %&gt;% kableExtra::kable_styling() regen_size_class regen_size_class_diam n 0-1 inch 0-1 62 1-2 inch 1-2 54 2-3 inch 2-3 32 3-4 inch 3-4 14 4-5 inch 4-5 10 &lt; 4.5 ft tall NA 94 no trees NA 32 7.1.1 Regeneration Field Data Plot Map field_regen %&gt;% sf::st_drop_geometry() %&gt;% dplyr::distinct(plot_dir_id, utm_x, utm_y) %&gt;% sf::st_as_sf(coords = c(&quot;utm_x&quot;, &quot;utm_y&quot;), crs = sf::st_crs(treetops_sf_with_dbh)) %&gt;% dplyr::mutate(x=1) %&gt;% mapview::mapview(col.regions = &quot;tan&quot;, layer.name = &quot;regen plot&quot;, alpha.regions = 0.6) + mapview::mapview( harvests , color = &quot;black&quot; , lwd = 3 , alpha.regions = 0 , label = FALSE , legend = FALSE , popup = FALSE ) 7.2 Create Data to Compare to UAS The process used below identifies all plots sampled to create a full dataset containing all possible diameter size classes sampled in the field including for plots on which there were 0 trees in a particular size class. # row unique by plot_dir_id, regen_size_class_diam field_regen_plt_diam = dplyr::cross_join( # plot ids field_regen %&gt;% dplyr::distinct(plot_dir_id, geometry) # possible diameter size classes ... # ...excludes regen_size_class %in% c(&quot;no trees&quot;, &quot;&lt;4.5 ft tall&quot;) # ...includes stringr::str_detect(regen_size_class, &quot;inch&quot;) , field_regen %&gt;% dplyr::filter(!is.na(regen_size_class_diam)) %&gt;% dplyr::distinct(regen_size_class_diam, diam_inch_class_upper, diam_inch_class_lower) ) %&gt;% # join with original data dplyr::left_join( field_regen %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select( plot_dir_id, regen_size_class_diam , number_of_trees_in_size_class, average_tree_height_feet ) , by = dplyr::join_by(plot_dir_id, regen_size_class_diam) ) %&gt;% # fill with valid zero data dplyr::mutate( number_of_trees_in_size_class = dplyr::coalesce(number_of_trees_in_size_class, 0) , plot_area_ac = 1/400 , plot_area_ha = plot_area_ac/2.471 ) ################################################################################# ################################################################################# # Join tree tops with forest stands # row unique by suid, plot_dir_id, regen_size_class_diam ################################################################################# ################################################################################# harvests_regen_plt_diam = harvests %&gt;% dplyr::mutate( stand_area_m2 = sf::st_area(.) %&gt;% as.numeric() , stand_area_ha = stand_area_m2/10000 ) %&gt;% sf::st_intersection(las_ctg_dta) %&gt;% dplyr::mutate( intrsct_stand_area_m2 = sf::st_area(.) %&gt;% as.numeric() ) %&gt;% dplyr::filter(round(intrsct_stand_area_m2, 0) == round(stand_area_m2, 0)) %&gt;% dplyr::select( suid, forest_commonname, admin_region_code, activity_name , treatment_type, treatment_type_grp, date_compl, year_id , stand_area_m2, stand_area_ha ) %&gt;% sf::st_intersection(field_regen_plt_diam) This data contains a row for every plot surveyed and every diameter size class in the regeneration sampling protocol, including plots with 0 observations for a size class. field_regen_plt_diam %&gt;% sf::st_drop_geometry() %&gt;% dplyr::arrange(plot_dir_id,diam_inch_class_lower) %&gt;% dplyr::select(plot_dir_id, regen_size_class_diam, number_of_trees_in_size_class) %&gt;% dplyr::slice_head(n=10) %&gt;% kableExtra::kbl(digits = 1) %&gt;% kableExtra::kable_styling() plot_dir_id regen_size_class_diam number_of_trees_in_size_class 0001-center 0-1 1 0001-center 1-2 0 0001-center 2-3 0 0001-center 3-4 0 0001-center 4-5 0 0001-north 0-1 15 0001-north 1-2 5 0001-north 2-3 0 0001-north 3-4 0 0001-north 4-5 0 Summary statistics by regeneration size class field_regen_plt_diam %&gt;% sf::st_drop_geometry() %&gt;% dplyr::group_by(regen_size_class_diam) %&gt;% dplyr::summarise( number_of_plots = dplyr::n() , min_num_trees = min(number_of_trees_in_size_class, na.rm = T) , max_num_trees = max(number_of_trees_in_size_class, na.rm = T) , mean_num_trees = mean(number_of_trees_in_size_class, na.rm = T) , median_num_trees = median(number_of_trees_in_size_class, na.rm = T) ) %&gt;% kableExtra::kbl(digits = 1) %&gt;% kableExtra::kable_styling() regen_size_class_diam number_of_plots min_num_trees max_num_trees mean_num_trees median_num_trees 0-1 138 0 35 3.4 0 1-2 138 0 14 1.6 0 2-3 138 0 4 0.4 0 3-4 138 0 5 0.2 0 4-5 138 0 2 0.1 0 7.2.1 Field Regeneration TPA by Size Class The 2023-06 BHEF field surveys used \\(\\frac{1}{400}\\) acre (10.117 m2) plots with a 5.89 ft (1.795 m) radius for regeneration sampling. Aggregated across all plots sampled what was the estimated regeneration trees per acre by size class? # total tpa_temp = field_regen_plt_diam %&gt;% sf::st_drop_geometry() %&gt;% dplyr::group_by(plot_dir_id) %&gt;% dplyr::mutate(plot_area_ac = ifelse(dplyr::row_number()==1,plot_area_ac,0)) %&gt;% dplyr::ungroup() %&gt;% dplyr::summarise( tpa = sum(number_of_trees_in_size_class)/sum(plot_area_ac) ) %&gt;% dplyr::pull(tpa) # plot plt_fld_tpa_diam = field_regen_plt_diam %&gt;% sf::st_drop_geometry() %&gt;% dplyr::group_by(regen_size_class_diam) %&gt;% dplyr::summarise( number_of_plots = dplyr::n() , sum_num_trees = sum(number_of_trees_in_size_class) , sampled_area_ac = sum(plot_area_ac) , sampled_area_ha = sum(plot_area_ha) ) %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate( trees_per_ac = sum_num_trees/sampled_area_ac , trees_per_ha = sum_num_trees/sampled_area_ha , regen_size_class_diam = regen_size_class_diam %&gt;% factor() %&gt;% forcats::fct_rev() , pct = trees_per_ac/sum(trees_per_ac) ) %&gt;% ggplot( mapping = aes( x = trees_per_ac, y = regen_size_class_diam , fill=trees_per_ac , label = paste0( scales::comma(trees_per_ac, accuracy = 0.1) , &quot;\\n&quot; , scales::percent(pct, accuracy = 0.1) ) ) ) + geom_col( width = 0.7, alpha=0.8 ) + geom_text( color = &quot;black&quot;, size = 3.5 , hjust = -0.1 ) + scale_fill_viridis_c(option = &quot;mako&quot;, direction = -1) + scale_x_continuous(expand = expansion(mult = c(0, .15))) + labs( fill = &quot;&quot; , y = &quot;Regeneration Diameter Size Class (in)&quot; , x = &quot;Trees per Acre&quot; , title = &quot;Field-Based TPA by Regeneration Diameter Size Class&quot; , subtitle = paste0( &quot;Total TPA: &quot; , scales::comma(tpa_temp, accuracy = 1) ) ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.title.x = element_text(size=10, face = &quot;bold&quot;) , axis.title.y = element_text(size=9) , axis.text.x = element_blank() , axis.text.y = element_text(color = &quot;black&quot;,size=12, face = &quot;bold&quot;) , axis.ticks.x = element_blank() , plot.title = element_text(size=10) , plot.subtitle = element_text(size=9, face = &quot;bold&quot;) ) plt_fld_tpa_diam 7.2.2 Stand Regeneration TPA Map harvests_regen_plt_diam %&gt;% sf::st_drop_geometry() %&gt;% dplyr::group_by(suid, plot_dir_id) %&gt;% dplyr::mutate(plot_area_ac = ifelse(dplyr::row_number()==1,plot_area_ac,0)) %&gt;% dplyr::group_by(suid) %&gt;% dplyr::summarise( tpa = sum(number_of_trees_in_size_class)/sum(plot_area_ac) ) %&gt;% dplyr::ungroup() %&gt;% dplyr::inner_join( harvests , by = dplyr::join_by(suid) ) %&gt;% sf::st_set_geometry(&quot;geom&quot;) %&gt;% ggplot(mapping = aes(fill = tpa)) + geom_sf(alpha = 0.8) + geom_sf_label(mapping = aes(label = scales::comma(tpa, accuracy = 1)), fill = &quot;white&quot;) + scale_fill_viridis_c(option = &quot;cividis&quot;) + labs( title = &quot;Regeneration Trees per Acre&quot; , subtitle = paste0( &quot;reneration size diameter size measured: &quot; , min(field_regen_plt_diam$diam_inch_class_lower) , &quot;-&quot; , max(field_regen_plt_diam$diam_inch_class_upper) , &quot; inches&quot; ) ) + theme_void() + theme( legend.position = &quot;none&quot; ) 7.3 UAS Estimated Regeneration The UAS data only includes trees 1.4 m (4.6 ft) and above. The average tree this tall has a diameter of 0.08 inches based on the UAS SfM-derived height to diameter allometry. # filter and plot pred_mod_best %&gt;% dplyr::filter(lower_b_in &lt; 5) %&gt;% ggplot( mapping = aes( x=tree_height_ft, y = estimate_in ) ) + geom_ribbon( mapping = aes(ymin = lower_b_in, ymax = upper_b_in) , fill = &quot;gray88&quot; , alpha = 0.5 ) + geom_line( color = &quot;gray33&quot; , lwd = 1 ) + scale_x_continuous(limits = c(0,NA), breaks=scales::breaks_extended(n=16)) + scale_y_continuous(limits = c(0,NA), breaks=scales::breaks_extended(n=8)) + labs( y = &quot;DBH (in)&quot; , x = &quot;Tree Ht. (ft)&quot; , title = &quot;Local height to DBH allometry from SfM-extracted DBH samples&quot; , subtitle = &quot;for trees predicted at DBH &lt; 5 in&quot; ) + theme_light() + theme(legend.position = &quot;none&quot;) Based on the UAS SfM-derived height to diameter allometry for the area sampled, trees below 5 inches in diameter (i.e. the cutoff for field-based regeneration sampling) have a maximum height of 30.8 feet with 90% probability. The average tree with a diameter of 5 inches is 22.6 feet. 7.3.1 UAS vs Field Regneration TPA by Size Class tpa_temp = harvests_trees %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(suid, treeID, dbh_cm, stand_area_ha, tree_height_m) %&gt;% calc_imperial_units_fn() %&gt;% dplyr::inner_join( field_regen_plt_diam %&gt;% dplyr::distinct(regen_size_class_diam, diam_inch_class_lower, diam_inch_class_upper) %&gt;% dplyr::mutate( dplyr::across(tidyselect::starts_with(&quot;diam_inch_class&quot;), as.numeric) ) , by = dplyr::join_by( dbh_in &lt; diam_inch_class_upper , dbh_in &gt;= diam_inch_class_lower ) ) %&gt;% dplyr::group_by(suid, regen_size_class_diam) %&gt;% dplyr::mutate(stand_area_ac = ifelse(dplyr::row_number()==1,stand_area_ac,0)) %&gt;% dplyr::group_by(regen_size_class_diam) %&gt;% dplyr::summarise(trees_per_ac = dplyr::n()/sum(stand_area_ac)) %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate( tot = sum(trees_per_ac), pct = trees_per_ac/tot , regen_size_class_diam = regen_size_class_diam %&gt;% factor() %&gt;% forcats::fct_rev() ) # plot plt_uas_tpa_diam = ggplot( data = tpa_temp , mapping = aes( x = trees_per_ac, y = regen_size_class_diam, fill=trees_per_ac , label = paste0( scales::comma(trees_per_ac, accuracy = 0.1) , &quot;\\n&quot; , scales::percent(pct, accuracy = 0.1) ) ) ) + geom_col( width = 0.7, alpha=0.8 ) + geom_text( color = &quot;black&quot;, size = 3.5 , hjust = -0.1 ) + scale_fill_viridis_c(option = &quot;mako&quot;, direction = -1) + scale_x_continuous(expand = expansion(mult = c(0, .15))) + labs( fill = &quot;&quot; , y = &quot;Regeneration Diameter Size Class (in)&quot; , x = &quot;Trees per Acre&quot; , title = &quot;UAS-Based TPA by Regeneration Diameter Size Class&quot; , subtitle = paste0( &quot;Total TPA: &quot; , scales::comma(tpa_temp$tot[1], accuracy = 1) ) ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.title.x = element_text(size=10, face = &quot;bold&quot;) , axis.title.y = element_text(size=9) , axis.text.x = element_blank() , axis.text.y = element_text(color = &quot;black&quot;,size=12, face = &quot;bold&quot;) , axis.ticks.x = element_blank() , plot.title = element_text(size=10) , plot.subtitle = element_text(size=9, face = &quot;bold&quot;) ) plt_uas_tpa_diam + plt_fld_tpa_diam + labs( caption = paste0( &quot;*note field-based estimates include trees &lt; &quot; , round(min_uas_dbh_in,2) , &quot; in. which are excluded from UAS data&quot; ) ) 7.3.2 UAS vs Field Regeneration TPA by Stand field_uas_regen_comp_temp = harvests_regen_plt_diam %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter( diam_inch_class_upper &gt; min_uas_dbh_in ) %&gt;% dplyr::mutate( dplyr::across( tidyselect::starts_with(&quot;diam_inch_class&quot;) , .fn = as.numeric ) , num_trees_wt = dplyr::case_when( min_uas_dbh_in &lt; diam_inch_class_upper &amp; min_uas_dbh_in &gt;= diam_inch_class_lower ~ (min_uas_dbh_in - diam_inch_class_lower) / (diam_inch_class_upper - diam_inch_class_lower) , T ~ 1 ) ) %&gt;% dplyr::group_by(suid, regen_size_class_diam) %&gt;% dplyr::summarise( number_of_plots = dplyr::n_distinct(plot_dir_id) , max_diam_inch_class_upper = max(diam_inch_class_upper) , sum_num_trees = sum(number_of_trees_in_size_class*num_trees_wt) , sampled_area_ac = sum(plot_area_ac) ) %&gt;% dplyr::group_by(suid) %&gt;% dplyr::summarise( field_trees_per_ac = sum(sum_num_trees/sampled_area_ac) , number_of_plots = max(number_of_plots) , max_diam_inch_class_upper = max(max_diam_inch_class_upper) ) %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate( min_diam_inch_class_lower = min_uas_dbh_in ) %&gt;% dplyr::inner_join( harvests_trees %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(suid, dbh_cm, stand_area_ha, tree_height_m) %&gt;% calc_imperial_units_fn() %&gt;% dplyr::filter(dbh_in &lt; 5) %&gt;% dplyr::group_by(suid) %&gt;% dplyr::summarise(uas_trees_per_ac = dplyr::n()/max(stand_area_ac)) , by = dplyr::join_by(suid) ) field_uas_regen_comp_temp %&gt;% dplyr::select(suid, field_trees_per_ac, uas_trees_per_ac) %&gt;% dplyr::mutate( abs_error = abs(uas_trees_per_ac-field_trees_per_ac) , pct_error = abs_error/field_trees_per_ac ) %&gt;% kableExtra::kbl( caption = paste0( &quot;Regeneration TPA prediction performance for trees &quot; , field_uas_regen_comp_temp$min_diam_inch_class_lower %&gt;% min() %&gt;% scales::comma(accuracy = .01) , &quot; to &quot; , field_uas_regen_comp_temp$max_diam_inch_class_upper %&gt;% max() %&gt;% scales::comma(accuracy = .01) , &quot; inches in diameter&quot; ) , col.names = c( &quot;Harvest Stand&quot; , &quot;Field TPA&quot; , &quot;UAS TPA&quot; , &quot;Abs. Error&quot; , &quot;Abs. Percent Error&quot; ) , digits = 2 ) %&gt;% kableExtra::kable_styling() Table 7.1: Regeneration TPA prediction performance for trees 0.08 to 5.00 inches in diameter Harvest Stand Field TPA UAS TPA Abs. Error Abs. Percent Error 0203088082660001000 866.62 86.96 779.66 0.90 0203088082660002000 1121.68 89.28 1032.40 0.92 0203088082660003000 927.08 117.19 809.89 0.87 0203088082660004000 917.25 120.59 796.66 0.87 0203088082660009000 1070.63 101.28 969.36 0.91 0203088082660010000 1623.17 112.72 1510.45 0.93 7.3.3 UAS vs Field Regeneration TPA in Sample Plots Limit the UAS vs Field comparison to the area within the field-based sampling plots. # aggregate field data to plot level field_regen_plt_temp = field_regen_plt_diam %&gt;% dplyr::filter( diam_inch_class_upper &gt; min_uas_dbh_in ) %&gt;% dplyr::mutate( dplyr::across( tidyselect::starts_with(&quot;diam_inch_class&quot;) , .fn = as.numeric ) , num_trees_wt = dplyr::case_when( min_uas_dbh_in &lt; diam_inch_class_upper &amp; min_uas_dbh_in &gt;= diam_inch_class_lower ~ (min_uas_dbh_in - diam_inch_class_lower) / (diam_inch_class_upper - diam_inch_class_lower) , T ~ 1 ) ) %&gt;% sf::st_set_geometry(&quot;geometry&quot;) %&gt;% dplyr::group_by(plot_dir_id, plot_area_ac, plot_area_ha, geometry) %&gt;% dplyr::summarise( max_diam_inch_class_upper = max(diam_inch_class_upper) , sum_num_trees = sum(number_of_trees_in_size_class*num_trees_wt) ) %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate( field_trees_per_ac = sum_num_trees/plot_area_ac , min_diam_inch_class_lower = min_uas_dbh_in ) %&gt;% tidyr::separate_wider_delim( cols = plot_dir_id , delim = &quot;-&quot; , names = c( &quot;plot_id&quot; , &quot;plot_direction_id&quot; ) , cols_remove = F ) %&gt;% sf::st_set_geometry(&quot;geometry&quot;) Aggregate to plot level by combining the plot_direction_id column (e.g. center, north, south). Buffer the plot points and combine the plot geometry together via sf::st_bbox to create an estimated bounding box of the area sampled in the regeneration field sampling. This area will be used to find the UAS detected trees within the bounding box to compare TPA estimates. field_regen_plt_bbox_temp = field_regen_plt_temp %&gt;% sf::st_buffer(field_regen_plt_temp$plot_area_ha[1]*10000) %&gt;% dplyr::group_by(plot_id) %&gt;% tidyr::nest() %&gt;% dplyr::mutate( bbox = purrr::map(data, function(x){ x %&gt;% sf::st_bbox() %&gt;% sf::st_as_sfc() }) ) %&gt;% tidyr::unnest(cols = c(data, bbox)) %&gt;% dplyr::group_by(plot_id) %&gt;% dplyr::summarise( geometry = sf::st_union(bbox) , sum_num_trees = sum(sum_num_trees) , sum_plot_area_ac = sum(plot_area_ac) , sum_plot_area_ha = sum(plot_area_ha) ) %&gt;% dplyr::ungroup() %&gt;% sf::st_set_geometry(&quot;geometry&quot;) %&gt;% dplyr::mutate( field_trees_per_ac = sum_num_trees/sum_plot_area_ac , bbox_area_m2 = sf::st_area(geometry) %&gt;% as.numeric() , bbox_area_ha = bbox_area_m2/10000 , bbox_area_ac = bbox_area_ha*2.471 ) mapview::mapview( field_regen_plt_bbox_temp , zcol = &quot;field_trees_per_ac&quot; , layer.name = &quot;regen bbox TPA&quot; , col.regions = viridis::cividis(n=nrow(harvests)*1.1) , alpha.regions = 0.7 , na.color = &quot;transparent&quot; , popup = F ) + mapview::mapview( harvests , color = &quot;black&quot; , lwd = 3 , alpha.regions = 0 , label = FALSE , legend = FALSE , popup = FALSE ) These boundary box sample areas are 0.19 acres (779.6 m2). Join UAS trees within the boundary box of the field regeneration sample plots field_uas_regen_comp_temp = field_regen_plt_bbox_temp %&gt;% dplyr::left_join( field_regen_plt_bbox_temp %&gt;% sf::st_intersection( harvests_trees %&gt;% dplyr::select(treeID, dbh_cm) %&gt;% calc_imperial_units_fn() %&gt;% dplyr::filter(dbh_in &lt; 5) ) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::group_by(plot_id, bbox_area_ac) %&gt;% dplyr::summarise(uas_num_trees = dplyr::n()) %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate(uas_trees_per_ac = uas_num_trees/bbox_area_ac) %&gt;% dplyr::select(plot_id, uas_trees_per_ac) , by = dplyr::join_by(plot_id) ) %&gt;% dplyr::mutate( uas_trees_per_ac = dplyr::coalesce(uas_trees_per_ac, 0) ) 7.3.4 UAS vs Field Regeneration TPA Correlation What is the relationship between the UAS-based and the Field-based regeneration TPA estimates at the level of the field sampling plot? ggplot( data = field_uas_regen_comp_temp , mapping = aes( x = uas_trees_per_ac , y = field_trees_per_ac ) ) + geom_smooth(method = &quot;lm&quot;, color = &quot;gray66&quot;, se = F) + geom_point(color = &quot;gray22&quot;) + ggpubr::stat_regline_equation( aes(label = paste(after_stat(eq.label), after_stat(rr.label), sep = &quot;~~~~~&quot;)) ) + scale_x_continuous(limits = c(0,NA), labels = scales::comma_format(accuracy = 1)) + scale_y_continuous(limits = c(0,NA), labels = scales::comma_format(accuracy = 1)) + labs( x = &quot;UAS-based regeneration TPA&quot; , y = &quot;Field-based regeneration TPA&quot; , title = &quot;UAS vs Field regeneration TPA estimates at the sample plot level&quot; ) + theme_bw() + theme(legend.position = &quot;none&quot;) 7.3.5 UAS Regeneration TPA Reliability data.frame( mae_tpa = Metrics::mae( field_uas_regen_comp_temp$field_trees_per_ac , field_uas_regen_comp_temp$uas_trees_per_ac ) %&gt;% scales::comma(accuracy = 0.1) , smape_tpa = Metrics::smape( field_uas_regen_comp_temp$field_trees_per_ac , field_uas_regen_comp_temp$uas_trees_per_ac ) %&gt;% scales::percent(accuracy = 0.1) , rmse_tpa = Metrics::rmse( field_uas_regen_comp_temp$field_trees_per_ac , field_uas_regen_comp_temp$uas_trees_per_ac ) %&gt;% scales::comma(accuracy = 0.1) , n = nrow(field_uas_regen_comp_temp) %&gt;% scales::comma(accuracy = 1) ) %&gt;% kableExtra::kbl( caption = &quot;UAS regeneration TPA prediction performance&quot; , col.names = c( &quot;Mean Abs. Error&quot; , &quot;Sym. Mean Abs. Percent Error&quot; , &quot;Root Mean Squared Error&quot; , &quot;N&quot; ) ) %&gt;% kableExtra::kable_styling() Table 7.2: UAS regeneration TPA prediction performance Mean Abs. Error Sym. Mean Abs. Percent Error Root Mean Squared Error N 927.7 161.9% 1,339.1 46 "],["silv.html", "Section 8 Silvicultural Metrics 8.1 Overstory Summary 8.2 Height Distribution 8.3 Understory Summary 8.4 Define Functions for Stand Summary 8.5 Harvest Unit Summary Reports", " Section 8 Silvicultural Metrics Overstory metrics are calculated using the UAS SfM-derived DBH and height measurements, where DBH is estimated using a local DBH-Height allometric relationship. Validation of the UAS SfM-derived DBH and height measurements was completed using field-based sampling data. In the following analysis and reporting, overstory includes any tree where the DBH is 5.0 in. (12.70 cm) or greater. Understory (i.e. regeneration) metrics are calculated using the field-based sampling data reviewed in this section. The following analysis and reporting, understory includes any tree where the DBH is less than 5.0 in. (12.70 cm) or greater. # Common silvicultural metrics are calculated for the entire extent. # Note, that stand-level summaries can be computed if stand vector data is provided. # metrics include: # &quot;n_trees&quot; # &quot;stand_area_ha&quot; # &quot;trees_per_ha&quot; # &quot;mean_dbh_cm&quot; # &quot;qmd_cm&quot; # &quot;mean_tree_height_m&quot; # &quot;loreys_height_m&quot; # &quot;basal_area_m2&quot; # &quot;basal_area_m2_per_ha&quot; ### stand-level summaries silv_metrics = harvests_trees %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(dbh_cm &gt;= ostory_min_tree_dbh_cm) %&gt;% dplyr::ungroup() %&gt;% dplyr::group_by(suid,stand_area_ha) %&gt;% dplyr::summarise( n_trees = dplyr::n_distinct(treeID) , mean_dbh_cm = mean(dbh_cm, na.rm = T) , mean_tree_height_m = mean(tree_height_m, na.rm = T) , loreys_height_m = sum(basal_area_m2*tree_height_m, na.rm = T) / sum(basal_area_m2, na.rm = T) , basal_area_m2 = sum(basal_area_m2, na.rm = T) , sum_dbh_cm_sq = sum(dbh_cm^2, na.rm = T) ) %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate( trees_per_ha = (n_trees/stand_area_ha) , basal_area_m2_per_ha = (basal_area_m2/stand_area_ha) , qmd_cm = sqrt(sum_dbh_cm_sq/n_trees) ) %&gt;% dplyr::select(-c(sum_dbh_cm_sq)) %&gt;% # convert to imperial units calc_imperial_units_fn() %&gt;% dplyr::select( &quot;suid&quot; , &quot;n_trees&quot; , &quot;stand_area_ha&quot; , &quot;trees_per_ha&quot; , &quot;mean_dbh_cm&quot; , &quot;qmd_cm&quot; , &quot;mean_tree_height_m&quot; , &quot;loreys_height_m&quot; , &quot;basal_area_m2&quot; , &quot;basal_area_m2_per_ha&quot; # imperial , &quot;stand_area_ac&quot; , &quot;trees_per_ac&quot; , &quot;mean_dbh_in&quot; , &quot;qmd_in&quot; , &quot;mean_tree_height_ft&quot; , &quot;loreys_height_ft&quot; , &quot;basal_area_ft2&quot; , &quot;basal_area_ft2_per_ac&quot; ) ### export tabular write.csv( silv_metrics , paste0(delivery_dir, &quot;/stand_overstory_silv_metrics.csv&quot;) , row.names = F ) # join with spatial data silv_metrics = harvests %&gt;% # join with plot data data dplyr::inner_join( silv_metrics , by = dplyr::join_by(&quot;suid&quot;) ) ###################################################### # UNDERSTORY SUMMARY ###################################################### ustory_silv_metrics = harvests_regen_plt_diam %&gt;% sf::st_drop_geometry() %&gt;% dplyr::mutate( dplyr::across( tidyselect::starts_with(&quot;diam_inch_class&quot;) , .fn = as.numeric ) ) %&gt;% dplyr::filter( diam_inch_class_lower &lt; ustory_max_tree_dbh_cm ) %&gt;% dplyr::group_by(suid, regen_size_class_diam) %&gt;% dplyr::summarise( number_of_plots = dplyr::n_distinct(plot_dir_id) , max_diam_inch_class_upper = max(diam_inch_class_upper) , sum_num_trees = sum(number_of_trees_in_size_class) , sampled_area_ac = sum(plot_area_ac) , sampled_area_ha = sum(plot_area_ha) ) %&gt;% dplyr::mutate( size_class_trees_per_ac = sum_num_trees/sampled_area_ac , size_class_trees_per_ha = sum_num_trees/sampled_area_ha ) %&gt;% dplyr::group_by(suid) %&gt;% dplyr::mutate( unit_trees_per_ac = sum(size_class_trees_per_ac) , unit_trees_per_ha = sum(size_class_trees_per_ha) ) %&gt;% dplyr::ungroup() ### export tabular write.csv( ustory_silv_metrics , paste0(delivery_dir, &quot;/stand_understory_silv_metrics.csv&quot;) , row.names = F ) 8.1 Overstory Summary 8.1.1 Distribution of silvicultural metrics Distribution of silvicultural metrics across the 6 stands in this analysis. silv_metrics %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select( &quot;suid&quot; , &quot;stand_area_ac&quot; , &quot;n_trees&quot; , &quot;trees_per_ac&quot; , &quot;mean_dbh_in&quot; , &quot;qmd_in&quot; , &quot;mean_tree_height_ft&quot; , &quot;loreys_height_ft&quot; , &quot;basal_area_ft2_per_ac&quot; ) %&gt;% tidyr::pivot_longer( cols = -c(suid), names_to = &quot;metric&quot;, values_to = &quot;val&quot; ) %&gt;% # order metrics dplyr::mutate( metric = factor( metric , ordered = T , levels = c( &quot;stand_area_ac&quot; , &quot;n_trees&quot; , &quot;trees_per_ac&quot; , &quot;mean_tree_height_ft&quot; , &quot;loreys_height_ft&quot; , &quot;mean_dbh_in&quot; , &quot;qmd_in&quot; , &quot;basal_area_ft2_per_ac&quot; ) , labels = c( latex2exp::TeX(&quot;Stand Area (ac)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Number of Trees&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Trees $ac^{-1}$&quot;) , latex2exp::TeX(&quot;Mean Tree Height (ft)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Lorey&#39;s Mean Height (ft)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Mean DBH (in)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;QMD (in)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Basal Area $ft^{2} \\\\cdot ac^{-1}$&quot;) ) ) ) %&gt;% ggplot( mapping = aes( x = val , y = 1 ) ) + geom_boxplot(fill = &quot;gray&quot;, width = 0.7, outlier.shape = NA) + geom_point(mapping = aes(group = suid)) + facet_wrap(facets = vars(metric), ncol = 2, scales = &quot;free_x&quot;, labeller = label_parsed) + scale_x_continuous(breaks = scales::extended_breaks(6)) + scale_y_continuous(limits = c(0.5,1.5)) + labs( y = &quot;&quot; , x = &quot;&quot; , title = paste0( &quot;Overstory (&gt;= &quot; , scales::comma(ostory_min_tree_dbh_cm/2.54,accuracy = 0.1) , &quot; in. DBH) Distribution of Silvicultural Metrics&quot; ) , subtitle = paste(nrow(silv_metrics), &quot;stands included in analysis&quot;) ) + theme_light() + theme( legend.position = &quot;none&quot; , strip.text = element_text(color = &quot;black&quot;) , strip.background = element_rect(fill = &quot;gray88&quot;) , axis.text.y = element_blank() , axis.ticks.y = element_blank() , panel.grid.major.y = element_blank() , panel.grid.minor.y = element_blank() ) 8.1.2 Overstory Stand Basal Area Map mapview::mapview( bhef_boundary , color = &quot;black&quot; , lwd = 3 , alpha.regions = 0 , layer.name = &quot;BHEF&quot; , label = FALSE , legend = FALSE , popup = FALSE ) + mapview::mapview( silv_metrics , zcol = &quot;basal_area_ft2_per_ac&quot; , layer.name = &quot;BA (ft2 per ac)&quot; #latex2exp::TeX(&quot;Basal Area $ft^{2} \\\\cdot ac^{-1}$&quot;) , col.regions = viridis::cividis(n=nrow(silv_metrics)*1.1) , alpha.regions = 0.7 , na.color = &quot;transparent&quot; , popup = F ) 8.1.3 Stand QMD Map Quadratic mean diameter (QMD) is a measure of the diameter of the tree of mean basal area: \\[ \\textrm{quadratic mean diameter (QMD)} = \\sqrt{\\frac{\\sum{d_{i}^{2}}}{n}} \\] , where \\(d_{i}\\) is the diameter at breast height of an individual tree, and \\(n\\) is the total number of trees. mapview::mapview( bhef_boundary , color = &quot;black&quot; , lwd = 3 , alpha.regions = 0 , layer.name = &quot;BHEF&quot; , label = FALSE , legend = FALSE , popup = FALSE ) + mapview::mapview( silv_metrics , zcol = &quot;qmd_in&quot; , layer.name = &quot;QMD (in)&quot; #latex2exp::TeX(&quot;Basal Area $ft^{2} \\\\cdot ac^{-1}$&quot;) , col.regions = viridis::mako(n=nrow(silv_metrics)*1.1, direction = -1) , alpha.regions = 0.7 , na.color = &quot;transparent&quot; , popup = F ) 8.1.4 Overstory DBH Distrubtion harvests_trees %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(dbh_cm &gt;= ostory_min_tree_dbh_cm) %&gt;% dplyr::select(treeID, dbh_in) %&gt;% dplyr::ungroup() %&gt;% dplyr::distinct() %&gt;% ggplot( mapping = aes(x = dbh_in) ) + geom_density(alpha = 0.8, fill = &quot;navy&quot;, color = NA) + labs( x = &quot;DBH (in)&quot; , y = &quot;density&quot; , title = paste0( &quot;Overstory (&gt;= &quot; , scales::comma(ostory_min_tree_dbh_cm/2.54,accuracy = 0.1) , &quot; in. DBH) SfM-derived tree DBH distribution&quot; ) ) + scale_x_continuous(breaks = scales::extended_breaks(n=20)) + theme_light() + theme( legend.position = &quot;none&quot; ) tpa_temp = harvests_trees %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(dbh_cm &gt;= ostory_min_tree_dbh_cm) %&gt;% dplyr::select(treeID, dbh_in) %&gt;% dplyr::ungroup() %&gt;% dplyr::distinct() %&gt;% dplyr::mutate( dbh_cl = ggplot2::cut_width(dbh_in, width = 1, center = 0.5, closed = &quot;left&quot;) ) %&gt;% dplyr::group_by(dbh_cl) %&gt;% dplyr::summarise( n_trees = dplyr::n() , trees_per_ac = dplyr::n()/ (harvests %&gt;% sf::st_union() %&gt;% sf::st_area() %&gt;% as.numeric() %&gt;% `/`(10000) %&gt;% `*`(2.471)) , trees_per_ha = dplyr::n()/ (harvests %&gt;% sf::st_union() %&gt;% sf::st_area() %&gt;% as.numeric() %&gt;% `/`(10000)) ) %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate( tot_trees_per_ac = sum(trees_per_ac) , tot_trees_per_ha = sum(trees_per_ha) , pct = trees_per_ac/tot_trees_per_ac , dbh_cl_lab = paste0( stringr::word(dbh_cl, 1, sep = fixed(&quot;,&quot;)) %&gt;% readr::parse_number() , &quot; to &quot; , stringr::word(dbh_cl, -1, sep = fixed(&quot;,&quot;)) %&gt;% readr::parse_number() %&gt;% `-`(0.1) ) %&gt;% factor() %&gt;% forcats::fct_reorder(stringr::word(dbh_cl, 1, sep = fixed(&quot;,&quot;)) %&gt;% readr::parse_number()) ) # plot tpa_temp %&gt;% ggplot( mapping = aes( x = dbh_cl_lab, y = trees_per_ac , fill=trees_per_ac , label = paste0( scales::comma(trees_per_ac, accuracy = 0.1) , &quot;\\n&quot; , scales::percent(pct, accuracy = 0.1) ) ) ) + geom_col(width = 0.7) + geom_text(color = &quot;black&quot;, size = 3, vjust = -0.2) + scale_fill_viridis_c(option = &quot;mako&quot;, direction = -1) + scale_y_continuous(labels = scales::comma_format(accuracy = 1),expand = expansion(mult = c(0, .13))) + labs( x = &quot;DBH (in) Class&quot; , y = &quot;TPA&quot; , title = paste0( &quot;Overstory (&gt;= &quot; , scales::comma(ostory_min_tree_dbh_cm/2.54,accuracy = 0.1) , &quot; in. DBH) Trees Per Acre by Diameter Class&quot; ) , subtitle = paste0( &quot;Total TPA: &quot; , scales::comma(tpa_temp$tot_trees_per_ac[1], accuracy = 1) ) ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.text.x = element_text(angle = 90, size = 10, face = &quot;bold&quot;, vjust = 0.5, hjust = 1) ) 8.2 Height Distribution harvests_trees %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(dbh_cm &gt;= ostory_min_tree_dbh_cm) %&gt;% dplyr::select(treeID, tree_height_ft) %&gt;% dplyr::ungroup() %&gt;% dplyr::distinct() %&gt;% ggplot( mapping = aes(x = tree_height_ft) ) + geom_density(alpha = 0.8, fill = &quot;steelblue&quot;, color = NA) + labs( x = &quot;Height (ft)&quot; , y = &quot;density&quot; , title = paste0( &quot;Overstory (&gt;= &quot; , scales::comma(ostory_min_tree_dbh_cm/2.54,accuracy = 0.1) , &quot; in. DBH) SfM-derived tree height distribution&quot; ) ) + scale_x_continuous(breaks = scales::extended_breaks(n=10)) + theme_light() + theme( legend.position = &quot;none&quot; ) 8.3 Understory Summary # total tpa_temp = harvests_regen_plt_diam %&gt;% sf::st_drop_geometry() %&gt;% dplyr::mutate( dplyr::across( tidyselect::starts_with(&quot;diam_inch_class&quot;) , .fn = as.numeric ) ) %&gt;% dplyr::filter( diam_inch_class_lower &lt; ustory_max_tree_dbh_cm ) %&gt;% dplyr::ungroup() %&gt;% dplyr::distinct(plot_dir_id, regen_size_class_diam, number_of_trees_in_size_class, plot_area_ac, plot_area_ha) %&gt;% dplyr::group_by(regen_size_class_diam) %&gt;% dplyr::summarise( number_of_plots = dplyr::n_distinct(plot_dir_id) , sum_num_trees = sum(number_of_trees_in_size_class) , sampled_area_ac = sum(plot_area_ac) , sampled_area_ha = sum(plot_area_ha) ) %&gt;% dplyr::mutate( size_class_trees_per_ac = sum_num_trees/sampled_area_ac , size_class_trees_per_ha = sum_num_trees/sampled_area_ha ) %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate( tot_trees_per_ac = sum(size_class_trees_per_ac) , tot_trees_per_ha = sum(size_class_trees_per_ha) , pct = size_class_trees_per_ac/tot_trees_per_ac , dbh_cl_lab = paste0( stringr::word(regen_size_class_diam, 1, sep = fixed(&quot;-&quot;)) %&gt;% readr::parse_number() , &quot; to &quot; , stringr::word(regen_size_class_diam, -1, sep = fixed(&quot;-&quot;)) %&gt;% readr::parse_number() %&gt;% `-`(0.1) ) %&gt;% factor() %&gt;% forcats::fct_reorder(stringr::word(regen_size_class_diam, 1, sep = fixed(&quot;-&quot;)) %&gt;% readr::parse_number()) ) # plot tpa_temp %&gt;% ggplot( mapping = aes( x = dbh_cl_lab, y = size_class_trees_per_ac , fill=size_class_trees_per_ac , label = paste0( scales::comma(size_class_trees_per_ac, accuracy = 0.1) , &quot;\\n&quot; , scales::percent(pct, accuracy = 0.1) ) ) ) + geom_col(width = 0.7) + geom_text(color = &quot;black&quot;, size = 3, vjust = -0.2) + scale_fill_viridis_c(option = &quot;mako&quot;, direction = -1) + scale_y_continuous(labels = scales::comma_format(accuracy = 1),expand = expansion(mult = c(0, .13))) + labs( x = &quot;DBH (in) Class&quot; , y = &quot;TPA&quot; , title = paste0( &quot;Understory (&lt; &quot; , scales::comma(ustory_max_tree_dbh_cm/2.54,accuracy = 0.1) , &quot; in. DBH) Trees Per Acre by Diameter Class&quot; ) , subtitle = paste0( &quot;Total TPA: &quot; , scales::comma(tpa_temp$tot_trees_per_ac[1], accuracy = 1) ) ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.text.x = element_text(angle = 90, size = 10, face = &quot;bold&quot;, vjust = 0.5, hjust = 1) ) 8.4 Define Functions for Stand Summary Create plots to combine for report orthomosaic + chm + tree tops + stand plot ###################################################################################### # function to plot ortho + chm + points + stand ###################################################################################### ortho_plt_fn = function(my_suid){ # convert to stars ortho_st = ortho_rast %&gt;% terra::subset(subset = c(1,2,3)) %&gt;% terra::crop( # stand %&gt;% harvests %&gt;% dplyr::filter(suid==my_suid) %&gt;% sf::st_buffer(20) %&gt;% sf::st_bbox() %&gt;% sf::st_as_sfc() %&gt;% terra::vect() ) %&gt;% terra::aggregate(fact = 4, fun = &quot;mean&quot;, na.rm = T) %&gt;% stars::st_as_stars() # convert to rgb ortho_rgb &lt;- stars::st_rgb( ortho_st[,,,1:3] , dimension = 3 , use_alpha = FALSE # , stretch = &quot;histogram&quot; , probs = c(0.005, 0.995) , stretch = &quot;percent&quot; ) # ggplot plt_rgb &lt;- ggplot() + stars::geom_stars(data = ortho_rgb[]) + scale_fill_identity(na.value = &quot;transparent&quot;) + # !!! don&#39;t take this out or RGB plot will kill your computer scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + labs( x = &quot;&quot; , y = &quot;&quot; ) + theme_void() # chm chm = chm_rast %&gt;% terra::crop( harvests %&gt;% dplyr::filter(suid==my_suid) %&gt;% terra::vect() ) %&gt;% terra::mask( harvests %&gt;% dplyr::filter(suid==my_suid) %&gt;% terra::vect() ) %&gt;% terra::aggregate(fact = 2, fun = &quot;mean&quot;, na.rm = T) %&gt;% `*`(3.28) %&gt;% # transform to feet as.data.frame(xy=T) %&gt;% rename(f=3) # return(plt_rgb) # combine all plot elements plt_combine = plt_rgb + # # understory # geom_tile( # data = chm %&gt;% # dplyr::filter( # f &lt; # pred_mod_best %&gt;% # dplyr::filter(estimate_in &lt; ustory_max_tree_dbh_cm/2.54) %&gt;% # dplyr::pull(tree_height_ft) %&gt;% max() # ) # , mapping = aes(x = x, y = y) # , fill = &quot;gray&quot; # , alpha = 0.4 # , na.rm = T # ) + # overstory ggnewscale::new_scale_fill() + geom_tile( data = chm %&gt;% dplyr::filter( f &gt;= pred_mod_best %&gt;% dplyr::filter(estimate_in &gt;= ostory_min_tree_dbh_cm/2.54) %&gt;% dplyr::pull(tree_height_ft) %&gt;% min() ) , mapping = aes(x = x, y = y, fill = f) , na.rm = T ) + scale_fill_viridis_c(option=&quot;plasma&quot;, alpha = 0.6, breaks = scales::extended_breaks(n=6), na.value = &quot;transparent&quot;) + geom_sf( data = harvests %&gt;% dplyr::filter(suid==my_suid) , alpha = 0 , lwd = 1.5 , color = &quot;#b22222&quot; ) + # geom_sf( # data = treetops_sf_with_dbh %&gt;% # sf::st_intersection(harvests %&gt;% dplyr::filter(suid==my_suid)) # , color = &quot;#330099&quot; # , shape = &quot;.&quot; # ) + labs( fill = &quot;overstory\\ncanopy ht. (ft)&quot; # , title = &quot;Trees identified within stand boundary&quot; # , title = &quot;&lt;span&gt;&lt;span style=&#39;color:#330099;&#39;&gt;&lt;b&gt;&lt;i&gt;Trees&lt;/i&gt;&lt;/b&gt;&lt;/span&gt; identified within &lt;span style=&#39;color:#b22222;&#39;&gt;&lt;b&gt;&lt;i&gt;stand&lt;/i&gt;&lt;/b&gt;&lt;/span&gt; boundary&lt;/span&gt;&quot; , title = paste0( &quot;Overstory (&gt;= &quot; , scales::comma(ostory_min_tree_dbh_cm/2.54,accuracy = 0.1) , &quot; in. DBH) within stand boundary&quot; ) # , subtitle = paste0( # &quot;trees under &quot; # , scales::comma((ustory_max_tree_dbh_cm/2.54),accuracy = 0.1) # , &quot; in. DBH shown in gray&quot; # ) ) + theme( legend.position = &quot;top&quot; # c(0.5,1) , legend.direction = &quot;horizontal&quot; , legend.margin = margin(0,0,-1,0) , legend.text = element_text(size = 8) , legend.title = element_text(size = 8) # , plot.title = ggtext::element_markdown(size = 10, hjust = 0.5) , plot.title = element_text(size = 10, hjust = 0.5, face = &quot;bold&quot;) , plot.subtitle = element_text(size = 8, hjust = 0.5, face = &quot;italic&quot;) ) return(plt_combine) } # ortho_plt_fn(harvests$suid[3]) dbh distribution plot dbh_dist_fn = function(my_suid){ harvests_trees %&gt;% dplyr::filter( suid == my_suid &amp; dbh_cm &gt;= ostory_min_tree_dbh_cm ) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(treeID, dbh_in) %&gt;% dplyr::distinct() %&gt;% ggplot( mapping = aes(x = dbh_in) ) + geom_density(alpha = 0.8, fill = &quot;navy&quot;, color = NA) + labs( x = &quot;DBH (in)&quot; , y = &quot;density&quot; , title = paste0( &quot;Overstory (&gt;= &quot; , scales::comma(ostory_min_tree_dbh_cm/2.54,accuracy = 0.1) , &quot; in. DBH) DBH distribution&quot; ) ) + scale_x_continuous(breaks = scales::extended_breaks(n=20)) + theme_light() + theme( legend.position = &quot;none&quot; ) } # dbh_dist_fn(harvests$suid[1]) height distribution plot ht_dist_fn = function(my_suid){ harvests_trees %&gt;% dplyr::filter( suid == my_suid &amp; dbh_cm &gt;= ostory_min_tree_dbh_cm ) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(treeID, tree_height_ft) %&gt;% dplyr::distinct() %&gt;% ggplot( mapping = aes(x = tree_height_ft) ) + geom_density(alpha = 0.8, fill = &quot;steelblue&quot;, color = NA) + labs( x = &quot;Height (ft)&quot; , y = &quot;density&quot; , title = paste0( &quot;Overstory (&gt;= &quot; , scales::comma(ostory_min_tree_dbh_cm/2.54,accuracy = 0.1) , &quot; in. DBH) height distribution&quot; ) ) + scale_x_continuous(breaks = scales::extended_breaks(n=10)) + theme_light() + theme( legend.position = &quot;none&quot; ) } # ht_dist_fn(harvests$suid[1]) silvicultural metrics imperial table tab_imp_fn = function(my_suid){ silv_metrics %&gt;% dplyr::filter(suid == my_suid) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select( &quot;suid&quot; , &quot;stand_area_ac&quot; , &quot;n_trees&quot; , &quot;trees_per_ac&quot; , &quot;mean_dbh_in&quot; , &quot;qmd_in&quot; , &quot;mean_tree_height_ft&quot; , &quot;loreys_height_ft&quot; , &quot;basal_area_ft2_per_ac&quot; ) %&gt;% tidyr::pivot_longer( cols = -c(suid), names_to = &quot;metric&quot;, values_to = &quot;val&quot; ) %&gt;% # order metrics dplyr::mutate( metric = factor( metric , ordered = T , levels = c( &quot;stand_area_ac&quot; , &quot;n_trees&quot; , &quot;trees_per_ac&quot; , &quot;mean_tree_height_ft&quot; , &quot;loreys_height_ft&quot; , &quot;mean_dbh_in&quot; , &quot;qmd_in&quot; , &quot;basal_area_ft2_per_ac&quot; ) , labels = c( latex2exp::TeX(&quot;Stand Area (ac)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Number of Trees&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Trees $ac^{-1}$&quot;) , latex2exp::TeX(&quot;Mean Tree Height (ft)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Lorey&#39;s Mean Height (ft)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Mean DBH (in)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;QMD (in)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Basal Area $ft^{2} \\\\cdot ac^{-1}$&quot;) ) ) ) %&gt;% dplyr::mutate(val = scales::comma(val,accuracy=0.1)) %&gt;% dplyr::select(metric, val) %&gt;% ggpubr::ggtexttable( rows = NULL , cols = rep(&quot;&quot;, 2) , theme = ggpubr::ttheme( base_style = &quot;blank&quot; , tbody.style = ggpubr::tbody_style( parse = T, fill = &quot;white&quot;, linecolor = &quot;gray&quot; , size = 10 ) ) ) %&gt;% ggpubr::tab_add_title( text = paste0( &quot;Silvicultural Metrics (imperial)&quot; , &quot;\\nOverstory (&gt;= &quot; , scales::comma(ostory_min_tree_dbh_cm/2.54,accuracy = 0.1) , &quot; in. DBH)&quot; ) , face = &quot;bold&quot; , size = 10, padding = unit(0.5, &quot;line&quot;) ) } # tab_imp_fn(harvests$suid[2]) silvicultural metrics metric table tab_met_fn = function(my_suid){ silv_metrics %&gt;% dplyr::filter(suid == my_suid) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select( &quot;suid&quot; , &quot;stand_area_ha&quot; , &quot;n_trees&quot; , &quot;trees_per_ha&quot; , &quot;mean_dbh_cm&quot; , &quot;qmd_cm&quot; , &quot;mean_tree_height_m&quot; , &quot;loreys_height_m&quot; , &quot;basal_area_m2_per_ha&quot; ) %&gt;% tidyr::pivot_longer( cols = -c(suid), names_to = &quot;metric&quot;, values_to = &quot;val&quot; ) %&gt;% # order metrics dplyr::mutate( metric = factor( metric , ordered = T , levels = c( &quot;stand_area_ha&quot; , &quot;n_trees&quot; , &quot;trees_per_ha&quot; , &quot;mean_tree_height_m&quot; , &quot;loreys_height_m&quot; , &quot;mean_dbh_cm&quot; , &quot;qmd_cm&quot; , &quot;basal_area_m2_per_ha&quot; ) , labels = c( latex2exp::TeX(&quot;Stand Area (ha)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Number of Trees&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Trees $ha^{-1}$&quot;) , latex2exp::TeX(&quot;Mean Tree Height (m)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Lorey&#39;s Mean Height (m)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Mean DBH (cm)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;QMD (cm)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Basal Area $m^{2} \\\\cdot ha^{-1}$&quot;) ) ) ) %&gt;% dplyr::mutate(val = scales::comma(val,accuracy=0.1)) %&gt;% dplyr::select(metric, val) %&gt;% ggpubr::ggtexttable( rows = NULL , cols = rep(&quot;&quot;, 2) , theme = ggpubr::ttheme( base_style = &quot;blank&quot; , tbody.style = ggpubr::tbody_style( parse = T, fill = &quot;white&quot;, linecolor = &quot;gray&quot; , size = 10 ) ) ) %&gt;% ggpubr::tab_add_title( text = paste0( &quot;Silvicultural Metrics (metric)&quot; , &quot;\\nOverstory (&gt;= &quot; , scales::comma(ostory_min_tree_dbh_cm,accuracy = 0.1) , &quot; cm DBH)&quot; ) , face = &quot;bold&quot; , size = 10, padding = unit(0.5, &quot;line&quot;) ) } # tab_met_fn(harvests$suid[2]) inset map plot plt_inset_map_fn &lt;- function(my_suid){ ( ggplot() + geom_sf(data = bhef_boundary, alpha = 0, lwd = 1, color = &quot;black&quot;) + geom_sf(data = harvests, alpha = 0, lwd = 0.4, color = &quot;gray&quot;) + geom_sf( data = harvests %&gt;% dplyr::filter(suid == my_suid) , fill = &quot;firebrick&quot; , alpha = 0.3 , lwd = 1 , color = &quot;firebrick&quot; ) + # geom_sf_label( # data = rx_fire # , aes(label = unit) # , label.size = NA # , alpha = 0 # , size = 2.5 # ) + xlab(&quot;&quot;) + ylab(&quot;&quot;) + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + theme_bw() + theme( axis.text = element_text(size = 3.5) , axis.text.x = element_text(angle = 35) , panel.border = element_blank() ) ) } # plt_inset_map_fn(harvests$suid[4]) contour + elevation map plot # sequence by 5&#39;s to get 5m breaks list for contour contour_int_m &lt;- 5 seq_brk &lt;- seq(0, 40000, contour_int_m) # create contour data elev_contour &lt;- dtm_rast %&gt;% stars::st_as_stars() %&gt;% stars::st_contour( na.rm = TRUE , contour_lines = FALSE , breaks = # classInt::classIntervals(na.omit(as.vector(x[[1]])))$brks seq_brk[ seq_brk &gt; min(na.omit(as.vector(dtm_rast[[1]]))) - contour_int_m &amp; seq_brk &lt; max(na.omit(as.vector(dtm_rast[[1]]))) + contour_int_m ] ) plt_contour_map_fn &lt;- function(my_suid){ ( ######################################### ######################################### # map of unit w/ contour ######################################### ######################################### # plot ggplot() + geom_tile( data = dtm_rast %&gt;% terra::crop( harvests %&gt;% dplyr::filter(suid == my_suid) %&gt;% sf::st_buffer(dist = 20) %&gt;% sf::st_bbox() %&gt;% sf::st_as_sfc() %&gt;% terra::vect() ) %&gt;% terra::aggregate(fact=2) %&gt;% `*`(3.28) %&gt;% # transform to feet as.data.frame(xy=T) %&gt;% dplyr::rename(elev = 3) , mapping = aes(x=x,y=y,fill=elev) ) + geom_sf(data = elev_contour %&gt;% sf::st_crop( harvests %&gt;% dplyr::filter(suid == my_suid) %&gt;% sf::st_buffer(dist = 20) %&gt;% sf::st_bbox() ) , alpha = 0 , lwd = 0.5 , color = &quot;gray30&quot; , show.legend = FALSE ) + geom_sf(data = harvests %&gt;% dplyr::filter(suid == my_suid) , alpha = 0 , lwd = 1.5 , color = &quot;firebrick&quot; , show.legend = FALSE ) + scale_fill_viridis_c( option = &quot;viridis&quot; , alpha = 0.9 , na.value = &quot;transparent&quot; , breaks = scales::extended_breaks(n = 6) , labels = scales::comma ) + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + labs( subtitle = paste0( as.character(round(contour_int_m * 3.28, 1)) , &quot; ft (&quot; , as.character(contour_int_m) , &quot; m) contours&quot; ) , fill = &quot;elev. (ft)&quot; , x = &quot;&quot; , y = &quot;&quot; ) + theme_void() + theme( legend.position = &quot;top&quot; , legend.direction = &quot;horizontal&quot; , legend.margin = margin(0,0,-1,0) # , legend.box.margin = margin(-1,0,2,0) , legend.text = element_text(size = 4, angle = 25, hjust = 0.7) , legend.title = element_text(size = 4) , plot.subtitle = element_text( size=5, face=&quot;italic&quot;, color=&quot;gray20&quot;, margin = margin(0,0,0,0) , hjust = 0.5 ) ) ) } # plt_contour_map_fn(harvests$suid[1]) regen by size class plt_regen_dist_fn &lt;- function(my_suid){ dta = harvests_regen_plt_diam %&gt;% sf::st_drop_geometry() %&gt;% dplyr::mutate( dplyr::across( tidyselect::starts_with(&quot;diam_inch_class&quot;) , .fn = as.numeric ) ) %&gt;% dplyr::filter( suid == my_suid &amp; diam_inch_class_lower &lt; ustory_max_tree_dbh_cm ) %&gt;% dplyr::group_by(suid,regen_size_class_diam) %&gt;% dplyr::summarise( number_of_plots = dplyr::n() , sum_num_trees = sum(number_of_trees_in_size_class) , sampled_area_ac = sum(plot_area_ac) ) %&gt;% dplyr::group_by(suid) %&gt;% dplyr::mutate( trees_per_ac = sum_num_trees/sampled_area_ac , stand_trees_per_ac = sum(sum_num_trees)/max(sampled_area_ac) , regen_size_class_diam = regen_size_class_diam %&gt;% factor() %&gt;% forcats::fct_rev() ) %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate( stand_lab = paste0( # suid &quot;\\nTotal TPA: &quot; , scales::comma(stand_trees_per_ac, accuracy = 1) ) # factor() %&gt;% forcats::fct_reorder(desc(stand_trees_per_ac)) ) ## plt ggplot( data = dta , mapping = aes( x = trees_per_ac, y = regen_size_class_diam , fill=trees_per_ac , label = scales::comma(trees_per_ac, accuracy = 0.1) ) ) + geom_col( width = 0.7 ) + geom_text( color = &quot;black&quot;, size = 2 , hjust = -0.1 ) + scale_fill_viridis_c(option = &quot;mako&quot;, direction = -1) + scale_x_continuous(expand = expansion(mult = c(0, .13))) + # facet_wrap(facets = vars(stand_lab), ncol = 3) + labs( fill = &quot;&quot; , y = &quot;DBH (in) Class&quot; , x = &quot;Trees per Acre&quot; , title = paste0( &quot;Understory (&lt; &quot; , scales::comma(ustory_max_tree_dbh_cm/2.54,accuracy = 0.1) , &quot; in. DBH) Trees Per Acre&quot; ) # , subtitle = &quot;by harvest unit (with FACTS ID)&quot; , subtitle = dta$stand_lab[1] ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.text.x = element_blank() , axis.text.y = element_text(color = &quot;black&quot;,size=12, face = &quot;bold&quot;) , axis.ticks.x = element_blank() # , strip.text = element_text(color = &quot;black&quot;, size = 12) # , strip.background = element_rect(fill = &quot;gray88&quot;) ) } # plt_regen_dist_fn(harvests$suid[2]) build report report_fn = function(my_suid){ # generate plots ortho_plt_temp = ortho_plt_fn(my_suid) # ortho_plt_fn(harvests$suid[4]) dbh_dist_temp = dbh_dist_fn(my_suid) + # dbh_dist_fn(harvests$suid[4]) theme( plot.background = element_rect(colour = &quot;gray&quot;, fill=NA, size=1) # , plot.title = element_text(size = 9) # , plot.subtitle = element_text(size = 7) ) ht_dist_temp = ht_dist_fn(my_suid) + # ht_dist_fn(harvests$suid[4]) theme( plot.background = element_rect(colour = &quot;gray&quot;, fill=NA, size=1) # , plot.title = element_text(size = 9) # , plot.subtitle = element_text(size = 7) ) plt_inset_map_temp = plt_inset_map_fn(my_suid) # plt_inset_map_fn(harvests$suid[4]) plt_contour_map_temp = plt_contour_map_fn(my_suid) # plt_contour_map_fn(harvests$suid[4]) tab_imp_temp = tab_imp_fn(my_suid) # tab_imp_fn(harvests$suid[4]) tab_met_temp = tab_met_fn(my_suid) # tab_met_fn(harvests$suid[4]) plt_regen_dist_temp = plt_regen_dist_fn(my_suid) + theme(plot.background = element_rect(colour = &quot;gray&quot;, fill=NA, size=1)) # plot layout # area(t,l,b,r) layout_temp = c( # map area(1, 2, 2, 2) # map inset , area(1, 1, 1, 1) # contour , area(2, 1, 2, 1) # # tables , area(4, 1, 5, 1) , area(6, 1, 7, 1) # space , area(3, 1, 3, 2) # # # distributions , area(5, 2, 5, 2) , area(6, 2, 6, 2) , area(7, 2, 7, 2) ) # check the layout # plot(layout_temp) # patchwork rpt = ortho_plt_temp + plt_inset_map_temp + plt_contour_map_temp + tab_imp_temp + tab_met_temp + patchwork::plot_spacer() + dbh_dist_temp + ht_dist_temp + plt_regen_dist_temp + patchwork::plot_layout( design = layout_temp , heights = c(0.7, 0.8, 0.3, 1,1,1,1) , widths = c(0.5,1) ) # export ggplot2::ggsave( filename = paste0(delivery_dir, &quot;/suid_&quot;, my_suid, &quot;.pdf&quot;) , plot = rpt , device = &quot;pdf&quot; , width = 8.5, height = 11, units = &quot;in&quot; ) return(rpt) } 8.5 Harvest Unit Summary Reports # generate and print reports harvests$suid %&gt;% # .[1] %&gt;% purrr::map(report_fn) %&gt;% print() # combine all pdfs together # combine with pdftools pdftools::pdf_combine( sort(list.files(delivery_dir, pattern = &quot;\\\\.pdf$&quot;, full.names = TRUE)) , output = paste0( delivery_dir , &quot;/BHEF_UAS_202306_report_&quot; , gsub(&quot;-&quot;, &quot;&quot;, Sys.Date()) , &quot;.pdf&quot; ) ) "],["tree_spatial.html", "Section 9 UAS Tree Spatial Arrangement 9.1 Example Tree Group Workflow 9.2 ICO Implementation", " Section 9 UAS Tree Spatial Arrangement 9.1 Example Tree Group Workflow For now we’ll just make a visual overview of the UAS-SfM forest inventory process to present at the 2024 National Silvicultural Workshop. # focus on one harvest unit my_suid = harvests$suid[6] ######################### ######################### # what is overstory? ######################### ######################### #!!!!! fill in one...if both filled in will use DBH # determine overstory by height ostory_ht_m = as.numeric(NA) # m = ft / 3.281 # determine overstory by diameter ostory_dbh_cm = 5*2.54 # cm = in * 2.54 ######################### ######################### # clump spacing ######################### ######################### # maximum distance between trees for determining tree clumps # stems within 6 m of one another were considered to have the potential for developing interlocking crowns tree_clump_dist_m = 6 Check the stand location # where is this mapview::mapview(harvests %&gt;% dplyr::filter(suid==my_suid), layer.name = &quot;BHEF&quot;, label = FALSE, legend = FALSE, popup = FALSE) 9.1.1 Orthomosaic from UAS ###################################################################################### # function to plot ortho + stand ###################################################################################### ortho_plt_fn = function(my_suid){ # convert to stars ortho_st = ortho_rast %&gt;% terra::subset(subset = c(1,2,3)) %&gt;% terra::crop( # stand %&gt;% harvests %&gt;% dplyr::filter(suid==my_suid) %&gt;% sf::st_buffer(20) %&gt;% sf::st_bbox() %&gt;% sf::st_as_sfc() %&gt;% terra::vect() ) %&gt;% terra::aggregate(fact = 2, fun = &quot;mean&quot;, na.rm = T) %&gt;% stars::st_as_stars() # convert to rgb ortho_rgb &lt;- stars::st_rgb( ortho_st[,,,1:3] , dimension = 3 , use_alpha = FALSE # , stretch = &quot;histogram&quot; , probs = c(0.005, 0.995) , stretch = &quot;percent&quot; ) # ggplot plt_rgb &lt;- ggplot() + stars::geom_stars(data = ortho_rgb[]) + scale_fill_identity(na.value = &quot;transparent&quot;) + # !!! don&#39;t take this out or RGB plot will kill your computer scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + labs( x = &quot;&quot; , y = &quot;&quot; ) + theme_void() # return(plt_rgb) # combine all plot elements plt_combine = plt_rgb + geom_sf( data = harvests %&gt;% dplyr::filter(suid==my_suid) , alpha = 0 , lwd = 1.5 , color = &quot;#b22222&quot; ) + theme( legend.position = &quot;top&quot; # c(0.5,1) , legend.direction = &quot;horizontal&quot; , legend.margin = margin(0,0,0,0) , legend.text = element_text(size = 8) , legend.title = element_text(size = 8) , legend.key = element_rect(fill = &quot;white&quot;) # , plot.title = ggtext::element_markdown(size = 10, hjust = 0.5) , plot.title = element_text(size = 10, hjust = 0.5, face = &quot;bold&quot;) , plot.subtitle = element_text(size = 8, hjust = 0.5, face = &quot;italic&quot;) ) return(plt_combine) } # PLOT IT ortho_plt_fn(my_suid) + labs( subtitle = &quot;\\nstand boundary\\n&quot; # subtitle = &quot;&lt;span style=&#39;color:#b22222;&#39;&gt;&lt;b&gt;&lt;i&gt;stand boundary&lt;/i&gt;&lt;/b&gt;&lt;/span&gt;&quot; ) + theme( plot.subtitle = element_text(size = 9.5, color = &quot;#b22222&quot;, hjust = 0.5, face = &quot;bold&quot;) ) # save it ggplot2::ggsave(&quot;../data/NSW_01.jpeg&quot;, dpi = &quot;print&quot;, height = 11, width = 5.8, device = &quot;jpeg&quot;) plot with CHM # chm chm_temp = chm_rast %&gt;% terra::crop( harvests %&gt;% dplyr::filter(suid==my_suid) %&gt;% terra::vect() ) %&gt;% terra::mask( harvests %&gt;% dplyr::filter(suid==my_suid) %&gt;% terra::vect() ) %&gt;% terra::aggregate(fact = 2, fun = &quot;mean&quot;, na.rm = T) %&gt;% `*`(3.28) %&gt;% # transform to feet as.data.frame(xy=T) %&gt;% rename(f=3) # plot it plt_chm_temp = ortho_plt_fn(my_suid) + # chm ggnewscale::new_scale_fill() + geom_tile( data = chm_temp , mapping = aes(x = x, y = y, fill = f) , na.rm = T ) + scale_fill_viridis_c(option=&quot;plasma&quot;, alpha = 0.8, breaks = scales::extended_breaks(n=6), na.value = &quot;transparent&quot;) + labs(fill = &quot;CHM (ft)&quot;) # PLOT IT plt_chm_temp # save it ggplot2::ggsave(&quot;../data/NSW_02.jpeg&quot;, dpi = &quot;print&quot;, height = 11, width = 5.8, device = &quot;jpeg&quot;) 9.1.2 ITD individual trees detected from lidR::locate_trees() Height plt_ttops_temp = ortho_plt_fn(my_suid) + # treetops geom_sf( data = harvests_trees %&gt;% dplyr::filter(suid==my_suid) , mapping = aes(color = tree_height_ft) , size = 1 ) + scale_color_viridis_c(option=&quot;plasma&quot;, alpha = 0.8, breaks = scales::extended_breaks(n=6)) + labs(color = &quot;Individual Tree\\nHt. (ft)&quot;) # PLOT IT plt_ttops_temp # save it ggplot2::ggsave(&quot;../data/NSW_03.jpeg&quot;, dpi = &quot;print&quot;, height = 11, width = 5.8, device = &quot;jpeg&quot;) overstory/understory plt_ttops_temp = ortho_plt_fn(my_suid) + # treetops geom_sf( data = harvests_trees %&gt;% dplyr::filter(suid==my_suid) %&gt;% dplyr::mutate( ostory = dplyr::case_when( !is.na(as.numeric(ostory_dbh_cm)) &amp; dbh_cm&gt;=as.numeric(ostory_dbh_cm) ~ &quot;overstory&quot; , !is.na(as.numeric(ostory_ht_m)) &amp; tree_height_m&gt;=as.numeric(ostory_ht_m) ~ &quot;overstory&quot; , is.na(as.numeric(ostory_dbh_cm)) &amp; is.na(as.numeric(ostory_ht_m)) &amp; dbh_cm&gt;=5*2.54 ~ &quot;overstory&quot; , T ~ &quot;understory&quot; ) , ostory_sz = ifelse(ostory==&quot;overstory&quot;,0.51,0.5) ) , mapping = aes(color = ostory) , size = 1 ) + scale_color_manual(values = c(&quot;navy&quot;,&quot;gray&quot;)) + labs(color = &quot;&quot;) + theme(legend.key = element_rect(color = NA, fill = NA), legend.margin = margin(6.5,0,6.5,0)) + guides(size = &quot;none&quot;, color = guide_legend(override.aes = list(size = 5))) # PLOT IT plt_ttops_temp # save it ggplot2::ggsave(&quot;../data/NSW_04.jpeg&quot;, dpi = &quot;print&quot;, height = 11, width = 5.8, device = &quot;jpeg&quot;) 9.1.3 Tree Groups Identify tree groups using dbscan::dbscan() as outlined by Hanna et al. (2024): To evaluate the ability of UAS-extracted trees to characterize horizontal and vertical heterogeneity tree arrangement, clusters of trees were identifed within the stem-mapped and UAS trees. A cluster of trees was defned as two or more trees with the potential for interlocking crowns. Overstory trees on the stem maps generally had a crown radius of ~3.0 m, so stems within 6 m of one another were considered to have the potential for developing interlocking crowns. Density-based spatial clustering of applications with noise (DBSCAN) from the fpr package (Hahsler et al., 2019) in R was used to assign trees to unique clusters, including individual trees that were assigned by themselves if they did not have the potential to develop interlocking crowns (&gt;6 m from another tree). (p. 529) To analyze the efect of tree aggregation on tree attributes, the identifed trees and clusters were designated as an “individual” or as a cluster consisting of 2-4, 5-9, 10-15, and &gt;15 trees. We then calculated the number of clusters, the percent of stand basal area, the height coefcient of variation, and the canopy area within the cluster size classes for each site. (p. 529-530) With repect to clump size groupings, Churchill et al. (2016) note that: Proportions for clump sizes should be lumped into four or five bins for operational simplicity. We use 4 or 5 bins (Fig 5): individual trees, small clumps (2-4 trees), medium clumps (5-9 trees), and large clumps (10-20+ trees). Note that when instructed to leave a large clump (e.g. 10-20 trees), marking crews often have difficulty leaving the upper end of the size range (e.g. an 18, 19, or 20 tree clump). Thus adding a fifth bin for “super clumps” may be necessary (e.g. 15-20 trees or 20-25+ trees), especially if the upper size range of clumps is desired. (p. 12-13) # filter trees spatially based on unit id ttops_temp = harvests_trees %&gt;% dplyr::filter(suid==my_suid) %&gt;% dplyr::mutate( ostory = dplyr::case_when( !is.na(as.numeric(ostory_dbh_cm)) &amp; dbh_cm&gt;=as.numeric(ostory_dbh_cm) ~ &quot;overstory&quot; , !is.na(as.numeric(ostory_ht_m)) &amp; tree_height_m&gt;=as.numeric(ostory_ht_m) ~ &quot;overstory&quot; , is.na(as.numeric(ostory_dbh_cm)) &amp; is.na(as.numeric(ostory_ht_m)) &amp; dbh_cm&gt;=5*2.54 ~ &quot;overstory&quot; , T ~ &quot;understory&quot; ) ) %&gt;% dplyr::filter(ostory==&quot;overstory&quot;) %&gt;% dplyr::mutate( X = sf::st_coordinates(.)[,1] %&gt;% as.numeric() , Y = sf::st_coordinates(.)[,2] %&gt;% as.numeric() ) ############################################################################# ##### Identify clusters in each stem map plot ##### ############################################################################# ### Place trees into clusters using an inter-tree distance of 6 m my_dbscan_temp = ttops_temp %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(X,Y) %&gt;% dbscan::dbscan(eps = tree_clump_dist_m, minPts = 2) # my_dbscan_temp %&gt;% str() ### append cluster ID to trees ttops_temp$dbscan_cluster = my_dbscan_temp$cluster # ttops_temp$cluster %&gt;% summary() # ttops_temp %&gt;% sf::st_drop_geometry() %&gt;% dplyr::count(cluster) %&gt;% dplyr::arrange(desc(n)) %&gt;% dplyr::slice_head(n=11) ### cluster metrics ttops_temp = ttops_temp %&gt;% dplyr::group_by(dbscan_cluster) %&gt;% dplyr::mutate( # unique dbscan_cluster for individuals clump_id = dplyr::case_when( dbscan_cluster == 0 ~ max(my_dbscan_temp$cluster)+dplyr::row_number() , T ~ dbscan_cluster ) %&gt;% factor() ) %&gt;% dplyr::group_by(clump_id) %&gt;% dplyr::mutate( dbscan_cluster = factor(dbscan_cluster) , clump_n_trees = dplyr::n() , clump_n_trees_grp = cut( clump_n_trees ,breaks = c(0,1,4,9,15,Inf) , labels = c(&quot;Individual&quot;,&quot;2-4 trees&quot;,&quot;5-9 trees&quot;,&quot;10-15 trees&quot;,&quot;&gt;15 trees&quot;) ) %&gt;% factor( ordered = T , levels = c(&quot;Individual&quot;,&quot;2-4 trees&quot;,&quot;5-9 trees&quot;,&quot;10-15 trees&quot;,&quot;&gt;15 trees&quot;) ) ) %&gt;% dplyr::ungroup() # what? ttops_temp %&gt;% dplyr::glimpse() ## Rows: 2,159 ## Columns: 61 ## $ suid &lt;chr&gt; &quot;0203088082660001000&quot;, &quot;0203088082660001000&quot;… ## $ forest_commonname &lt;chr&gt; &quot;Black Hills National Forest&quot;, &quot;Black Hills … ## $ admin_region_code &lt;chr&gt; &quot;02&quot;, &quot;02&quot;, &quot;02&quot;, &quot;02&quot;, &quot;02&quot;, &quot;02&quot;, &quot;02&quot;, &quot;0… ## $ activity_name &lt;chr&gt; &quot;Single-tree Selection Cut&quot;, &quot;Single-tree Se… ## $ treatment_type &lt;chr&gt; &quot;Single-tree selectio&quot;, &quot;Single-tree selecti… ## $ treatment_type_grp &lt;chr&gt; &quot;Single-tree/Group Selection Cut&quot;, &quot;Single-t… ## $ date_compl &lt;date&gt; 2021-06-01, 2021-06-01, 2021-06-01, 2021-06… ## $ year_id &lt;dbl&gt; 2021, 2021, 2021, 2021, 2021, 2021, 2021, 20… ## $ stand_area_m2 &lt;dbl&gt; 122161.5, 122161.5, 122161.5, 122161.5, 1221… ## $ stand_area_ha &lt;dbl&gt; 12.21615, 12.21615, 12.21615, 12.21615, 12.2… ## $ treeID &lt;chr&gt; &quot;14552_610693.9_4889086.6&quot;, &quot;14644_610749.4_… ## $ tree_height_m &lt;dbl&gt; 13.338, 8.104, 7.523, 7.951, 10.099, 9.421, … ## $ crown_area_m2 &lt;dbl&gt; 14.4375, 11.4375, 9.9375, 20.8750, 9.1250, 1… ## $ comp_trees_per_ha &lt;dbl&gt; 254.7643, 127.3822, 254.7643, 382.1465, 127.… ## $ comp_relative_tree_height &lt;dbl&gt; 100.00000, 100.00000, 100.00000, 66.28595, 1… ## $ comp_dist_to_nearest_m &lt;dbl&gt; 4.527693, 6.932712, 4.123106, 3.783186, 6.93… ## $ mean_crown_ht_m &lt;dbl&gt; 10.416134, 4.533062, 4.840354, 4.106737, 8.0… ## $ median_crown_ht_m &lt;dbl&gt; 10.855000, 5.097000, 4.936000, 4.018000, 8.3… ## $ min_crown_ht_m &lt;dbl&gt; 4.504333, 1.371000, 1.392000, 1.372000, 4.98… ## $ reg_est_dbh_cm &lt;dbl&gt; 24.04701, 13.06371, 11.95876, 12.85215, 17.0… ## $ reg_est_lower_dbh_cm &lt;dbl&gt; 14.904274, 8.132362, 7.403700, 7.957194, 10.… ## $ reg_est_upper_dbh_cm &lt;dbl&gt; 35.00581, 19.03814, 17.25921, 18.71577, 24.8… ## $ is_training_data &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FA… ## $ dbh_cm &lt;dbl&gt; 27.41359, 15.20204, 13.87409, 15.01066, 19.9… ## $ dbh_m &lt;dbl&gt; 0.2741359, 0.1520204, 0.1387409, 0.1501066, … ## $ radius_m &lt;dbl&gt; 0.13706795, 0.07601020, 0.06937043, 0.075053… ## $ basal_area_m2 &lt;dbl&gt; 0.05902306, 0.01815071, 0.01511815, 0.017696… ## $ mod_lin_est_dbh_cm &lt;dbl&gt; 27.41359, 15.20204, 13.87409, 15.01066, 19.9… ## $ mod_quad_est_dbh_cm &lt;dbl&gt; 27.17828, 17.04654, 16.11576, 16.86108, 20.4… ## $ mod_quad_noint_est_dbh_cm &lt;dbl&gt; 26.396383, 10.452572, 9.106412, 10.195015, 1… ## $ mod_pwr_est_dbh_cm &lt;dbl&gt; 27.10818, 16.46476, 15.37877, 16.17962, 20.3… ## $ mod_weib_est_dbh_cm &lt;dbl&gt; 27.76495, 13.72004, 12.14118, 13.44165, 18.9… ## $ mod_rf_est_dbh_cm &lt;dbl&gt; 28.24706, 26.12541, 21.28572, 21.98804, 21.3… ## $ reg_est_dbh_in &lt;dbl&gt; 9.474521, 5.147103, 4.711751, 5.063749, 6.70… ## $ reg_est_lower_dbh_in &lt;dbl&gt; 5.872284, 3.204150, 2.917058, 3.135134, 4.12… ## $ reg_est_upper_dbh_in &lt;dbl&gt; 13.792290, 7.501026, 6.800127, 7.374013, 9.7… ## $ dbh_in &lt;dbl&gt; 10.800955, 5.989604, 5.466390, 5.914199, 7.8… ## $ mod_lin_est_dbh_in &lt;dbl&gt; 10.800955, 5.989604, 5.466390, 5.914199, 7.8… ## $ mod_quad_est_dbh_in &lt;dbl&gt; 10.708243, 6.716339, 6.349609, 6.643264, 8.0… ## $ mod_quad_noint_est_dbh_in &lt;dbl&gt; 10.400175, 4.118313, 3.587926, 4.016836, 6.1… ## $ mod_pwr_est_dbh_in &lt;dbl&gt; 10.680622, 6.487117, 6.059237, 6.374768, 8.0… ## $ mod_weib_est_dbh_in &lt;dbl&gt; 10.939392, 5.405695, 4.783623, 5.296009, 7.4… ## $ mod_rf_est_dbh_in &lt;dbl&gt; 11.129343, 10.293411, 8.386573, 8.663287, 8.… ## $ tree_height_ft &lt;dbl&gt; 43.74864, 26.58112, 24.67544, 26.07928, 33.1… ## $ comp_dist_to_nearest_ft &lt;dbl&gt; 14.850832, 22.739296, 13.523786, 12.408852, … ## $ mean_crown_ht_ft &lt;dbl&gt; 34.16492, 14.86844, 15.87636, 13.47010, 26.4… ## $ median_crown_ht_ft &lt;dbl&gt; 35.60440, 16.71816, 16.19008, 13.17904, 27.4… ## $ min_crown_ht_ft &lt;dbl&gt; 14.77421, 4.49688, 4.56576, 4.50016, 16.3606… ## $ dbh_ft &lt;dbl&gt; 0.8991658, 0.4986269, 0.4550700, 0.4923496, … ## $ radius_ft &lt;dbl&gt; 0.4495829, 0.2493135, 0.2275350, 0.2461748, … ## $ comp_trees_per_ac &lt;dbl&gt; 103.17954, 51.58977, 103.17954, 154.76931, 5… ## $ crown_area_ft2 &lt;dbl&gt; 155.40525, 123.11325, 106.96725, 224.69850, … ## $ basal_area_ft2 &lt;dbl&gt; 0.6353242, 0.1953742, 0.1627318, 0.1904860, … ## $ geom &lt;POINT [m]&gt; POINT (610693.9 4889087), POINT (61074… ## $ ostory &lt;chr&gt; &quot;overstory&quot;, &quot;overstory&quot;, &quot;overstory&quot;, &quot;over… ## $ X &lt;dbl&gt; 610693.9, 610749.4, 610720.1, 610706.1, 6107… ## $ Y &lt;dbl&gt; 4889087, 4889085, 4889085, 4889084, 4889082,… ## $ dbscan_cluster &lt;fct&gt; 0, 0, 0, 1, 0, 2, 1, 3, 4, 2, 0, 4, 0, 0, 2,… ## $ clump_id &lt;fct&gt; 269, 270, 271, 1, 272, 2, 1, 3, 4, 2, 273, 4… ## $ clump_n_trees &lt;int&gt; 1, 1, 1, 2, 1, 4, 2, 3, 20, 4, 1, 20, 1, 1, … ## $ clump_n_trees_grp &lt;ord&gt; Individual, Individual, Individual, 2-4 tree… plot overstory tree clumps plt_grps_temp = ortho_plt_fn(my_suid) + # treetops geom_sf( data = ttops_temp , mapping = aes(color = dbscan_cluster) , size = 1 ) + scale_color_manual(values = c( &quot;white&quot; , # get random list of colors from viridis and avoid whites c( viridis::turbo(length(unique(ttops_temp$dbscan_cluster))/2 %&gt;% round()) , viridis::plasma(length(unique(ttops_temp$dbscan_cluster))/2 %&gt;% round(), end = 0.95) , viridis::viridis(length(unique(ttops_temp$dbscan_cluster))/2 %&gt;% round(), end = 0.9) , viridis::cividis(length(unique(ttops_temp$dbscan_cluster))/2 %&gt;% round(), end = 0.9) ) %&gt;% sample() %&gt;% .[1:length(unique(ttops_temp$dbscan_cluster))-1] ) ) + # scale_color_viridis_d(&quot;turbo&quot;) + labs(subtitle = &quot;\\n overstory tree groups\\n(individual trees in white)&quot;) + theme( legend.position = &quot;none&quot; , plot.subtitle = element_text(size = 9.5, hjust = 0.5, face = &quot;bold&quot;) ) # PLOT IT plt_grps_temp # save it ggplot2::ggsave(&quot;../data/NSW_05.jpeg&quot;, dpi = &quot;print&quot;, height = 11, width = 5.8, device = &quot;jpeg&quot;) and plot overstory tree clumps by number of trees plt_grps_temp = ortho_plt_fn(my_suid) + # treetops geom_sf( data = ttops_temp , mapping = aes(color = clump_n_trees_grp) , size = 1 ) + scale_color_viridis_d(option=&quot;mako&quot;, direction = -1) + labs(color = &quot;&quot;) + theme(legend.key = element_rect(color = NA, fill = NA), legend.margin = margin(6.5,0,6.5,0)) + guides(size = &quot;none&quot;, color = guide_legend(override.aes = list(size = 5))) # PLOT IT plt_grps_temp # save it ggplot2::ggsave(&quot;../data/NSW_06.jpeg&quot;, dpi = &quot;print&quot;, height = 11, width = 5.8, device = &quot;jpeg&quot;) 9.1.4 Within Clump Distance Determine nearest neighbor distance for the stand and within clusters. Some combination of these metrics has been used to describe relative aggregation. (source?) Calculate the distance to the nearest tree within each clump ttops_temp = ttops_temp %&gt;% dplyr::group_by(clump_id) %&gt;% tidyr::nest() %&gt;% dplyr::mutate( distance_clump_nn_m = purrr::map(data, function(x){ # get index of nearest neighbor i = sf::st_nearest_feature(x) # get dist d = sf::st_distance(x, x[i,], by_element=TRUE) %&gt;% as.numeric() return(d) }) ) %&gt;% tidyr::unnest(cols = c(data, distance_clump_nn_m)) %&gt;% sf::st_set_geometry(&quot;geom&quot;) %&gt;% # set it cuz it got lost dplyr::ungroup() # ggplot() + geom_point(aes(x=X,y=Y,color = distance_clump_nn_m)) + theme_light() plot it ortho_plt_fn(my_suid) + # treetops geom_sf( data = ttops_temp , mapping = aes(color = distance_clump_nn_m) , size = 1 ) + scale_color_viridis_c(option=&quot;viridis&quot;, na.value = &quot;white&quot;) + labs(color = &quot;within clump\\nN.N. dist. (m)&quot;) 9.1.4.1 Create function to get tree list with clumps # create function to pass a unit id and return list of trees with clump groupings get_tree_clumps = function( my_suid , tree_clump_dist_m=6 , ostory_ht_m = as.numeric(NA) , ostory_dbh_cm = as.numeric(NA) ){ # check ostory definition if(is.na(as.numeric(ostory_dbh_cm)) &amp; is.na(as.numeric(ostory_ht_m))){ warning(&quot;`ostory_dbh_cm` and `ostory_ht_m` are not set...using `ostory_dbh_cm` = 12.7&quot;) ostory_dbh_cm = 5*2.54 # filter data ttops_temp = harvests_trees %&gt;% dplyr::filter( suid==my_suid &amp; dbh_cm&gt;=as.numeric(ostory_dbh_cm) ) }else if(!is.na(as.numeric(ostory_dbh_cm))){ # filter data ttops_temp = harvests_trees %&gt;% dplyr::filter( suid==my_suid &amp; dbh_cm&gt;=as.numeric(ostory_dbh_cm) ) }else{ # filter data ttops_temp = harvests_trees %&gt;% dplyr::filter( suid==my_suid &amp; tree_height_m&gt;=as.numeric(ostory_ht_m) ) } # calcs ttops_temp = ttops_temp %&gt;% dplyr::mutate( X = sf::st_coordinates(.)[,1] %&gt;% as.numeric() , Y = sf::st_coordinates(.)[,2] %&gt;% as.numeric() ) ############################################################################# ##### Identify clusters in each stem map plot ##### ############################################################################# ### Place trees into clusters using an inter-tree distance of 6 m my_dbscan_temp = ttops_temp %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(X,Y) %&gt;% dbscan::dbscan(eps = tree_clump_dist_m, minPts = 2) # my_dbscan_temp %&gt;% str() ### append cluster ID to trees ttops_temp$dbscan_cluster = my_dbscan_temp$cluster # ttops_temp$cluster %&gt;% summary() # ttops_temp %&gt;% sf::st_drop_geometry() %&gt;% dplyr::count(cluster) %&gt;% dplyr::arrange(desc(n)) %&gt;% dplyr::slice_head(n=11) ### cluster metrics ttops_temp = ttops_temp %&gt;% dplyr::group_by(dbscan_cluster) %&gt;% dplyr::mutate( # unique dbscan_cluster for individuals clump_id = dplyr::case_when( dbscan_cluster == 0 ~ max(my_dbscan_temp$cluster)+dplyr::row_number() , T ~ dbscan_cluster ) %&gt;% factor() ) %&gt;% dplyr::group_by(clump_id) %&gt;% dplyr::mutate( dbscan_cluster = factor(dbscan_cluster) , clump_n_trees = dplyr::n() , clump_n_trees_grp = cut( clump_n_trees ,breaks = c(0,1,4,9,15,Inf) , labels = c(&quot;Individual&quot;,&quot;2-4 trees&quot;,&quot;5-9 trees&quot;,&quot;10-15 trees&quot;,&quot;&gt;15 trees&quot;) ) %&gt;% factor( ordered = T , levels = c(&quot;Individual&quot;,&quot;2-4 trees&quot;,&quot;5-9 trees&quot;,&quot;10-15 trees&quot;,&quot;&gt;15 trees&quot;) ) ) %&gt;% dplyr::ungroup() # add distance to nearest within clump ttops_temp = ttops_temp %&gt;% dplyr::group_by(clump_id) %&gt;% tidyr::nest() %&gt;% dplyr::mutate( distance_clump_nn_m = purrr::map(data, function(x){ # get index of nearest neighbor i = sf::st_nearest_feature(x) # get dist d = sf::st_distance(x, x[i,], by_element=TRUE) %&gt;% as.numeric() return(d) }) ) %&gt;% tidyr::unnest(cols = c(data, distance_clump_nn_m)) %&gt;% sf::st_set_geometry(&quot;geom&quot;) %&gt;% # set it cuz it got lost dplyr::ungroup() %&gt;% dplyr::mutate( tree_clump_dist_m = tree_clump_dist_m # , ostory_ht_m = ifelse(is.na(ostory_ht_m), as.numeric(NA), as.numeric(ostory_ht_m)) # , ostory_dbh_cm = ifelse(is.na(ostory_dbh_cm), as.numeric(NA), as.numeric(ostory_dbh_cm)) ) # return return(ttops_temp) } # call it ttops_temp = get_tree_clumps( my_suid = my_suid , tree_clump_dist_m = tree_clump_dist_m , ostory_dbh_cm = ostory_dbh_cm ) 9.1.5 Clump Polygons and Metrics Churchill et al. (2016) provide instructions for implementing the clump identification (Plotkin et al. 2002) in ArcGIS: Use the Buffer tool (in the Proximity toolset within the Analysis toolbox) to create a buffer of distance d/2, one half the inter-tree distance, around each point. This quantity d/2 is meant to approximate the crown radius of a “typical” overstory tree. Set the Dissolve Type option to ALL, which dissolves overlapping buffers, creating a reduced set of spatially non-overlapping polygons stored as a multipart polygon feature…Sanchez Meador et al. (2011) provide some useful examples of how clump attributes can be summarized…The method described here can be modified to use measured or modeled crown radii for each tree in place of d/2 (p.36) # create function to pass a return from get_tree_clumps() and create clump polygons with summary stats get_clump_summary = function(dta){ # get tree_clump_dist_m tree_clump_dist_m = min(dta$tree_clump_dist_m, na.rm = T) # create clump polys and summary clump_polys_temp = dta %&gt;% dplyr::ungroup() %&gt;% sf::st_set_geometry(&quot;geometry&quot;) %&gt;% sf::st_buffer(tree_clump_dist_m/2) %&gt;% dplyr::group_by(suid, clump_id, dbscan_cluster, clump_n_trees_grp) %&gt;% dplyr::summarise( # union buffered tree points geometry = sf::st_union(geometry) # summary metrics , n_trees = dplyr::n_distinct(treeID) , mean_dbh_cm = mean(dbh_cm, na.rm = T) , mean_tree_height_m = mean(tree_height_m, na.rm = T) , loreys_height_m = sum(basal_area_m2*tree_height_m, na.rm = T) / sum(basal_area_m2, na.rm = T) , basal_area_m2 = sum(basal_area_m2, na.rm = T) , sum_dbh_cm_sq = sum(dbh_cm^2, na.rm = T) ) %&gt;% dplyr::ungroup() %&gt;% sf::st_make_valid() %&gt;% dplyr::mutate( clump_area_ha = sf::st_area(geometry) %&gt;% as.numeric() %&gt;% `/`(10000) , trees_per_ha = (n_trees/clump_area_ha) , basal_area_m2_per_ha = (basal_area_m2/clump_area_ha) , pct_stand_basal_area = basal_area_m2/sum(basal_area_m2) , pct_stand_n_trees = n_trees/sum(n_trees) , qmd_cm = sqrt(sum_dbh_cm_sq/n_trees) ) %&gt;% dplyr::select(-c(sum_dbh_cm_sq)) %&gt;% # convert to imperial units calc_imperial_units_fn() %&gt;% dplyr::mutate(tree_clump_dist_m = tree_clump_dist_m) # calculate distance between clumps clump_polys_temp = clump_polys_temp %&gt;% dplyr::mutate( nearest = sf::st_nearest_feature(clump_polys_temp) , distance_nearest_clump_m = sf::st_distance( clump_polys_temp , clump_polys_temp[nearest,] , by_element=TRUE ) %&gt;% as.numeric() ) %&gt;% dplyr::select(-c(nearest)) # return return(clump_polys_temp) } # get it # get_clump_summary( # dta = get_tree_clumps(my_suid = my_suid, tree_clump_dist_m = tree_clump_dist_m) # ) clump_polys_temp = get_clump_summary(ttops_temp) # what? clump_polys_temp %&gt;% dplyr::glimpse() ## Rows: 465 ## Columns: 26 ## $ suid &lt;chr&gt; &quot;0203088082660001000&quot;, &quot;0203088082660001000&quot;,… ## $ clump_id &lt;fct&gt; 269, 270, 271, 272, 273, 274, 275, 276, 277, … ## $ dbscan_cluster &lt;fct&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ clump_n_trees_grp &lt;ord&gt; Individual, Individual, Individual, Individua… ## $ geometry &lt;POLYGON [m]&gt; POLYGON ((610696.9 4889087,..., POLYG… ## $ n_trees &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, … ## $ mean_dbh_cm &lt;dbl&gt; 27.41359, 15.20204, 13.87409, 19.94740, 26.62… ## $ mean_tree_height_m &lt;dbl&gt; 13.338, 8.104, 7.523, 10.099, 12.864, 8.047, … ## $ loreys_height_m &lt;dbl&gt; 13.338, 8.104, 7.523, 10.099, 12.864, 8.047, … ## $ basal_area_m2 &lt;dbl&gt; 0.05902306, 0.01815071, 0.01511815, 0.0312509… ## $ clump_area_ha &lt;dbl&gt; 0.002826142, 0.002826142, 0.002826142, 0.0028… ## $ trees_per_ha &lt;dbl&gt; 353.8393, 353.8393, 353.8393, 353.8393, 353.8… ## $ basal_area_m2_per_ha &lt;dbl&gt; 20.884680, 6.422435, 5.349396, 11.057798, 19.… ## $ pct_stand_basal_area &lt;dbl&gt; 0.0005399084, 0.0001660321, 0.0001382920, 0.0… ## $ pct_stand_n_trees &lt;dbl&gt; 0.0004631774, 0.0004631774, 0.0004631774, 0.0… ## $ qmd_cm &lt;dbl&gt; 27.41359, 15.20204, 13.87409, 19.94740, 26.62… ## $ mean_dbh_in &lt;dbl&gt; 10.800955, 5.989604, 5.466390, 7.859276, 10.4… ## $ qmd_in &lt;dbl&gt; 10.800955, 5.989604, 5.466390, 7.859276, 10.4… ## $ mean_tree_height_ft &lt;dbl&gt; 43.74864, 26.58112, 24.67544, 33.12472, 42.19… ## $ loreys_height_ft &lt;dbl&gt; 43.74864, 26.58112, 24.67544, 33.12472, 42.19… ## $ basal_area_ft2_per_ac &lt;dbl&gt; 91.03632, 27.99539, 23.31802, 48.20094, 85.87… ## $ trees_per_ac &lt;dbl&gt; 143.3049, 143.3049, 143.3049, 143.3049, 143.3… ## $ clump_area_ac &lt;dbl&gt; 0.006983396, 0.006983396, 0.006983396, 0.0069… ## $ basal_area_ft2 &lt;dbl&gt; 0.6353242, 0.1953742, 0.1627318, 0.3363847, 0… ## $ tree_clump_dist_m &lt;dbl&gt; 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, … ## $ distance_nearest_clump_m &lt;dbl&gt; 0.021675089, 0.934747368, 4.205774953, 0.9347… # do these numbers match identical( # clump polys nrow(clump_polys_temp) # clumps in tree list data , ttops_temp %&gt;% dplyr::distinct(clump_id) %&gt;% nrow() ) ## [1] TRUE plot it ortho_plt_fn(my_suid) + # clumps ggnewscale::new_scale_fill() + geom_sf( data = clump_polys_temp , mapping = aes(fill = dbscan_cluster) , color = NA, alpha = 0.9 ) + scale_fill_manual(values = c( &quot;white&quot; , # get random list of colors from viridis and avoid whites c( viridis::turbo(length(unique(ttops_temp$dbscan_cluster))/2 %&gt;% round()) , viridis::plasma(length(unique(ttops_temp$dbscan_cluster))/2 %&gt;% round(), end = 0.95) , viridis::viridis(length(unique(ttops_temp$dbscan_cluster))/2 %&gt;% round(), end = 0.9) , viridis::cividis(length(unique(ttops_temp$dbscan_cluster))/2 %&gt;% round(), end = 0.9) ) %&gt;% sample() %&gt;% .[1:length(unique(ttops_temp$dbscan_cluster))-1] ) ) + labs(subtitle = &quot;\\n overstory tree group polygons\\n(individual trees in white)&quot;) + theme( legend.position = &quot;none&quot; , plot.subtitle = element_text(size = 9.5, hjust = 0.5, face = &quot;bold&quot;) ) check the distance between clumps ortho_plt_fn(my_suid) + ggnewscale::new_scale_fill() + geom_sf( data = clump_polys_temp , mapping = aes(fill = distance_nearest_clump_m) , size = 1, color = NA ) + scale_fill_viridis_c(option=&quot;viridis&quot;, na.value = &quot;white&quot;) + labs(fill = &quot;nearest clump\\ndist. (m)&quot;) 9.1.6 Clump Spacing See Churchill et al. (2016) Figure 4 (p.10) and Matonis and Binkley (2018) who “calculated coverage of mosaic-meadows (percentage of stand &gt; 6 m from overstory trees)” (p. 124) Since we already buffered the tree points to approximate the crown radius, we’ll continue to use our \\(d/2\\) where \\(d\\) is maximum distance between trees for determining tree clumps and is meant to approximate the crown radius of a “typical” overstory tree # create function to pass a return from get_clump_summary() and get a distance raster get_clump_dist_rast = function(dta){ # get tree_clump_dist_m tree_clump_dist_m = min(dta$tree_clump_dist_m, na.rm = T) # suid my_suid = dta$suid[1] # rasterize the clump polygons and then calculate distance between clumps as raster dist_rast = terra::rasterize( x = clump_polys_temp %&gt;% terra::vect() , y = clump_polys_temp %&gt;% terra::vect() %&gt;% terra::rast(res = 0.2) ) %&gt;% terra::distance() %&gt;% # crop it to stand extent terra::crop( harvests %&gt;% dplyr::filter(suid==my_suid) %&gt;% terra::vect() ) %&gt;% terra::mask( harvests %&gt;% dplyr::filter(suid==my_suid) %&gt;% terra::vect() ) ######### part 2 # now create openings vector data openings_vect = dist_rast %&gt;% terra::classify(rcl = c(tree_clump_dist_m/2,Inf), others = NA, include.lowest = T) %&gt;% terra::as.polygons(na.rm = T) %&gt;% sf::st_as_sf() %&gt;% sf::st_cast(&quot;POLYGON&quot;) %&gt;% dplyr::mutate(layer = dplyr::row_number()) %&gt;% dplyr::mutate( openining_area_m2 = sf::st_area(geometry) %&gt;% as.numeric() , suid = my_suid , tree_clump_dist_m = tree_clump_dist_m ) # return return(list(dist_rast = dist_rast, openings_vect = openings_vect)) } # get it dist_rast_temp = get_clump_dist_rast(clump_polys_temp) dist_rast_temp ## $dist_rast ## class : SpatRaster ## dimensions : 3259, 1565, 1 (nrow, ncol, nlyr) ## resolution : 0.2, 0.2 (x, y) ## extent : 610479.1, 610792.1, 4888438, 4889090 (xmin, xmax, ymin, ymax) ## coord. ref. : NAD83 / UTM zone 13N (EPSG:26913) ## source(s) : memory ## name : layer ## min value : 0.00000 ## max value : 19.20521 ## ## $openings_vect ## Simple feature collection with 283 features and 4 fields ## Geometry type: POLYGON ## Dimension: XY ## Bounding box: xmin: 610479.1 ymin: 4888438 xmax: 610791.5 ymax: 4889090 ## Projected CRS: NAD83 / UTM zone 13N ## First 10 features: ## layer geometry openining_area_m2 suid ## 1 1 POLYGON ((610700.9 4889089,... 6.60 0203088082660001000 ## 1.1 2 POLYGON ((610684.7 4889085,... 0.04 0203088082660001000 ## 1.2 3 POLYGON ((610707.9 4889090,... 18.20 0203088082660001000 ## 1.3 4 POLYGON ((610697.3 4889082,... 0.56 0203088082660001000 ## 1.4 5 POLYGON ((610724.1 4889090,... 114.52 0203088082660001000 ## 1.5 6 POLYGON ((610717.1 4889080,... 14.48 0203088082660001000 ## 1.6 7 POLYGON ((610702.9 4889075,... 0.04 0203088082660001000 ## 1.7 8 POLYGON ((610684.3 4889085,... 112.44 0203088082660001000 ## 1.8 9 POLYGON ((610702.1 4889072,... 2.76 0203088082660001000 ## 1.9 10 POLYGON ((610753.5 4889090,... 167.40 0203088082660001000 ## tree_clump_dist_m ## 1 6 ## 1.1 6 ## 1.2 6 ## 1.3 6 ## 1.4 6 ## 1.5 6 ## 1.6 6 ## 1.7 6 ## 1.8 6 ## 1.9 6 plot the distance raster and openings vector data we just got with overlaid tree clumps and tree points plt_fnl_temp = ggplot() + # distance geom_tile( data = dist_rast_temp$dist_rast %&gt;% terra::aggregate(2, cores = 4) %&gt;% as.data.frame(xy = T) %&gt;% rename(f=3) , mapping = aes(x=x, y=y, fill = f) ) + scale_fill_distiller( palette = &quot;YlOrRd&quot; , na.value = &quot;transparent&quot; , direction = 1 , name = &quot;distance to\\nnearest tree (m)&quot; ) + # openings geom_sf(data = dist_rast_temp$openings_vect, mapping = aes(color = openining_area_m2), fill = NA) + scale_color_gradient( low = &quot;gray77&quot;, high = &quot;gray11&quot; , labels = scales::comma_format(accuracy = 1) , name = latex2exp::TeX(&quot;opening\\narea ($\\\\m^2$)&quot;) ) + # clumps ggnewscale::new_scale_fill() + geom_sf( data = clump_polys_temp , mapping = aes(fill = clump_n_trees_grp) , color = NA ) + scale_fill_viridis_d(option=&quot;mako&quot;, direction = -1, name = &quot;clump size&quot;) + # tree points geom_sf(data = ttops_temp, color = &quot;gray88&quot;, shape = &quot;.&quot;) + theme_void() ## |---------|---------|---------|---------|========================================= # plot plt_fnl_temp # save it ggplot2::ggsave(&quot;../data/NSW_07.jpeg&quot;, dpi = &quot;print&quot;, height = 11, width = 5.8, device = &quot;jpeg&quot;) highlight the openings plt_open_temp = ggplot() + # clumps geom_sf( data = clump_polys_temp , mapping = aes(fill = clump_n_trees_grp) , color = NA ) + scale_fill_viridis_d(option=&quot;mako&quot;, direction = -1, name = &quot;clump size&quot;) + # openings ggnewscale::new_scale_fill() + geom_sf(data = dist_rast_temp$openings_vect, mapping = aes(fill = openining_area_m2), color = NA) + scale_fill_gradient( low = &quot;gray77&quot;, high = &quot;gray11&quot; , labels = scales::comma_format(accuracy = 1) , name = latex2exp::TeX(&quot;opening\\narea ($\\\\m^2$)&quot;) ) + # tree points geom_sf(data = ttops_temp, color = &quot;gray88&quot;, shape = &quot;.&quot;) + theme_void() plt_open_temp # save it ggplot2::ggsave(&quot;../data/NSW_08.jpeg&quot;, dpi = &quot;print&quot;, height = 11, width = 5.8, device = &quot;jpeg&quot;) combine them? plt_fnl_temp + (plt_open_temp + theme(legend.position = &quot;none&quot;)) # save it ggplot2::ggsave(&quot;../data/NSW_09.jpeg&quot;, dpi = &quot;print&quot;, height = 11, width = 8, device = &quot;jpeg&quot;) 9.1.7 Clump Metrics create a function to summarize by number of tree clump grouping variable # create a function to summarize by number of tree clump grouping get_clump_n_trees_grp_summary = function(trees, clumps){ # get area of harvest unit #...will use this area in the area calculations such that... #...TPA = trees in a certain group size across the whole stand area harvest_area_m2 = harvests %&gt;% dplyr::filter(suid == trees$suid[1]) %&gt;% dplyr::pull(harvest_area_m2) %&gt;% .[1] # collapse and calculate silv metrics dta = trees %&gt;% sf::st_drop_geometry() %&gt;% dplyr::group_by(suid,stand_area_ha,clump_n_trees_grp) %&gt;% dplyr::summarise( # summary metrics n_trees = dplyr::n_distinct(treeID) , mean_dbh_cm = mean(dbh_cm, na.rm = T) , mean_tree_height_m = mean(tree_height_m, na.rm = T) , loreys_height_m = sum(basal_area_m2*tree_height_m, na.rm = T) / sum(basal_area_m2, na.rm = T) , basal_area_m2 = sum(basal_area_m2, na.rm = T) , sum_dbh_cm_sq = sum(dbh_cm^2, na.rm = T) ) %&gt;% dplyr::ungroup() %&gt;% # attach clump area dplyr::left_join( clumps %&gt;% sf::st_drop_geometry() %&gt;% dplyr::group_by(suid,clump_n_trees_grp) %&gt;% dplyr::summarise(clump_area_ha = sum(clump_area_ha), stand_n_clumps = dplyr::n()) ) %&gt;% dplyr::mutate( trees_per_ha = (n_trees/clump_area_ha) # (n_trees/stand_area_ha) ... this was not right , basal_area_m2_per_ha = (basal_area_m2/clump_area_ha) # (basal_area_m2/stand_area_ha) ... this was not right , qmd_cm = sqrt(sum_dbh_cm_sq/n_trees) # stand calcs , stand_trees_per_ha = sum(n_trees)/stand_area_ha , stand_basal_area_m2 = sum(basal_area_m2) , stand_basal_area_m2_per_ha = sum(basal_area_m2)/stand_area_ha , pct_stand_basal_area = basal_area_m2/stand_basal_area_m2 , pct_stand_n_trees = n_trees/sum(n_trees) , stand_qmd_cm = sqrt(sum(trees$dbh_cm^2, na.rm = T)/sum(n_trees)) ) %&gt;% dplyr::select(-c(sum_dbh_cm_sq)) %&gt;% # convert to imperial units calc_imperial_units_fn() # return return(dta) } # call it clump_n_trees_grp_summary_temp = get_clump_n_trees_grp_summary( trees = get_tree_clumps(my_suid = my_suid, tree_clump_dist_m = tree_clump_dist_m, ostory_dbh_cm = ostory_dbh_cm) , clumps = get_clump_summary( get_tree_clumps(my_suid = my_suid, tree_clump_dist_m = tree_clump_dist_m, ostory_dbh_cm = ostory_dbh_cm) ) ) # what? clump_n_trees_grp_summary_temp %&gt;% dplyr::glimpse() ## Rows: 5 ## Columns: 32 ## $ suid &lt;chr&gt; &quot;0203088082660001000&quot;, &quot;020308808266000100… ## $ stand_area_ha &lt;dbl&gt; 12.21615, 12.21615, 12.21615, 12.21615, 12… ## $ clump_n_trees_grp &lt;ord&gt; Individual, 2-4 trees, 5-9 trees, 10-15 tr… ## $ n_trees &lt;int&gt; 197, 379, 439, 486, 658 ## $ mean_dbh_cm &lt;dbl&gt; 24.34351, 26.20884, 25.00586, 24.40901, 22… ## $ mean_tree_height_m &lt;dbl&gt; 11.92746, 12.71196, 12.21416, 11.99020, 11… ## $ loreys_height_m &lt;dbl&gt; 14.86376, 15.12744, 13.83070, 13.57247, 12… ## $ basal_area_m2 &lt;dbl&gt; 10.54721, 22.93705, 23.35847, 24.51853, 27… ## $ clump_area_ha &lt;dbl&gt; 0.5567499, 0.9253275, 1.0161666, 1.0772512… ## $ stand_n_clumps &lt;int&gt; 197, 140, 65, 40, 23 ## $ trees_per_ha &lt;dbl&gt; 353.8393, 409.5847, 432.0158, 451.1482, 47… ## $ basal_area_m2_per_ha &lt;dbl&gt; 18.94426, 24.78804, 22.98685, 22.76027, 20… ## $ qmd_cm &lt;dbl&gt; 26.10904, 27.75903, 26.02825, 25.34452, 23… ## $ stand_trees_per_ha &lt;dbl&gt; 176.7333, 176.7333, 176.7333, 176.7333, 17… ## $ stand_basal_area_m2 &lt;dbl&gt; 109.3205, 109.3205, 109.3205, 109.3205, 10… ## $ stand_basal_area_m2_per_ha &lt;dbl&gt; 8.948854, 8.948854, 8.948854, 8.948854, 8.… ## $ pct_stand_basal_area &lt;dbl&gt; 0.09647974, 0.20981473, 0.21366963, 0.2242… ## $ pct_stand_n_trees &lt;dbl&gt; 0.09124595, 0.17554423, 0.20333488, 0.2251… ## $ stand_qmd_cm &lt;dbl&gt; 25.39099, 25.39099, 25.39099, 25.39099, 25… ## $ mean_dbh_in &lt;dbl&gt; 9.591343, 10.326282, 9.852309, 9.617151, 8… ## $ qmd_in &lt;dbl&gt; 10.286960, 10.937057, 10.255132, 9.985742,… ## $ stand_qmd_in &lt;dbl&gt; 10.00405, 10.00405, 10.00405, 10.00405, 10… ## $ mean_tree_height_ft &lt;dbl&gt; 39.12208, 41.69521, 40.06244, 39.32785, 36… ## $ loreys_height_ft &lt;dbl&gt; 48.75313, 49.61801, 45.36471, 44.51770, 41… ## $ basal_area_ft2_per_ac &lt;dbl&gt; 82.57803, 108.05106, 100.19970, 99.21201, … ## $ stand_basal_area_ft2_per_ac &lt;dbl&gt; 39.00806, 39.00806, 39.00806, 39.00806, 39… ## $ trees_per_ac &lt;dbl&gt; 143.3049, 165.8818, 174.9664, 182.7150, 19… ## $ stand_trees_per_ac &lt;dbl&gt; 71.577, 71.577, 71.577, 71.577, 71.577 ## $ stand_area_ac &lt;dbl&gt; 30.1861, 30.1861, 30.1861, 30.1861, 30.1861 ## $ clump_area_ac &lt;dbl&gt; 1.375729, 2.286484, 2.510948, 2.661888, 3.… ## $ basal_area_ft2 &lt;dbl&gt; 113.5302, 246.8944, 251.4306, 263.9174, 30… ## $ stand_basal_area_ft2 &lt;dbl&gt; 1176.726, 1176.726, 1176.726, 1176.726, 11… summary table # table it clump_n_trees_grp_summary_temp %&gt;% dplyr::select( clump_n_trees_grp, n_trees , mean_dbh_in , qmd_in , mean_tree_height_ft , loreys_height_ft , trees_per_ac , basal_area_ft2_per_ac, pct_stand_basal_area, pct_stand_n_trees ) %&gt;% dplyr::mutate( dplyr::across( .cols = c(pct_stand_basal_area, pct_stand_n_trees) , .fns = ~ scales::percent(.x, accuracy = 1) ) ) %&gt;% kableExtra::kbl( digits = 1 , escape = F , caption = paste0(&quot;Overstory tree clump summary&lt;br&gt;&quot;, &quot;stand suid: &quot;, clump_n_trees_grp_summary_temp$suid[1]) , col.names = c( &quot;&quot;, &quot;trees&quot; , &quot;mean&lt;br&gt;DBH (in)&quot; , &quot;QMD (in)&quot; , &quot;mean&lt;br&gt;Ht. (ft)&quot; , &quot;Loreys&lt;br&gt;Ht. (ft)&quot; , &quot;TPA&quot; , &quot;BA&lt;br&gt;ft&lt;sup&gt;2&lt;/sup&gt; ac&lt;sup&gt;-1&lt;/sup&gt;&quot; , &quot;%&lt;br&gt;stand BA&quot; , &quot;%&lt;br&gt;stand trees&quot; ) ) %&gt;% kableExtra::kable_styling() Table 9.1: Overstory tree clump summarystand suid: 0203088082660001000 trees meanDBH (in) QMD (in) meanHt. (ft) LoreysHt. (ft) TPA BAft2 ac-1 %stand BA %stand trees Individual 197 9.6 10.3 39.1 48.8 143.3 82.6 10% 9% 2-4 trees 379 10.3 10.9 41.7 49.6 165.9 108.1 21% 18% 5-9 trees 439 9.9 10.3 40.1 45.4 175.0 100.2 21% 20% 10-15 trees 486 9.6 10.0 39.3 44.5 182.7 99.2 22% 23% &gt;15 trees 658 8.8 9.2 36.6 41.0 193.7 88.6 26% 30% plot it clump_n_trees_grp_summary_temp %&gt;% dplyr::select( clump_n_trees_grp, n_trees , mean_dbh_in , qmd_in , mean_tree_height_ft , loreys_height_ft , trees_per_ac , basal_area_ft2_per_ac, pct_stand_basal_area ) %&gt;% dplyr::mutate(pct_stand_basal_area = pct_stand_basal_area*100) %&gt;% tidyr::pivot_longer( cols = -c(clump_n_trees_grp) ) %&gt;% dplyr::mutate( metric = factor( name , ordered = T , levels = c( &quot;n_trees&quot; , &quot;mean_dbh_in&quot; , &quot;qmd_in&quot; , &quot;mean_tree_height_ft&quot; , &quot;loreys_height_ft&quot; , &quot;trees_per_ac&quot; , &quot;basal_area_ft2_per_ac&quot; , &quot;pct_stand_basal_area&quot; ) , labels = c( latex2exp::TeX(&quot;Number of Trees&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Mean DBH (in)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;QMD (in)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Mean Tree Height (ft)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Lorey&#39;s Mean Height (ft)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Trees $ac^{-1}$&quot;) , latex2exp::TeX(&quot;Basal Area $ft^{2} \\\\cdot ac^{-1}$&quot;) , latex2exp::TeX(&quot;% stand BA&quot;, output = &quot;character&quot;) ) ) , clump_n_trees_grp = forcats::fct_rev(clump_n_trees_grp) ) %&gt;% ggplot(mapping = aes( x = value, y = clump_n_trees_grp , fill = name, label = scales::number(value, accuracy = 0.1) ) ) + geom_col(width = 0.7) + geom_text(color = &quot;black&quot;, size = 3.5, hjust = -0.1) + facet_wrap(facets = vars(metric), ncol = 2, scales = &quot;free_x&quot;, labeller = label_parsed) + scale_fill_viridis_d(option = &quot;cividis&quot;, alpha = 0.9) + scale_x_continuous(expand = expansion(mult = c(0,0.1))) + labs( x = &quot;&quot;, y = &quot;&quot; , subtitle = paste0( &quot;Overstory tree clump summary\\n&quot; , &quot;stand suid: &quot; , clump_n_trees_grp_summary_temp$suid[1]) ) + theme_light() + theme( legend.position = &quot;none&quot; , strip.text = element_text(color = &quot;black&quot;, size = 10) , strip.background = element_rect(fill = &quot;gray88&quot;) , axis.text.y = element_text(face = &quot;bold&quot;) , axis.ticks.y = element_blank() , panel.grid.major.y = element_blank() , panel.grid.minor.y = element_blank() ) 9.2 ICO Implementation Churchill et al. (2016) describe the full process for implementing the ICO approach in The ICO Approach to Quantifying and Restoring Forest Spatial Pattern: Implementation Guide in which the authors lay out the prescription development process: Identify skips and other special treatment areas Consider the need for openings Determine the stand average density target Determine the appropriate distance to define clumps Obtain targets for clump proportions Select target clump proportions for your stand Generate clump targets for the whole unit Combine clump and opening targets with leave tree criteria into marking guidelines The objective here is to: 1) provide the manager with the current conditions (completed above); 2) take the “targets” as set by the manager (steps 3, 5, 6, 7); 3) create the prescription with the leave tree marking. Let’s implement this prescription development process with our UAS tree list 9.2.1 3. Determine the stand average density target Step 3 in Churchill et al. (2016): An average BA, TPA, or SDI target for the stand should be selected that is appropriate for the species, structure, site conditions, and management objectives. Expected mortality from prescribed fire should be factored in. Stand average targets can come from historical reference stands, plant association based stocking guides, density management tools, or a combination of both (see Franklin et al. (2013) for a full discussion of setting density targets). In dry forests, the number and size of old trees must be accounted in setting the density target. To use the ICO method, the target must be converted to TPA (see Table 1). A lower diameter cutoff also needs to be specified for the TPA target. This should be the lower limit in the contract or cutting guidelines given to the marking crew or contractor. (p.11) this is what Table 1 looks like with TPA values are derived from the formula: \\[ TPA = \\frac{BA}{QMD^{2} \\times 0.005454} \\] # function to get tpa from ba and qmd get_tpa = function(ba_ft2_ac, qmd_in){ tpa = round(ba_ft2_ac/((qmd_in^2)*0.005454)) return(tpa) } # table it tidyr::crossing( ba = seq(40,200,20) , qmd = seq(8,20,2) ) %&gt;% dplyr::mutate( tpa = get_tpa(ba,qmd) ) %&gt;% tidyr::pivot_wider(names_from = ba, values_from = tpa) %&gt;% dplyr::mutate(l = &quot;QMD (in)&quot;) %&gt;% dplyr::relocate(l) %&gt;% kableExtra::kbl( col.names = c(&quot;.&quot;,&quot;&quot;, seq(40,200,20)) , escape = F , caption = &quot;Basal Area and QMD to TPA conversion chart&quot; ) %&gt;% kableExtra::add_header_above( c(&quot;&quot;,&quot;&quot;, &quot;Basal Area (ft2/ac)&quot;=length(seq(40,200,20))) ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::column_spec(1:2, bold = T) %&gt;% kableExtra::collapse_rows(columns = 1, valign = &quot;middle&quot;) Table 9.2: Basal Area and QMD to TPA conversion chart Basal Area (ft2/ac) . 40 60 80 100 120 140 160 180 200 QMD (in) 8 115 172 229 286 344 401 458 516 573 10 73 110 147 183 220 257 293 330 367 12 51 76 102 127 153 178 204 229 255 14 37 56 75 94 112 131 150 168 187 16 29 43 57 72 86 100 115 129 143 18 23 34 45 57 68 79 91 102 113 20 18 28 37 46 55 64 73 83 92 9.2.1.1 Current Stand Conditions For determining targets, the silviculturist needs to know the current conditions. Provide the current stand conditions based on the UAS tree list for the selected stand that are required to set the targets: Current BA Current QMD Current proportion of trees by clump size clump_n_trees_grp_summary_temp %&gt;% dplyr::select(clump_n_trees_grp, pct_stand_n_trees) %&gt;% dplyr::mutate( pct_stand_n_trees = scales::percent(pct_stand_n_trees,accuracy = 1) ) %&gt;% tidyr::pivot_wider(names_from = clump_n_trees_grp, values_from = pct_stand_n_trees) %&gt;% kableExtra::kable( caption = paste0( &quot;Current stand BA (ft2/ac): &quot; , clump_n_trees_grp_summary_temp$stand_basal_area_ft2_per_ac[1] %&gt;% scales::number(accuracy = 0.1) , &quot;&lt;br&gt;Current stand QMD (in): &quot; , clump_n_trees_grp_summary_temp$stand_qmd_in[1] %&gt;% scales::number(accuracy = 0.1) , &quot;&lt;br&gt;Current stand TPA: &quot; , clump_n_trees_grp_summary_temp$stand_trees_per_ac[1] %&gt;% scales::number(accuracy = 1) ) , escape = F , digits = 1 ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::footnote(general = &quot;values are the percent of trees in each clump size&quot;) Table 9.3: Table 9.4: Current stand BA (ft2/ac): 39.0Current stand QMD (in): 10.0Current stand TPA: 72 Individual 2-4 trees 5-9 trees 10-15 trees &gt;15 trees 9% 18% 20% 23% 30% Note: values are the percent of trees in each clump size 9.2.2 5. Obtain targets for clump proportions Step 5 in Churchill et al. (2016): ICO prescriptions are based on a target proportion of trees in different sized clumps within a stand. Proportions are just the percentage of trees, or TPA, that are in different sized clumps. Basal area proportions can be used, but we have found TPA targets to be more straightforward to use. Ideally, a table summarizing clump proportions for a range of reference conditions in your area is available (Table 2). If not, instructions for developing one are provided in section VI. (p.12) Section VI of Churchill et al. (2016) notes that reference spatial information may already be available and summarized in a way that it can be directly incorporated into ICO prescriptions. Such data exist and have been published for areas in Arizona (Abella and Denton 2009, Sánchez Meador et al. 2011), the eastern Washington Cascades (Churchill et al. 2013), the northern Rockies (Larson et al. 2012), and the Sierra Nevada (Lydersen et al. 2013). Reference datasets for using ICO in other forest types, such as coastal Douglas-fir or Pacific silver fir, also exist (Larson and Churchill 2008). (p.28) Table 2 is: 9.2.3 6. Select target clump proportions for your stand Now set the desired BA, QMD, and proportion of trees in each clump size: ######################################################################################## ######################################################################################## # desired BA, QMD, and proportion of trees in each clump size ######################################################################################## ######################################################################################## # desired BA target_ba = 37 # cannot be &gt; current BA # desired QMD target_qmd = 11 # desired proportion (%) of trees in each clump size # !cannot be create larger proportion of &quot;&gt;15 trees&quot; clump as this would require adding trees... # c(&quot;Individual&quot;, &quot;2-4 trees&quot;, &quot;5-9 trees&quot;, &quot;10-15 trees&quot;, &quot;&gt;15 trees&quot;) # c(.18, .33, .24, .10, .15) target_pcts = c(.18, .33, .24, .10, .15) ######################################################################################## ######################################################################################## # desired BA, QMD, and proportion of trees in each clump size ######################################################################################## ######################################################################################## Check set up and define data with targets get_target_check_prescription = function( clump_n_trees_grp_summary_dta , target_ba = as.numeric(NA) , target_qmd = as.numeric(NA) , target_pcts = as.numeric(NA) ){ if( is.na(target_ba) | is.na(target_qmd) | max(is.na(target_pcts))==1 ){ stop(&quot;must set all of the function parameters:\\n`target_ba`, `target_qmd`, and `target_pcts`&quot;) } ############################################# # check target BA and TPA ############################################# if(as.numeric(target_ba)&gt;clump_n_trees_grp_summary_dta$stand_basal_area_ft2_per_ac[1]){ stop( &quot;target BA in `target_ba` of &quot; , round(as.numeric(target_ba),1), &quot; is greater than current BA of &quot; , clump_n_trees_grp_summary_dta$stand_basal_area_ft2_per_ac[1] %&gt;% round(1) ) } if( get_tpa(target_ba, target_qmd)&gt;clump_n_trees_grp_summary_dta$stand_trees_per_ac[1] ){ stop( &quot;target TPA in of &quot; , round(as.numeric(get_tpa(target_ba, target_qmd)),1), &quot; is greater than current TPA of &quot; , clump_n_trees_grp_summary_dta$stand_trees_per_ac[1] %&gt;% round(1) , &quot;\\n adjust `target_ba` and/or `target_qmd` to get valid TPA&quot; ) } ############################################# # define data with current and target # ... this is &quot;smart&quot; in that percentages are adj based on: # ... 0) are there missing targets? # ... ... if &lt; 5 numbers provided in `target_pcts` then the largest tree groups get targets of 0 # ... 1) do targets sum to 1? # ... ... if not trees are distributed proportionally based on targets provided and trees available # ... 2) is target in largest clump size &gt; current conditions? # ... ... if yes, target is set to current condition # ... 3) is target listed in clump size &gt; current largest clump with trees? # ... ... if yes, target for largest clump size is shifted to current largest clump with trees ############################################# target_data = # create data for joining if missing clump groups dplyr::tibble( suid = rep(clump_n_trees_grp_summary_dta$suid[1],5) , stand_area_ac = rep(clump_n_trees_grp_summary_dta$stand_area_ac[1],5) , clump_n_trees_grp = factor( c(1:5) , labels = c(&quot;Individual&quot;, &quot;2-4 trees&quot;, &quot;5-9 trees&quot;, &quot;10-15 trees&quot;, &quot;&gt;15 trees&quot;) , ordered = T ) , mean_clump_n_trees = c(1,3,7,12,20) ) %&gt;% dplyr::left_join( clump_n_trees_grp_summary_dta %&gt;% dplyr::ungroup() %&gt;% dplyr::select(clump_n_trees_grp, pct_stand_n_trees, stand_n_clumps) ) %&gt;% dplyr::mutate( pct_stand_n_trees = dplyr::coalesce(pct_stand_n_trees,0) , stand_n_clumps = dplyr::coalesce(stand_n_clumps,0) ) %&gt;% # add targets dplyr::bind_cols( pct_stand_n_trees_target = c(as.numeric(target_pcts), rep(0,5))[1:5] # pad target with 0&#39;s ) %&gt;% # adjust target based on difference from 1 dplyr::mutate( pct_stand_n_trees_target = pct_stand_n_trees_target*(1/sum(pct_stand_n_trees_target)) # largest clump size with trees , largest_w_trees = max(ifelse(dplyr::coalesce(pct_stand_n_trees)&gt;0,clump_n_trees_grp,NA),na.rm = T) , largest_w_trees_target = max(ifelse(dplyr::coalesce(pct_stand_n_trees_target)&gt;0,clump_n_trees_grp,NA),na.rm = T) ) %&gt;% # move target for largest clump size to the largest current clump size dplyr::mutate( pct_stand_n_trees_target = dplyr::case_when( as.numeric(clump_n_trees_grp)==largest_w_trees &amp; largest_w_trees_target&gt;largest_w_trees ~ max( ifelse(as.numeric(clump_n_trees_grp)==largest_w_trees_target,pct_stand_n_trees_target,0) ) , T ~ pct_stand_n_trees_target ) ) %&gt;% # adjust target based on current conditions dplyr::mutate( pct_stand_n_trees_target = dplyr::case_when( as.numeric(clump_n_trees_grp)&gt;largest_w_trees &amp; pct_stand_n_trees_target &gt; 0 ~ 0 , as.numeric(clump_n_trees_grp)==largest_w_trees &amp; pct_stand_n_trees_target &gt; pct_stand_n_trees ~ pct_stand_n_trees , T ~ pct_stand_n_trees_target ) ) %&gt;% # finally, re-scale again based on adjustments dplyr::mutate( pct_stand_n_trees_target = dplyr::case_when( as.numeric(clump_n_trees_grp)==largest_w_trees ~ pct_stand_n_trees_target , T ~ pct_stand_n_trees_target * ( # pct remaining to scale to (1-max(ifelse(as.numeric(clump_n_trees_grp)==largest_w_trees,pct_stand_n_trees_target,0))) / # current pct remaining total allocated sum( ifelse(as.numeric(clump_n_trees_grp)!=largest_w_trees,pct_stand_n_trees_target,0)) ) ) ) %&gt;% # add other targets dplyr::rename(pct_stand_n_trees_current = pct_stand_n_trees) %&gt;% dplyr::mutate( stand_trees_per_ac_current = clump_n_trees_grp_summary_dta$stand_trees_per_ac[1] , stand_trees_per_ac_target = get_tpa(target_ba, target_qmd) , trees_per_acre_current = stand_trees_per_ac_current*pct_stand_n_trees_current , trees_per_acre_target = stand_trees_per_ac_target*pct_stand_n_trees_target , clumps_per_acre_current = trees_per_acre_current/mean_clump_n_trees , clumps_per_acre_target = trees_per_acre_target/mean_clump_n_trees , stand_n_clumps_current = stand_n_clumps , stand_n_clumps_target = (clumps_per_acre_target*stand_area_ac) %&gt;% round(0) ) %&gt;% dplyr::select(-c(tidyselect::starts_with(&quot;largest_w_trees&quot;), stand_n_clumps)) # ???? # target_data %&gt;% glimpse() # issue warning about targets if(min(target_data$pct_stand_n_trees_target == c(as.numeric(target_pcts), rep(0,5))[1:5])==0){ warning( &quot;proportion of trees in each clump size target `target_pcts` adjusted!!!&quot; , &quot;\\nfrom : &quot;, paste(round(target_pcts,2),collapse = &quot;,&quot;) , &quot;\\nto : &quot;, paste(round(target_data$pct_stand_n_trees_target,2),collapse = &quot;,&quot;) ) } # return return(target_data) } # call it target_data_temp = get_target_check_prescription( clump_n_trees_grp_summary_temp , target_ba = target_ba , target_qmd = target_qmd , target_pcts = target_pcts ) # what? target_data_temp %&gt;% dplyr::glimpse() ## Rows: 5 ## Columns: 14 ## $ suid &lt;chr&gt; &quot;0203088082660001000&quot;, &quot;0203088082660001000… ## $ stand_area_ac &lt;dbl&gt; 30.1861, 30.1861, 30.1861, 30.1861, 30.1861 ## $ clump_n_trees_grp &lt;ord&gt; Individual, 2-4 trees, 5-9 trees, 10-15 tre… ## $ mean_clump_n_trees &lt;dbl&gt; 1, 3, 7, 12, 20 ## $ pct_stand_n_trees_current &lt;dbl&gt; 0.09124595, 0.17554423, 0.20333488, 0.22510… ## $ pct_stand_n_trees_target &lt;dbl&gt; 0.18, 0.33, 0.24, 0.10, 0.15 ## $ stand_trees_per_ac_current &lt;dbl&gt; 71.577, 71.577, 71.577, 71.577, 71.577 ## $ stand_trees_per_ac_target &lt;dbl&gt; 56, 56, 56, 56, 56 ## $ trees_per_acre_current &lt;dbl&gt; 6.531111, 12.564929, 14.554100, 16.112284, … ## $ trees_per_acre_target &lt;dbl&gt; 10.08, 18.48, 13.44, 5.60, 8.40 ## $ clumps_per_acre_current &lt;dbl&gt; 6.531111, 4.188310, 2.079157, 1.342690, 1.0… ## $ clumps_per_acre_target &lt;dbl&gt; 10.0800000, 6.1600000, 1.9200000, 0.4666667… ## $ stand_n_clumps_current &lt;dbl&gt; 197, 140, 65, 40, 23 ## $ stand_n_clumps_target &lt;dbl&gt; 304, 186, 58, 14, 13 current vs target target_data_temp %&gt;% dplyr::select( clump_n_trees_grp , tidyselect::starts_with(&quot;pct_stand_n_trees&quot;) , tidyselect::starts_with(&quot;trees_per_acre_&quot;) ) %&gt;% dplyr::mutate( dplyr::across( tidyselect::starts_with(&quot;pct_stand_n_trees&quot;) , ~ scales::percent(.x,accuracy = 1) ) ) %&gt;% kableExtra::kable( caption = paste0( &quot;Current stand BA (ft2/ac): &quot; , clump_n_trees_grp_summary_temp$stand_basal_area_ft2_per_ac[1] %&gt;% scales::number(accuracy = 0.1) , &quot;&lt;br&gt;Current stand QMD (in): &quot; , clump_n_trees_grp_summary_temp$stand_qmd_in[1] %&gt;% scales::number(accuracy = 0.1) , &quot;&lt;br&gt;Current stand TPA: &quot; , clump_n_trees_grp_summary_temp$stand_trees_per_ac[1] %&gt;% scales::number(accuracy = 1) ) , escape = F , digits = 1 , col.names = c( &quot;&quot;, rep(c(&quot;current&quot;,&quot;target&quot;),2) ) ) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::add_header_above( c(&quot; &quot;=1,&quot;% Trees&quot;=2, &quot;TPA&quot;=2) ) Table 9.5: Table 9.6: Current stand BA (ft2/ac): 39.0Current stand QMD (in): 10.0Current stand TPA: 72 % Trees TPA current target current target Individual 9% 18% 6.5 10.1 2-4 trees 18% 33% 12.6 18.5 5-9 trees 20% 24% 14.6 13.4 10-15 trees 23% 10% 16.1 5.6 &gt;15 trees 30% 15% 21.8 8.4 9.2.4 8. Combine clump and opening targets with leave tree criteria into marking guidelines Use our UAS tree list to generate the prescription: start with the largest clump size currently with trees cut trees to the next largest clup size until desired # clumps is reached repeat with each successive clump size through to individual tree selection if possible, cut in same clump until desired proportions are reached to minimize machine time # use target data to get cut trees by clump size group # !!!! need this first: # target_data_temp = get_target_check_prescription( # clump_n_trees_grp_summary_temp # , target_ba = target_ba # , target_qmd = target_qmd # , target_pcts = target_pcts # ) cut_grp_ex_temp = ttops_temp %&gt;% dplyr::filter(clump_n_trees_grp == &quot;&gt;15 trees&quot;) %&gt;% dplyr::group_by(clump_id) %&gt;% tidyr::nest() %&gt;% dplyr::mutate( is_keep_tree = purrr::map(data, function(x, tgt = target_data_temp){ # get next size group n tree target ntree_target_temp = tgt %&gt;% dplyr::mutate(l = dplyr::lag(mean_clump_n_trees)) %&gt;% dplyr::filter(clump_n_trees_grp == x$clump_n_trees_grp[1]) %&gt;% dplyr::pull(l) %&gt;% dplyr::coalesce(0) # join to gridded area based on the tree clump distance grid = x %&gt;% sf::st_bbox() %&gt;% sf::st_make_grid( cellsize = round(tree_clump_dist_m/2,0) ) %&gt;% sf::st_as_sf() %&gt;% dplyr::mutate( grid_n = dplyr::row_number() ) x_grid = x %&gt;% sf::st_join(grid) %&gt;% dplyr::group_by(treeID) %&gt;% dplyr::filter(dplyr::row_number()==1) %&gt;% dplyr::ungroup() # get the biggest tree grid_n big_grid = x_grid %&gt;% dplyr::arrange(desc(dbh_cm), desc(tree_height_m)) %&gt;% dplyr::pull(grid_n) %&gt;% .[1] # start with biggest tree keep adding cells until desired n trees reached x_grid = x_grid %&gt;% dplyr::mutate( sorter = abs(grid_n-big_grid) ) %&gt;% dplyr::arrange(sorter, desc(dbh_cm), desc(tree_height_m)) %&gt;% dplyr::mutate( is_keep_tree = (dplyr::row_number() &lt;= ntree_target_temp) %&gt;% as.numeric() ) # join to original data and pull d = x %&gt;% sf::st_drop_geometry() %&gt;% dplyr::left_join( x_grid %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(treeID, is_keep_tree) #is_keep_tree , by = dplyr::join_by(&quot;treeID&quot;) ) %&gt;% dplyr::pull(is_keep_tree) # return return(d) }) ) %&gt;% tidyr::unnest(cols = c(data, is_keep_tree)) %&gt;% sf::st_set_geometry(&quot;geom&quot;) %&gt;% # set it cuz it got lost dplyr::ungroup() # what? cut_grp_ex_temp %&gt;% dplyr::glimpse() ## Rows: 658 ## Columns: 63 ## $ clump_id &lt;fct&gt; 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,… ## $ suid &lt;chr&gt; &quot;0203088082660001000&quot;, &quot;0203088082660001000&quot;… ## $ forest_commonname &lt;chr&gt; &quot;Black Hills National Forest&quot;, &quot;Black Hills … ## $ admin_region_code &lt;chr&gt; &quot;02&quot;, &quot;02&quot;, &quot;02&quot;, &quot;02&quot;, &quot;02&quot;, &quot;02&quot;, &quot;02&quot;, &quot;0… ## $ activity_name &lt;chr&gt; &quot;Single-tree Selection Cut&quot;, &quot;Single-tree Se… ## $ treatment_type &lt;chr&gt; &quot;Single-tree selectio&quot;, &quot;Single-tree selecti… ## $ treatment_type_grp &lt;chr&gt; &quot;Single-tree/Group Selection Cut&quot;, &quot;Single-t… ## $ date_compl &lt;date&gt; 2021-06-01, 2021-06-01, 2021-06-01, 2021-06… ## $ year_id &lt;dbl&gt; 2021, 2021, 2021, 2021, 2021, 2021, 2021, 20… ## $ stand_area_m2 &lt;dbl&gt; 122161.5, 122161.5, 122161.5, 122161.5, 1221… ## $ stand_area_ha &lt;dbl&gt; 12.21615, 12.21615, 12.21615, 12.21615, 12.2… ## $ treeID &lt;chr&gt; &quot;15301_610728.4_4889078.1&quot;, &quot;15447_610747.6_… ## $ tree_height_m &lt;dbl&gt; 12.801, 14.147, 14.125, 12.965, 15.533, 15.3… ## $ crown_area_m2 &lt;dbl&gt; 10.8125, 3.1875, 8.3125, 10.5000, 9.7500, 11… ## $ comp_trees_per_ha &lt;dbl&gt; 254.7643, 254.7643, 636.9108, 382.1465, 382.… ## $ comp_relative_tree_height &lt;dbl&gt; 90.62655, 92.19290, 98.16527, 91.78761, 100.… ## $ comp_dist_to_nearest_m &lt;dbl&gt; 3.758324, 3.913119, 3.020761, 3.020761, 3.50… ## $ mean_crown_ht_m &lt;dbl&gt; 10.406252, 13.085699, 11.250704, 10.273142, … ## $ median_crown_ht_m &lt;dbl&gt; 10.37733, 12.97100, 11.01700, 10.37700, 13.0… ## $ min_crown_ht_m &lt;dbl&gt; 6.184, 12.091, 6.916, 1.372, 10.270, 6.581, … ## $ reg_est_dbh_cm &lt;dbl&gt; 22.90049, 25.84725, 25.84725, 23.43148, 29.4… ## $ reg_est_lower_dbh_cm &lt;dbl&gt; 14.373235, 15.891937, 15.891937, 14.578828, … ## $ reg_est_upper_dbh_cm &lt;dbl&gt; 33.05160, 37.66970, 37.66970, 34.07166, 43.1… ## $ is_training_data &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FA… ## $ dbh_cm &lt;dbl&gt; 26.38163, 29.44918, 29.44918, 26.71785, 32.5… ## $ dbh_m &lt;dbl&gt; 0.2638163, 0.2944918, 0.2944918, 0.2671785, … ## $ radius_m &lt;dbl&gt; 0.13190816, 0.14724592, 0.14724592, 0.133589… ## $ basal_area_m2 &lt;dbl&gt; 0.05466297, 0.06811400, 0.06811400, 0.056065… ## $ mod_lin_est_dbh_cm &lt;dbl&gt; 26.38163, 29.44918, 29.44918, 26.71785, 32.5… ## $ mod_quad_est_dbh_cm &lt;dbl&gt; 25.94027, 29.08143, 29.08143, 26.55107, 32.2… ## $ mod_quad_noint_est_dbh_cm &lt;dbl&gt; 24.756043, 29.431199, 29.431199, 25.436149, … ## $ mod_pwr_est_dbh_cm &lt;dbl&gt; 25.97342, 28.90742, 28.90742, 26.37333, 32.2… ## $ mod_weib_est_dbh_cm &lt;dbl&gt; 26.34391, 29.90921, 29.90921, 26.90339, 33.3… ## $ mod_rf_est_dbh_cm &lt;dbl&gt; 25.89944, 26.18041, 27.98203, 27.92877, 30.5… ## $ reg_est_dbh_in &lt;dbl&gt; 9.022792, 10.183815, 10.183815, 9.232003, 11… ## $ reg_est_lower_dbh_in &lt;dbl&gt; 5.663054, 6.261423, 6.261423, 5.744058, 7.13… ## $ reg_est_upper_dbh_in &lt;dbl&gt; 13.022331, 14.841863, 14.841863, 13.424235, … ## $ dbh_in &lt;dbl&gt; 10.394363, 11.602978, 11.602978, 10.526833, … ## $ mod_lin_est_dbh_in &lt;dbl&gt; 10.394363, 11.602978, 11.602978, 10.526833, … ## $ mod_quad_est_dbh_in &lt;dbl&gt; 10.220465, 11.458085, 11.458085, 10.461122, … ## $ mod_quad_noint_est_dbh_in &lt;dbl&gt; 9.753881, 11.595892, 11.595892, 10.021843, 1… ## $ mod_pwr_est_dbh_in &lt;dbl&gt; 10.233528, 11.389524, 11.389524, 10.391090, … ## $ mod_weib_est_dbh_in &lt;dbl&gt; 10.379500, 11.784227, 11.784227, 10.599935, … ## $ mod_rf_est_dbh_in &lt;dbl&gt; 10.204379, 10.315081, 11.024918, 11.003937, … ## $ tree_height_ft &lt;dbl&gt; 41.98728, 46.40216, 46.33000, 42.52520, 50.9… ## $ comp_dist_to_nearest_ft &lt;dbl&gt; 12.327303, 12.835030, 9.908098, 9.908098, 11… ## $ mean_crown_ht_ft &lt;dbl&gt; 34.13251, 42.92109, 36.90231, 33.69591, 42.4… ## $ median_crown_ht_ft &lt;dbl&gt; 34.03765, 42.54488, 36.13576, 34.03656, 42.7… ## $ min_crown_ht_ft &lt;dbl&gt; 20.28352, 39.65848, 22.68448, 4.50016, 33.68… ## $ dbh_ft &lt;dbl&gt; 0.8653175, 0.9659332, 0.9659332, 0.8763455, … ## $ radius_ft &lt;dbl&gt; 0.4326588, 0.4829666, 0.4829666, 0.4381727, … ## $ comp_trees_per_ac &lt;dbl&gt; 103.17954, 103.17954, 257.94886, 154.76931, … ## $ crown_area_ft2 &lt;dbl&gt; 116.38575, 34.31025, 89.47575, 113.02200, 10… ## $ basal_area_ft2 &lt;dbl&gt; 0.5883922, 0.7331791, 0.7331791, 0.6034851, … ## $ geom &lt;POINT [m]&gt; POINT (610728.4 4889078), POINT (61074… ## $ X &lt;dbl&gt; 610728.4, 610747.6, 610728.1, 610725.4, 6107… ## $ Y &lt;dbl&gt; 4889078, 4889076, 4889074, 4889073, 4889073,… ## $ dbscan_cluster &lt;fct&gt; 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,… ## $ clump_n_trees &lt;int&gt; 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, … ## $ clump_n_trees_grp &lt;ord&gt; &gt;15 trees, &gt;15 trees, &gt;15 trees, &gt;15 trees, … ## $ distance_clump_nn_m &lt;dbl&gt; 3.758324, 3.913119, 3.020761, 3.020761, 3.50… ## $ tree_clump_dist_m &lt;dbl&gt; 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,… ## $ is_keep_tree &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1,… "],["plot-it.html", "Section 10 plot it", " Section 10 plot it ggplot() + geom_sf(data = harvests %&gt;% dplyr::filter(suid == my_suid), fill = NA, color = &quot;black&quot;) + geom_sf( data = clump_polys_temp %&gt;% dplyr::filter(clump_n_trees_grp == &quot;&gt;15 trees&quot;) , mapping = aes(fill = clump_id) , color = NA , show.legend = F ) + scale_fill_manual( values = viridis::mako( clump_polys_temp %&gt;% dplyr::filter(clump_n_trees_grp == &quot;&gt;15 trees&quot;) %&gt;% dplyr::pull(clump_id) %&gt;% unique() %&gt;% length() ) %&gt;% sample() ) + # tree points geom_sf(data = cut_grp_ex_temp, mapping = aes(color = as.factor(is_keep_tree)), size = 0.5) + scale_color_manual(values = c(&quot;firebrick&quot;, &quot;gold&quot;)) + labs(color = &quot;is keep tree?&quot;) + theme_void() + guides(color = guide_legend(override.aes = list(size = 5))) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
