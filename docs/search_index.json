[["index.html", "Black Hills Experimental Forest UAS Mission Data Summary Section 1 Introduction", " Black Hills Experimental Forest UAS Mission Data Summary George Woolsey 13 February, 2024 Section 1 Introduction This project summarizes processed point cloud data created using structure from motion (SfM) photogrammetry methods on imagery collected from Unmanned Aircraft System (UAS) flights completed in June 2023. UAS imagery was collected using a DJI Phantom 4 Pro equipped with a 20 megapixel metal oxide semiconductor red-green-blue camera at a fixed 8.8 mm focal length. Flights followed a pre-programmed serpentine flight paths at an altitude of 120 m above ground level, using a nadir camera orientation, with 80% forward and side image overlap.The UAV imagery was processed in Agisoft Metashape using the routine outlined by Tinkham and Swayze (2021) to produce an SfM point cloud for optimized tree detection. The SfM-derived point cloud was processed using the methods outlined by Swayze and Tinkham (2022). Specifically, this script which is outlined in detail at its parent Github repository was used to process the raw point cloud data. UAS point cloud files (laz files) for this project were processed in two batches with the outputs combined using this script from the same repository. SfM techniques using UAS data reliably identify most tree locations and heights in open-canopied forests. However, their ability to characterize diameter at breast height (DBH) is limited to estimates of a fraction of trees within the area. SfM-derived DBH was estimated at the tree level following the methods outlined by Tinkham et al. (2022). "],["objective.html", "Section 2 Objective", " Section 2 Objective The objective of this analysis is to summarize forest stand characteristics using the UAS-derived tree list which includes tree location, height, and DBH measurements. Forest stands in this analysis include stands which were harvested in 2021 using single-tree and group-selection silvicultural prescriptions. The Forest Activity Tracking System (FACTS) database maintained by the U.S. Department of Agriculture, Forest Service (USFS) was used to delineate georeferenced boundaries of forest harvest activities. "],["data_prep.html", "Section 3 Data Preparation 3.1 Data Load 3.2 Load orthomosaic rasters", " Section 3 Data Preparation 3.1 Data Load Data loaded includes outputs from the UAS point cloud processing script: raw_las_ctg_info.gpkg, final_detected_crowns.gpkg, final_detected_tree_tops.gpkg. Also, loaded are experimental forest boundaries and timber harvest boundaries from the USFS FACTS database. # where is the processed data from point_cloud_processing_run_combine.R ? input_dir = &quot;../data/point_cloud_processing_BHEF_202306_combined&quot; # set output directory delivery_dir = &quot;../data/delivery&quot; dir.create(delivery_dir, showWarnings = FALSE) ### read data from point_cloud_processing #rasters dtm_rast = terra::rast(paste0(input_dir, &quot;/dtm_1m.tif&quot;)) chm_rast = terra::rast(paste0(input_dir, &quot;/chm_0.25m.tif&quot;)) # crowns = terra::rast(paste0(input_dir, &quot;/top_down_detected_tree_crowns.tif&quot;)) # las extent las_ctg_dta = sf::st_read(paste0(input_dir, &quot;/raw_las_ctg_info.gpkg&quot;)) # vectors # crown polygons crowns_sf_with_dbh = sf::st_read(paste0(input_dir, &quot;/final_detected_crowns.gpkg&quot;)) %&gt;% dplyr::select(-c(basal_area_ft2)) %&gt;% dplyr::rename( reg_est_lower_dbh_cm = reg_est_dbh_cm_lower , reg_est_upper_dbh_cm = reg_est_dbh_cm_upper ) # tree top points treetops_sf_with_dbh = sf::st_read(paste0(input_dir, &quot;/final_detected_tree_tops.gpkg&quot;)) %&gt;% dplyr::select(-c(basal_area_ft2)) %&gt;% dplyr::rename( reg_est_lower_dbh_cm = reg_est_dbh_cm_lower , reg_est_upper_dbh_cm = reg_est_dbh_cm_upper ) # height range for use in estimation height_range = dplyr::tibble( tree_height_m = seq( from = 0 , to = round(max(treetops_sf_with_dbh$tree_height_m)*1.05,0) , by = 0.1 # by 0.1 m increments ) ) # set crs proj_crs = sf::st_crs(las_ctg_dta) # read data from FACTS # harvests harvests = sf::st_read(&quot;../data/bhef_harvests.gpkg&quot;) %&gt;% dplyr::filter( year_id == 2021 # year_id &gt;= year(Sys.time()) - 15 &amp; !(treatment_type_grp %in% c(&quot;Improvement/Liberation Cut&quot;, &quot;Other&quot;, &quot;Sanitation Cut&quot;)) ) %&gt;% sf::st_transform(proj_crs) # bhef bounds bhef_boundary = sf::st_read(&quot;../data/bhef_boundary.gpkg&quot;) %&gt;% sf::st_transform(proj_crs) Define a function to convert columns in data frame from metric to imperial calc_imperial_units_fn &lt;- function(df) { df %&gt;% # convert to imperial units dplyr::mutate( dplyr::across( .cols = tidyselect::ends_with(&quot;_cm&quot;) , ~ .x * 0.394 , .names = &quot;{.col}_in&quot; ) , dplyr::across( .cols = tidyselect::ends_with(&quot;_m&quot;) , ~ .x * 3.28 , .names = &quot;{.col}_ft&quot; ) , dplyr::across( .cols = tidyselect::ends_with(&quot;_m2_per_ha&quot;) , ~ .x * 4.359 , .names = &quot;{.col}_ftac&quot; ) , dplyr::across( .cols = tidyselect::ends_with(&quot;_per_ha&quot;) &amp; !tidyselect::ends_with(&quot;_m2_per_ha&quot;) , ~ .x * 0.405 , .names = &quot;{.col}_ac&quot; ) , dplyr::across( .cols = tidyselect::ends_with(&quot;_area_ha&quot;) , ~ .x * 2.471 , .names = &quot;{.col}_ac&quot; ) , dplyr::across( .cols = tidyselect::ends_with(&quot;_m2&quot;) , ~ .x * 10.764 , .names = &quot;{.col}_ft2&quot; ) ) %&gt;% dplyr::rename_with( .fn = function(x){dplyr::case_when( stringr::str_ends(x,&quot;_cm_in&quot;) ~ stringr::str_replace(x,&quot;_cm_in&quot;,&quot;_in&quot;) , stringr::str_ends(x,&quot;_m_ft&quot;) ~ stringr::str_replace(x,&quot;_m_ft&quot;,&quot;_ft&quot;) , stringr::str_ends(x,&quot;_m2_per_ha_ftac&quot;) ~ stringr::str_replace(x,&quot;_m2_per_ha_ftac&quot;,&quot;_ft2_per_ac&quot;) , stringr::str_ends(x,&quot;_per_ha_ac&quot;) ~ stringr::str_replace(x,&quot;_per_ha_ac&quot;,&quot;_per_ac&quot;) , stringr::str_ends(x,&quot;_area_ha_ac&quot;) ~ stringr::str_replace(x,&quot;_area_ha_ac&quot;,&quot;_area_ac&quot;) , stringr::str_ends(x,&quot;_m2_ft2&quot;) ~ stringr::str_replace(x,&quot;_m2_ft2&quot;,&quot;_ft2&quot;) , TRUE ~ x )} ) } 3.2 Load orthomosaic rasters Orthomosaic tif files from the UAS flight imagery that were created in Agisoft Metashape are loaded and stitched together via terra::mosaic. if(!file.exists(paste0(delivery_dir,&quot;/BHEF_202306_Full_RBG.tif&quot;))){ # read list of orthos ortho_list_temp = list.files(&quot;../data/ortho/&quot;, pattern = &quot;.*\\\\.(tif|tiff)$&quot;, full.names = T)[] %&gt;% purrr::map(function(x){terra::rast(x)}) # ortho_list_temp[[1]] %&gt;% # terra::aggregate(20) %&gt;% # terra::plotRGB(r = 1, g = 2, b = 3, stretch = &quot;hist&quot;, colNA = &quot;transparent&quot;) ####### ensure the resolution of the rasters matches # terra::res(ortho_list_temp[[1]]) ## function change_res_fn = function(r, my_res=1){ r2 = r terra::res(r2) = my_res r2 = terra::resample(r, r2) return(r2) } ## apply the function ortho_list_temp = 1:length(ortho_list_temp) %&gt;% purrr::map(function(x){change_res_fn(ortho_list_temp[[x]], my_res=0.5)}) # terra::res(ortho_list_temp[[1]]) # ortho_list_temp[[1]] %&gt;% # terra::aggregate(2) %&gt;% # terra::plotRGB(r = 1, g = 2, b = 3, stretch = &quot;hist&quot;, colNA = &quot;transparent&quot;) ######## mosaic the raster list ortho_rast = terra::mosaic( terra::sprc(ortho_list_temp) , fun = &quot;min&quot; # min only thing that works ) ## write the mosaic terra::writeRaster(ortho_rast, filename = paste0(delivery_dir,&quot;/BHEF_202306_Full_RBG.tif&quot;), overwrite = T) }else{ ortho_rast = terra::rast(paste0(delivery_dir,&quot;/BHEF_202306_Full_RBG.tif&quot;)) } # ortho_rast %&gt;% # terra::aggregate(4) %&gt;% # terra::plotRGB(r = 1, g = 2, b = 3, stretch = &quot;lin&quot;, colNA = &quot;transparent&quot;) "],["local_mod.html", "Section 4 Local DBH to Height Model 4.1 Random Forest Model 4.2 Linear Model 4.3 Quadratic Model 4.4 No Intercept Quadratic Model 4.5 Nonlinear Power Model 4.6 Nonlinear Weibull Model 4.7 Model Comparison 4.8 Update DBH to best model 4.9 Combine harvest units with tree locations", " Section 4 Local DBH to Height Model 4.1 Random Forest Model The UAS point cloud processing script used a random forest model to estimate tree DBH based on the sample of DBH values extracted from the point cloud (outlined in detail here. This random forest model included tree height (m), crown area (m2), minimum crown height (m), and local tree competition metrics to estimate missing DBH values. Using methods outlined by Tinkham et al. (2022), local competition metrics included the distance to the nearest neighbor, trees ha1 within a 5 m radius, and the relative tree height within a 5 m radius. A 5 m radius was selected as it represents a distance slightly less than the point at which two mature ponderosa pine trees in the region would begin to have interlocking crowns, representing a proxy for direct competition. The relative tree height within a 5 m radius was estimated using: \\[ \\textrm{Relative Height} = \\frac{\\textrm{Height}}{\\textrm{Height}_\\textrm{max}} \\times 100 \\] , where \\(\\textrm{Height}\\) is the height of the subject tree and \\(\\textrm{Height}_\\textrm{max}\\) is the height of the tallest tree within a 5 m radius of the subject tree. 4.1.1 Training vs Non-Training DBH ### plot plt_rf = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) %&gt;% dplyr::bind_rows( treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==F) %&gt;% dplyr::slice_sample(prop = 0.15) ) %&gt;% ggplot( mapping = aes( x=tree_height_m, y = dbh_cm , color = is_training_data , fill = is_training_data , group = is_training_data ) ) + geom_point( alpha = 0.6 , size = 0.7 , color = &quot;transparent&quot; , shape = 21 , show.legend = F ) + geom_smooth( method = &quot;loess&quot; , se = F , span = 1 , lwd = 1.5 , show.legend = T ) + scale_color_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_fill_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_y_continuous(limits = c(0,max(treetops_sf_with_dbh$dbh_cm)*1.02)) + scale_x_continuous(limits = c(0,max(treetops_sf_with_dbh$tree_height_m)*1.02)) + labs( y = &quot;DBH (cm)&quot; , x = &quot;Tree Ht. (m)&quot; , title = &quot;Random Forest Model&quot; , subtitle = &quot;SfM-derived tree height and DBH relationship&quot; , color = &quot;Training Data&quot; , fill = &quot;Training Data&quot; ) + theme_light() + theme( legend.position = &quot;bottom&quot; , legend.direction = &quot;horizontal&quot; ) + guides( color = guide_legend(override.aes = list(shape = 15, lwd = 6, size = 6, alpha = 1)) ) # plot plt_rf 4.2 Linear Model Tinkham et al. (2022) found the simple linear form resulted in the best estimates for both tree and stand level summarizations: \\[\\begin{align*} DBH_{i} &amp;\\sim {\\sf Gamma} \\bigl(g(\\beta_0, \\beta_1, Height_{i}), shape \\bigr) \\\\ g(\\beta_0, \\beta_1, Height_{i}) &amp;= {\\exp \\bigl(\\beta_0 + \\beta_1 \\cdot Height_{i}\\bigr)} \\\\ \\beta_{0} &amp;\\sim {\\sf Normal} (0,10) \\\\ \\beta_{1} &amp;\\sim {\\sf Normal} (0,10) \\\\ shape &amp;\\sim {\\sf Gamma} (0.01,0.01) \\end{align*}\\] , where \\(i\\) is the individual tree estimate from UAS SfM data. The \\(\\sf Gamma\\) response distribution represents \\(DBH_{i}\\) as strictly non-negative. # population model with no random effects (i.e. no group-level variation) # Gamma distribution for strictly positive response variable dbh mod_lin = brms::brm( formula = dbh_cm ~ 1 + tree_height_m , data = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) , family = brms::brmsfamily(&quot;Gamma&quot;, link = &quot;identity&quot;) , prior = c(prior(gamma(0.01, 0.01), class = shape)) , iter = 3000 , file = &quot;../data/mod_lin&quot; ) # plot(mod_lin) # summary(mod_lin) # plot(brms::conditional_effects(mod_lin), points = T) # compute and save the WAIC information for the next three models mod_lin = brms::add_criterion(mod_lin, c(&quot;loo&quot;, &quot;waic&quot;)) # predict values over range pred_mod_lin = predict( mod_lin , newdata = height_range , probs = c(.05, .95) ) %&gt;% dplyr::as_tibble() %&gt;% dplyr::rename( lower_b = 3, upper_b = 4 ) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::select(-c(est.error)) %&gt;% dplyr::bind_cols(height_range) %&gt;% dplyr::mutate(tree_height_m_tnth = round(tree_height_m,1) %&gt;% as.character()) # attach predicted values to original data treetops_sf_with_dbh = treetops_sf_with_dbh %&gt;% dplyr::mutate(tree_height_m_tnth = round(tree_height_m,1) %&gt;% as.character()) %&gt;% dplyr::left_join( pred_mod_lin %&gt;% dplyr::select(tree_height_m_tnth, estimate) , by = dplyr::join_by(tree_height_m_tnth) ) %&gt;% dplyr::mutate( mod_lin_est_dbh_cm = ifelse(is_training_data == T, dbh_cm, estimate) ) %&gt;% dplyr::select(-c(estimate, tree_height_m_tnth)) gc() 4.2.1 Model Parameter Estimates Simple linear form: \\[ DBH_i = \\beta_0 + \\beta_1 \\cdot Height_i \\] , where \\(i\\) is the individual tree estimate from UAS SfM data # parameter estimates mod_lin_sum_temp = brms::posterior_summary(mod_lin) %&gt;% as.data.frame() %&gt;% tibble::rownames_to_column(var = &quot;parameter&quot;) %&gt;% dplyr::filter(stringr::str_starts(parameter, &quot;b_&quot;)) %&gt;% # | parameter == &quot;shape&quot;) %&gt;% dplyr::rename_with(tolower) # table mod_lin_sum_temp %&gt;% kableExtra::kbl(digits = 4) %&gt;% kableExtra::kable_styling() parameter estimate est.error q2.5 q97.5 b_Intercept -4.3633 0.4390 -5.2251 -3.5021 b_tree_height_m 2.4009 0.0308 2.3406 2.4615 4.2.2 SfM-derived Height to DBH Allometry # plot predictions with data ggplot( data = pred_mod_lin, mapping = aes(x = tree_height_m) ) + geom_point( data = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) , mapping = aes(y = dbh_cm) , color = &quot;firebrick&quot; ) + geom_ribbon( mapping = aes(ymin = lower_b, ymax = upper_b) , fill = &quot;gray88&quot; , alpha = 0.5 ) + geom_line( aes(y = estimate) , color = &quot;gray33&quot; , lwd = 1 ) + labs( y = &quot;DBH (cm)&quot; , x = &quot;Tree Ht. (m)&quot; , title = &quot;Local height to DBH allometry from SfM-extracted DBH samples&quot; , subtitle = latex2exp::TeX(paste0( &quot;$DBH = &quot; , mod_lin_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_Intercept&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot; + &quot; , mod_lin_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_tree_height_m&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height&quot; )) ) + theme_light() + theme(legend.position = &quot;none&quot;) 4.2.3 Training vs Non-Training DBH ### plot plt_lin = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) %&gt;% dplyr::bind_rows( treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==F) %&gt;% dplyr::slice_sample(prop = 0.15) ) %&gt;% ggplot( mapping = aes( x=tree_height_m, y = mod_lin_est_dbh_cm , color = is_training_data , fill = is_training_data , group = is_training_data ) ) + geom_smooth( method = &quot;loess&quot; , se = F , span = 1 , lwd = 1.5 , show.legend = T ) + geom_point( alpha = 0.6 , size = 0.7 , color = &quot;transparent&quot; , shape = 21 , show.legend = F ) + annotate( &quot;text&quot;, x = 0, y = max(treetops_sf_with_dbh$dbh_cm) , label = latex2exp::TeX(paste0( &quot;$DBH = &quot; , mod_lin_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_Intercept&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot; + &quot; , mod_lin_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_tree_height_m&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height&quot; )) , parse = T , hjust = 0 ) + scale_color_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_fill_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_y_continuous(limits = c(0,max(treetops_sf_with_dbh$dbh_cm)*1.02)) + scale_x_continuous(limits = c(0,max(treetops_sf_with_dbh$tree_height_m)*1.02)) + labs( y = &quot;DBH (cm)&quot; , x = &quot;Tree Ht. (m)&quot; , title = &quot;Linear Model&quot; , subtitle = &quot;SfM-derived tree height and DBH relationship&quot; , color = &quot;Training Data&quot; , fill = &quot;Training Data&quot; ) + theme_light() + theme( legend.position = &quot;bottom&quot; , legend.direction = &quot;horizontal&quot; ) + guides( color = guide_legend(override.aes = list(shape = 15, lwd = 6, size = 6, alpha = 1)) ) # plot plt_lin 4.3 Quadratic Model A quadratic linear model with the inclusion of \\(Height_{i}^{2}\\) in the model allows us to account for a nonlinear (e.g. parabolic) relationship between DBH and tree height. \\[\\begin{align*} DBH_{i} &amp;\\sim {\\sf Gamma} \\bigl(g(\\beta_0, \\beta_1, \\beta_2, Height_{i}), shape \\bigr) \\\\ g(\\beta_0, \\beta_1, \\beta_2, Height_{i}) &amp;= {\\exp \\bigl(\\beta_0 + \\beta_1 \\cdot Height_{i} + \\beta_2 \\cdot Height_{i}^{2}\\bigr)} \\\\ \\beta_{0} &amp;\\sim {\\sf Normal} (0,10) \\\\ \\beta_{1} &amp;\\sim {\\sf Normal} (0,10) \\\\ \\beta_{2} &amp;\\sim {\\sf Normal} (0,10) \\\\ shape &amp;\\sim {\\sf Gamma} (0.01,0.01) \\end{align*}\\] , where \\(i\\) is the individual tree estimate from UAS SfM data. The \\(\\sf Gamma\\) response distribution represents \\(DBH_{i}\\) as strictly non-negative. # population model with no random effects (i.e. no group-level variation) # Gamma distribution for strictly positive response variable dbh mod_quad = brms::brm( formula = dbh_cm ~ 1 + tree_height_m + I(tree_height_m^2) , data = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) , family = brms::brmsfamily(&quot;Gamma&quot;, link = &quot;log&quot;) , prior = c(prior(gamma(0.01, 0.01), class = shape)) , iter = 3000 , file = &quot;../data/mod_quad&quot; ) # plot(mod_quad) # summary(mod_quad) # plot(brms::conditional_effects(mod_quad), points = T) # compute and save the WAIC information for the next three models mod_quad = brms::add_criterion(mod_quad, c(&quot;loo&quot;, &quot;waic&quot;)) # predict values over range pred_mod_quad = predict( mod_quad , newdata = height_range , probs = c(.05, .95) ) %&gt;% dplyr::as_tibble() %&gt;% dplyr::rename( lower_b = 3, upper_b = 4 ) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::select(-c(est.error)) %&gt;% dplyr::bind_cols(height_range) %&gt;% dplyr::mutate(tree_height_m_tnth = round(tree_height_m,1) %&gt;% as.character()) # attach predicted values to original data treetops_sf_with_dbh = treetops_sf_with_dbh %&gt;% dplyr::mutate(tree_height_m_tnth = round(tree_height_m,1) %&gt;% as.character()) %&gt;% dplyr::left_join( pred_mod_quad %&gt;% dplyr::select(tree_height_m_tnth, estimate) , by = dplyr::join_by(tree_height_m_tnth) ) %&gt;% dplyr::mutate( mod_quad_est_dbh_cm = ifelse(is_training_data == T, dbh_cm, estimate) ) %&gt;% dplyr::select(-c(estimate, tree_height_m_tnth)) gc() 4.3.1 Model Parameter Estimates Quadratic linear model form: \\[ DBH_{i} = \\exp\\bigl(\\beta_0 + \\beta_1 \\cdot Height_{i} + \\beta_2 \\cdot Height_{i}^{2} \\bigr) \\] , where \\(i\\) is the individual tree estimate from UAS SfM data # parameter estimates mod_quad_sum_temp = brms::posterior_summary(mod_quad) %&gt;% as.data.frame() %&gt;% tibble::rownames_to_column(var = &quot;parameter&quot;) %&gt;% dplyr::filter(stringr::str_starts(parameter, &quot;b_&quot;)) %&gt;% # | parameter == &quot;shape&quot;) %&gt;% dplyr::rename_with(tolower) # dplyr::mutate( # dplyr::across(.cols = tidyselect::where(is.numeric), .fns = exp) # ) # table mod_quad_sum_temp %&gt;% kableExtra::kbl(digits = 4) %&gt;% kableExtra::kable_styling() parameter estimate est.error q2.5 q97.5 b_Intercept 1.5319 0.0520 1.4276 1.6344 b_tree_height_m 0.1724 0.0063 0.1602 0.1846 b_Itree_height_mE2 -0.0030 0.0002 -0.0033 -0.0026 4.3.2 SfM-derived Height to DBH Allometry # predict and put estimates in a data frame predict( mod_quad , newdata = height_range , probs = c(.05, .95) ) %&gt;% dplyr::as_tibble() %&gt;% dplyr::rename( lower_b = 3, upper_b = 4 ) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::select(-c(est.error)) %&gt;% dplyr::bind_cols(height_range) %&gt;% # plot predictions with data ggplot( mapping = aes(x = tree_height_m) ) + geom_point( data = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) , mapping = aes(y = dbh_cm) , color = &quot;firebrick&quot; ) + geom_ribbon( mapping = aes(ymin = lower_b, ymax = upper_b) , fill = &quot;gray88&quot; , alpha = 0.5 ) + geom_line( aes(y = estimate) , color = &quot;gray33&quot; , lwd = 1 ) + labs( y = &quot;DBH (cm)&quot; , x = &quot;Tree Ht. (m)&quot; , title = &quot;Local height to DBH allometry from SfM-extracted DBH samples&quot; , subtitle = latex2exp::TeX(paste0( &quot;$DBH = \\\\exp(&quot; , mod_quad_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_Intercept&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot; + &quot; , mod_quad_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_tree_height_m&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height&quot; , &quot; + &quot; , mod_quad_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_Itree_height_mE2&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height^2)$&quot; )) ) + theme_light() + theme(legend.position = &quot;none&quot;) 4.3.3 Training vs Non-Training DBH ### plot plt_quad = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) %&gt;% dplyr::bind_rows( treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==F) %&gt;% dplyr::slice_sample(prop = 0.15) ) %&gt;% ggplot( mapping = aes( x=tree_height_m, y = mod_quad_est_dbh_cm , color = is_training_data , fill = is_training_data , group = is_training_data ) ) + geom_smooth( method = &quot;loess&quot; , se = F , span = 1 , lwd = 1.5 , show.legend = T ) + geom_point( alpha = 0.6 , size = 0.7 , color = &quot;transparent&quot; , shape = 21 , show.legend = F ) + annotate( &quot;text&quot;, x = 0, y = max(treetops_sf_with_dbh$dbh_cm) , label = latex2exp::TeX(paste0( &quot;$DBH = \\\\exp(&quot; , mod_quad_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_Intercept&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot; + &quot; , mod_quad_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_tree_height_m&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height&quot; , &quot; + &quot; , mod_quad_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_Itree_height_mE2&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height^2)$&quot; )) , parse = T , hjust = 0 ) + scale_color_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_fill_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_y_continuous(limits = c(0,max(treetops_sf_with_dbh$dbh_cm)*1.02)) + scale_x_continuous(limits = c(0,max(treetops_sf_with_dbh$tree_height_m)*1.02)) + labs( y = &quot;DBH (cm)&quot; , x = &quot;Tree Ht. (m)&quot; , title = &quot;Quadratic Model&quot; , subtitle = &quot;SfM-derived tree height and DBH relationship&quot; , color = &quot;Training Data&quot; , fill = &quot;Training Data&quot; ) + theme_light() + theme( legend.position = &quot;bottom&quot; , legend.direction = &quot;horizontal&quot; ) + guides( color = guide_legend(override.aes = list(shape = 15, lwd = 6, size = 6, alpha = 1)) ) # plot plt_quad 4.4 No Intercept Quadratic Model A quadratic linear model with the inclusion of \\(Height_{i}^{2}\\) in the model allows us to account for a nonlinear (e.g. parabolic) relationship between DBH and tree height. Forcing the intercept to \\(0\\) allows for the model to better account for the minimum tree height threshold set at 2 m in the point cloud processing workflow. \\[\\begin{align*} DBH_{i} &amp;\\sim {\\sf Gamma} \\bigl(g(\\beta_1, \\beta_2, Height_{i}), shape \\bigr) \\\\ g(\\beta_1, \\beta_2, Height_{i}) &amp;= {\\exp \\bigl(0 + \\beta_1 \\cdot Height_{i} + \\beta_2 \\cdot Height_{i}^{2}\\bigr)} \\\\ \\beta_{1} &amp;\\sim {\\sf Normal} (0,10) \\\\ \\beta_{2} &amp;\\sim {\\sf Normal} (0,10) \\\\ shape &amp;\\sim {\\sf Gamma} (0.01,0.01) \\end{align*}\\] , where \\(i\\) is the individual tree estimate from UAS SfM data. The \\(\\sf Gamma\\) response distribution represents \\(DBH_{i}\\) as strictly non-negative. # population model with no random effects (i.e. no group-level variation) # Gamma distribution for strictly positive response variable dbh mod_quad_noint = brms::brm( formula = dbh_cm ~ 0 + tree_height_m + I(tree_height_m^2) , data = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) , family = brms::brmsfamily(&quot;Gamma&quot;, link = &quot;log&quot;) , prior = c(prior(gamma(0.01, 0.01), class = shape)) , iter = 3000 , file = &quot;../data/mod_quad_noint&quot; ) # plot(mod_quad_noint) # summary(mod_quad_noint) # plot(brms::conditional_effects(mod_quad_noint), points = T) # compute and save the WAIC information for the next three models mod_quad_noint = brms::add_criterion(mod_quad_noint, c(&quot;loo&quot;, &quot;waic&quot;)) # predict values over range pred_mod_quad_noint = predict( mod_quad_noint , newdata = height_range , probs = c(.05, .95) ) %&gt;% dplyr::as_tibble() %&gt;% dplyr::rename( lower_b = 3, upper_b = 4 ) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::select(-c(est.error)) %&gt;% dplyr::bind_cols(height_range) %&gt;% dplyr::mutate(tree_height_m_tnth = round(tree_height_m,1) %&gt;% as.character()) # attach predicted values to original data treetops_sf_with_dbh = treetops_sf_with_dbh %&gt;% dplyr::mutate(tree_height_m_tnth = round(tree_height_m,1) %&gt;% as.character()) %&gt;% dplyr::left_join( pred_mod_quad_noint %&gt;% dplyr::select(tree_height_m_tnth, estimate) , by = dplyr::join_by(tree_height_m_tnth) ) %&gt;% dplyr::mutate( mod_quad_noint_est_dbh_cm = ifelse(is_training_data == T, dbh_cm, estimate) ) %&gt;% dplyr::select(-c(estimate, tree_height_m_tnth)) gc() 4.4.1 Model Parameter Estimates No intercept quadratic linear model form: \\[ DBH_{i} = \\exp\\bigl( 0 + \\beta_1 \\cdot Height_{i} + \\beta_2 \\cdot Height_{i}^{2} \\bigr) \\] , where \\(i\\) is the individual tree estimate from UAS SfM data # parameter estimates mod_quad_noint_sum_temp = brms::posterior_summary(mod_quad_noint) %&gt;% as.data.frame() %&gt;% tibble::rownames_to_column(var = &quot;parameter&quot;) %&gt;% dplyr::filter(stringr::str_starts(parameter, &quot;b_&quot;)) %&gt;% # | parameter == &quot;shape&quot;) %&gt;% dplyr::rename_with(tolower) # dplyr::mutate( # dplyr::across(.cols = tidyselect::where(is.numeric), .fns = exp) # ) # table mod_quad_noint_sum_temp %&gt;% kableExtra::kbl(digits = 4) %&gt;% kableExtra::kable_styling() parameter estimate est.error q2.5 q97.5 b_tree_height_m 0.3545 0.0012 0.3521 0.3569 b_Itree_height_mE2 -0.0081 0.0001 -0.0083 -0.0080 4.4.2 SfM-derived Height to DBH Allometry # predict and put estimates in a data frame predict( mod_quad_noint , newdata = height_range , probs = c(.05, .95) ) %&gt;% dplyr::as_tibble() %&gt;% dplyr::rename( lower_b = 3, upper_b = 4 ) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::select(-c(est.error)) %&gt;% dplyr::bind_cols(height_range) %&gt;% # plot predictions with data ggplot( mapping = aes(x = tree_height_m) ) + geom_point( data = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) , mapping = aes(y = dbh_cm) , color = &quot;firebrick&quot; ) + geom_ribbon( mapping = aes(ymin = lower_b, ymax = upper_b) , fill = &quot;gray88&quot; , alpha = 0.5 ) + geom_line( aes(y = estimate) , color = &quot;gray33&quot; , lwd = 1 ) + labs( y = &quot;DBH (cm)&quot; , x = &quot;Tree Ht. (m)&quot; , title = &quot;Local height to DBH allometry from SfM-extracted DBH samples&quot; , subtitle = latex2exp::TeX(paste0( &quot;$DBH = \\\\exp(0&quot; , &quot; + &quot; , mod_quad_noint_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_tree_height_m&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height&quot; , &quot; + &quot; , mod_quad_noint_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_Itree_height_mE2&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height^2)$&quot; )) ) + theme_light() + theme(legend.position = &quot;none&quot;) 4.4.3 Training vs Non-Training DBH ### plot plt_quad_noint = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) %&gt;% dplyr::bind_rows( treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==F) %&gt;% dplyr::slice_sample(prop = 0.15) ) %&gt;% ggplot( mapping = aes( x=tree_height_m, y = mod_quad_noint_est_dbh_cm , color = is_training_data , fill = is_training_data , group = is_training_data ) ) + geom_smooth( method = &quot;loess&quot; , se = F , span = 1 , lwd = 1.5 , show.legend = T ) + geom_point( alpha = 0.6 , size = 0.7 , color = &quot;transparent&quot; , shape = 21 , show.legend = F ) + annotate( &quot;text&quot;, x = 0, y = max(treetops_sf_with_dbh$dbh_cm) , label = latex2exp::TeX(paste0( &quot;$DBH = \\\\exp(0&quot; , &quot; + &quot; , mod_quad_noint_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_tree_height_m&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height&quot; , &quot; + &quot; , mod_quad_noint_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_Itree_height_mE2&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height^2)$&quot; )) , parse = T , hjust = 0 ) + scale_color_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_fill_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_y_continuous(limits = c(0,max(treetops_sf_with_dbh$dbh_cm)*1.02)) + scale_x_continuous(limits = c(0,max(treetops_sf_with_dbh$tree_height_m)*1.02)) + labs( y = &quot;DBH (cm)&quot; , x = &quot;Tree Ht. (m)&quot; , title = &quot;No Intercept Quadratic Model&quot; , subtitle = &quot;SfM-derived tree height and DBH relationship&quot; , color = &quot;Training Data&quot; , fill = &quot;Training Data&quot; ) + theme_light() + theme( legend.position = &quot;bottom&quot; , legend.direction = &quot;horizontal&quot; ) + guides( color = guide_legend(override.aes = list(shape = 15, lwd = 6, size = 6, alpha = 1)) ) # plot plt_quad_noint 4.5 Nonlinear Power Model A power-law function model allows us to account for a nonlinear relationship between DBH and tree height: \\[\\begin{align*} DBH_{i} &amp;\\sim {\\sf Gamma} \\bigl(g(\\alpha, \\kappa, Height_{i}), shape \\bigr) \\\\ g(\\alpha, \\kappa, Height_{i}) &amp;= {\\exp \\bigl(\\alpha \\cdot Height_{i}^{\\kappa}\\bigr)} \\\\ \\alpha &amp;\\sim {\\sf Normal} (0,10) \\\\ \\kappa &amp;\\sim {\\sf Normal} (0,10) \\\\ shape &amp;\\sim {\\sf Gamma} (0.01,0.01) \\end{align*}\\] , where \\(i\\) is the individual tree estimate from UAS SfM data. The \\(\\sf Gamma\\) response distribution represents \\(DBH_{i}\\) as strictly non-negative. # population model with no random effects (i.e. no group-level variation) # Gamma distribution for strictly positive response variable dbh mod_pwr = brms::brm( formula = brms::bf( formula = dbh_cm ~ a * (tree_height_m^k) , a + k ~ 1 , nl = TRUE # !! specify non-linear ) , data = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) , family = brms::brmsfamily(&quot;Gamma&quot;, link = &quot;log&quot;) , prior = c(prior(gamma(0.01, 0.01), class = shape)) , iter = 3000 , file = &quot;../data/mod_pwr&quot; ) # plot(mod_pwr) # summary(mod_pwr) # plot(brms::conditional_effects(mod_pwr), points = T) # compute and save the WAIC information for the next three models mod_pwr = brms::add_criterion(mod_pwr, c(&quot;loo&quot;, &quot;waic&quot;)) # predict values over range pred_mod_pwr = predict( mod_pwr , newdata = height_range , probs = c(.05, .95) ) %&gt;% dplyr::as_tibble() %&gt;% dplyr::rename( lower_b = 3, upper_b = 4 ) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::select(-c(est.error)) %&gt;% dplyr::bind_cols(height_range) %&gt;% dplyr::mutate(tree_height_m_tnth = round(tree_height_m,1) %&gt;% as.character()) # attach predicted values to original data treetops_sf_with_dbh = treetops_sf_with_dbh %&gt;% dplyr::mutate(tree_height_m_tnth = round(tree_height_m,1) %&gt;% as.character()) %&gt;% dplyr::left_join( pred_mod_pwr %&gt;% dplyr::select(tree_height_m_tnth, estimate) , by = dplyr::join_by(tree_height_m_tnth) ) %&gt;% dplyr::mutate( mod_pwr_est_dbh_cm = ifelse(is_training_data == T, dbh_cm, estimate) ) %&gt;% dplyr::select(-c(estimate, tree_height_m_tnth)) gc() 4.5.1 Model Parameter Estimates Power-law function model form: \\[ DBH_{i} = \\exp\\bigl(\\alpha \\cdot Height_{i}^{\\kappa}\\bigr) \\] , where \\(i\\) is the individual tree estimate from UAS SfM data # parameter estimates mod_pwr_sum_temp = brms::posterior_summary(mod_pwr) %&gt;% as.data.frame() %&gt;% tibble::rownames_to_column(var = &quot;parameter&quot;) %&gt;% dplyr::filter(stringr::str_starts(parameter, &quot;b_&quot;)) %&gt;% # | parameter == &quot;shape&quot;) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::mutate( parameter = stringr::str_remove_all(tolower(parameter), &quot;_intercept&quot;) # , dplyr::across(.cols = tidyselect::where(is.numeric), .fns = exp) ) # table mod_pwr_sum_temp %&gt;% kableExtra::kbl(digits = 4) %&gt;% kableExtra::kable_styling() parameter estimate est.error q2.5 q97.5 b_a 1.3752 0.0201 1.3375 1.4161 b_k 0.3386 0.0052 0.3279 0.3485 4.5.2 SfM-derived Height to DBH Allometry # predict and put estimates in a data frame predict( mod_pwr , newdata = height_range , probs = c(.05, .95) ) %&gt;% dplyr::as_tibble() %&gt;% dplyr::rename( lower_b = 3, upper_b = 4 ) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::select(-c(est.error)) %&gt;% dplyr::bind_cols(height_range) %&gt;% # plot predictions with data ggplot( mapping = aes(x = tree_height_m) ) + geom_point( data = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) , mapping = aes(y = dbh_cm) , color = &quot;firebrick&quot; ) + geom_ribbon( mapping = aes(ymin = lower_b, ymax = upper_b) , fill = &quot;gray88&quot; , alpha = 0.5 ) + geom_line( aes(y = estimate) , color = &quot;gray33&quot; , lwd = 1 ) + labs( y = &quot;DBH (cm)&quot; , x = &quot;Tree Ht. (m)&quot; , title = &quot;Local height to DBH allometry from SfM-extracted DBH samples&quot; , subtitle = latex2exp::TeX(paste0( &quot;$DBH = \\\\exp(&quot; , mod_pwr_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_a&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height^{&quot; , mod_pwr_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_k&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;})$&quot; )) ) + theme_light() + theme(legend.position = &quot;none&quot;) 4.5.3 Training vs Non-Training DBH ### plot plt_pwr = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) %&gt;% dplyr::bind_rows( treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==F) %&gt;% dplyr::slice_sample(prop = 0.15) ) %&gt;% ggplot( mapping = aes( x=tree_height_m, y = mod_pwr_est_dbh_cm , color = is_training_data , fill = is_training_data , group = is_training_data ) ) + geom_smooth( method = &quot;loess&quot; , se = F , span = 1 , lwd = 1.5 , show.legend = T ) + geom_point( alpha = 0.6 , size = 0.7 , color = &quot;transparent&quot; , shape = 21 , show.legend = F ) + annotate( &quot;text&quot;, x = 0, y = max(treetops_sf_with_dbh$dbh_cm) , label = latex2exp::TeX(paste0( &quot;$DBH = \\\\exp(&quot; , mod_pwr_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_a&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height^{&quot; , mod_pwr_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_k&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;})$&quot; )) , parse = T , hjust = 0 ) + scale_color_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_fill_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_y_continuous(limits = c(0,max(treetops_sf_with_dbh$dbh_cm)*1.02)) + scale_x_continuous(limits = c(0,max(treetops_sf_with_dbh$tree_height_m)*1.02)) + labs( y = &quot;DBH (cm)&quot; , x = &quot;Tree Ht. (m)&quot; , title = &quot;Nonlinear Power Model&quot; , subtitle = &quot;SfM-derived tree height and DBH relationship&quot; , color = &quot;Training Data&quot; , fill = &quot;Training Data&quot; ) + theme_light() + theme( legend.position = &quot;bottom&quot; , legend.direction = &quot;horizontal&quot; ) + guides( color = guide_legend(override.aes = list(shape = 15, lwd = 6, size = 6, alpha = 1)) ) # plot plt_pwr 4.6 Nonlinear Weibull Model Pilli et al. (2006) suggest a Weibull function for estimating DBH to height allometric relationships to allow for a nonlinear relationship: \\[\\begin{align*} DBH_{i} &amp;\\sim {\\sf Gamma} \\bigl(g(a, b, Height_{i}), shape \\bigr) \\\\ g(a, b, Height_{i}) &amp;= {\\exp\\biggl(a \\cdot \\bigl(1-\\exp(-Height_{i}/b)\\bigr)\\biggr)} \\\\ a &amp;\\sim {\\sf Normal} (0,10) \\\\ b &amp;\\sim {\\sf Normal} (0,10) \\\\ shape &amp;\\sim {\\sf Gamma} (0.01,0.01) \\end{align*}\\] , where \\(i\\) is the individual tree estimate from UAS SfM data. The \\(\\sf Gamma\\) response distribution represents \\(DBH_{i}\\) as strictly non-negative. # population model with no random effects (i.e. no group-level variation) # Gamma distribution for strictly positive response variable dbh # a × (1exp(DBH/b)) mod_weib = brms::brm( formula = brms::bf( formula = dbh_cm ~ a * (1-exp(-tree_height_m/b)) , a + b ~ 1 , nl = TRUE # !! specify non-linear ) , data = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) , family = brms::brmsfamily(&quot;Gamma&quot;, link = &quot;log&quot;) , prior = c(prior(gamma(0.01, 0.01), class = shape)) , iter = 3000 , file = &quot;../data/mod_weib&quot; ) # plot(mod_weib) # summary(mod_weib) # plot(brms::conditional_effects(mod_weib), points = T) # compute and save the WAIC information for the next three models mod_weib = brms::add_criterion(mod_weib, c(&quot;loo&quot;, &quot;waic&quot;)) # predict values over range pred_mod_weib = predict( mod_weib , newdata = height_range , probs = c(.05, .95) ) %&gt;% dplyr::as_tibble() %&gt;% dplyr::rename( lower_b = 3, upper_b = 4 ) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::select(-c(est.error)) %&gt;% dplyr::bind_cols(height_range) %&gt;% dplyr::mutate(tree_height_m_tnth = round(tree_height_m,1) %&gt;% as.character()) # attach predicted values to original data treetops_sf_with_dbh = treetops_sf_with_dbh %&gt;% dplyr::mutate(tree_height_m_tnth = round(tree_height_m,1) %&gt;% as.character()) %&gt;% dplyr::left_join( pred_mod_weib %&gt;% dplyr::select(tree_height_m_tnth, estimate) , by = dplyr::join_by(tree_height_m_tnth) ) %&gt;% dplyr::mutate( mod_weib_est_dbh_cm = ifelse(is_training_data == T, dbh_cm, estimate) ) %&gt;% dplyr::select(-c(estimate, tree_height_m_tnth)) gc() 4.6.1 Model Parameter Estimates Weibull function model form: \\[ DBH_{i} = \\exp\\biggl(a \\cdot \\bigl(1-\\exp(-Height_{i}/b)\\bigr)\\biggr) \\] , where \\(i\\) is the individual tree estimate from UAS SfM data # parameter estimates mod_weib_sum_temp = brms::posterior_summary(mod_weib) %&gt;% as.data.frame() %&gt;% tibble::rownames_to_column(var = &quot;parameter&quot;) %&gt;% dplyr::filter(stringr::str_starts(parameter, &quot;b_&quot;)) %&gt;% # | parameter == &quot;shape&quot;) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::mutate( parameter = stringr::str_remove_all(tolower(parameter), &quot;_intercept&quot;) # , dplyr::across(.cols = tidyselect::where(is.numeric), .fns = exp) ) # table mod_weib_sum_temp %&gt;% kableExtra::kbl(digits = 4) %&gt;% kableExtra::kable_styling() parameter estimate est.error q2.5 q97.5 b_a 4.1161 0.0182 4.0810 4.1528 b_b 8.0801 0.1095 7.8709 8.3011 4.6.2 SfM-derived Height to DBH Allometry # predict and put estimates in a data frame predict( mod_weib , newdata = height_range , probs = c(.05, .95) ) %&gt;% dplyr::as_tibble() %&gt;% dplyr::rename( lower_b = 3, upper_b = 4 ) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::select(-c(est.error)) %&gt;% dplyr::bind_cols(height_range) %&gt;% # plot predictions with data ggplot( mapping = aes(x = tree_height_m) ) + geom_point( data = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) , mapping = aes(y = dbh_cm) , color = &quot;firebrick&quot; ) + geom_ribbon( mapping = aes(ymin = lower_b, ymax = upper_b) , fill = &quot;gray88&quot; , alpha = 0.5 ) + geom_line( aes(y = estimate) , color = &quot;gray33&quot; , lwd = 1 ) + labs( y = &quot;DBH (cm)&quot; , x = &quot;Tree Ht. (m)&quot; , title = &quot;Local height to DBH allometry from SfM-extracted DBH samples&quot; , subtitle = latex2exp::TeX(paste0( &quot;$DBH = \\\\exp(&quot; , mod_weib_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_a&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot (1-\\\\exp(-Height/&quot; , mod_weib_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_b&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;)))$&quot; )) ) + theme_light() + theme(legend.position = &quot;none&quot;) 4.6.3 Training vs Non-Training DBH ### plot plt_weib = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) %&gt;% dplyr::bind_rows( treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==F) %&gt;% dplyr::slice_sample(prop = 0.15) ) %&gt;% ggplot( mapping = aes( x=tree_height_m, y = mod_weib_est_dbh_cm , color = is_training_data , fill = is_training_data , group = is_training_data ) ) + geom_smooth( method = &quot;loess&quot; , se = F , span = 1 , lwd = 1.5 , show.legend = T ) + geom_point( alpha = 0.6 , size = 0.7 , color = &quot;transparent&quot; , shape = 21 , show.legend = F ) + annotate( &quot;text&quot;, x = 0, y = max(treetops_sf_with_dbh$dbh_cm) , label = latex2exp::TeX(paste0( &quot;$DBH = \\\\exp(&quot; , mod_weib_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_a&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot (1-\\\\exp(-Height/&quot; , mod_weib_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_b&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;)))$&quot; )) , parse = T , hjust = 0 ) + scale_color_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_fill_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_y_continuous(limits = c(0,max(treetops_sf_with_dbh$dbh_cm)*1.02)) + scale_x_continuous(limits = c(0,max(treetops_sf_with_dbh$tree_height_m)*1.02)) + labs( y = &quot;DBH (cm)&quot; , x = &quot;Tree Ht. (m)&quot; , title = &quot;Nonlinear Weibull Model&quot; , subtitle = &quot;SfM-derived tree height and DBH relationship&quot; , color = &quot;Training Data&quot; , fill = &quot;Training Data&quot; ) + theme_light() + theme( legend.position = &quot;bottom&quot; , legend.direction = &quot;horizontal&quot; ) + guides( color = guide_legend(override.aes = list(shape = 15, lwd = 6, size = 6, alpha = 1)) ) # plot plt_weib 4.7 Model Comparison The pointwise log-likelihood can be used, among others, to calculate the leave-one-out cross-validation (LOO; Vehtari, Gelman, and Gabry 2015) allowing for comparison of different models applied to the same data (lower LOOs indicate better model fit). brms::loo_compare(mod_lin, mod_quad, mod_quad_noint, mod_pwr, mod_weib, criterion = &quot;loo&quot;) %&gt;% kableExtra::kbl(digits = 3) %&gt;% kableExtra::kable_styling() elpd_diff se_diff elpd_loo se_elpd_loo p_loo se_p_loo looic se_looic mod_quad 0.000 0.000 -9352.399 31.486 3.346 0.153 18704.80 62.973 mod_lin -6.342 4.895 -9358.741 31.475 2.612 0.150 18717.48 62.949 mod_pwr -23.425 6.842 -9375.824 31.575 2.602 0.089 18751.65 63.149 mod_weib -31.029 8.854 -9383.428 31.238 2.855 0.095 18766.86 62.476 mod_quad_noint -413.783 36.282 -9766.183 39.983 5.372 0.983 19532.37 79.967 # # can also check model weights # brms::model_weights(mod_lin, mod_quad, mod_quad_noint, mod_pwr, mod_weib, weights = &quot;loo&quot;) %&gt;% # round(3) Based on these results, the quadratic model \\(DBH_i = \\beta_0 + \\beta_1 \\cdot Height_i + \\beta_2 \\cdot Height_{i}^{2}\\) has the best fit among models tested. DBH estimates based on this model for trees where DBH could not be extracted from the UAS SfM data will be used in the following analysis and stand-level summaries 4.8 Update DBH to best model # update treetops treetops_sf_with_dbh = treetops_sf_with_dbh %&gt;% dplyr::mutate( mod_rf_est_dbh_cm = dbh_cm , dbh_cm = mod_quad_est_dbh_cm , dbh_m = dbh_cm/100 , radius_m = dbh_m/2 , basal_area_m2 = pi * (radius_m)^2 ) %&gt;% # convert to imperial units calc_imperial_units_fn() ########## # update crowns crowns_sf_with_dbh = crowns_sf_with_dbh %&gt;% dplyr::select(-c( dbh_cm , dbh_m , radius_m , basal_area_m2 )) %&gt;% dplyr::inner_join( treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select( treeID , dbh_cm , dbh_m , radius_m , basal_area_m2 , (tidyselect::starts_with(&quot;mod_&quot;) &amp; tidyselect::ends_with(&quot;_cm&quot;)) ) , by = dplyr::join_by(treeID) ) %&gt;% # convert to imperial units calc_imperial_units_fn() ## write data sf::st_write(treetops_sf_with_dbh, paste0(delivery_dir,&quot;/dbh_updated_detected_tree_tops.gpkg&quot;), append = F) sf::st_write(crowns_sf_with_dbh, paste0(delivery_dir,&quot;/dbh_updated_detected_crowns.gpkg&quot;), append = F) 4.9 Combine harvest units with tree locations Spatially combine harvest units with tree locations. One tree can be located in multiple harvest units if the harvest units spatially overlap; Ill allow it. Trees are matched to a harvest unit based on the location of the tree top which may or may not align with the location of the tree bole at DBH. ################################################################################# ################################################################################# # Join tree tops with forest stands ################################################################################# ################################################################################# harvests_trees = harvests %&gt;% dplyr::mutate( stand_area_m2 = sf::st_area(.) %&gt;% as.numeric() , stand_area_ha = stand_area_m2/10000 ) %&gt;% sf::st_intersection(las_ctg_dta) %&gt;% dplyr::mutate( intrsct_stand_area_m2 = sf::st_area(.) %&gt;% as.numeric() ) %&gt;% dplyr::filter(round(intrsct_stand_area_m2, 0) == round(stand_area_m2, 0)) %&gt;% dplyr::select( suid, forest_commonname, admin_region_code, activity_name , treatment_type, treatment_type_grp, date_compl, year_id , stand_area_m2, stand_area_ha ) %&gt;% sf::st_intersection(treetops_sf_with_dbh) # filter harvests harvests = harvests %&gt;% dplyr::filter(suid %in% unique(harvests_trees$suid)) "],["exploratory-analysis.html", "Section 5 Exploratory Analysis 5.1 Study Location Map 5.2 Digital Terrain Model (DTM) Map 5.3 Canopy height model (CHM) Map 5.4 DBH Distribution 5.5 Height Distribution 5.6 Relationship between height and DBH", " Section 5 Exploratory Analysis High-level summaries of the data. 5.1 Study Location Map Map of the BHEF, 2021 harvest boundaries, and 2023-06 UAS flight boundaries. The UAS flights covered 719.9 acres (291.3 ha). There are 6 stands harvested in 2021 that are entirely within the UAS flight boundaries. The harvested stands range in size from 9.6 acres (3.9 ha) to 167.8 acres (67.9 ha). # map mapview::mapview( bhef_boundary , color = &quot;black&quot; , lwd = 3 , alpha.regions = 0 , layer.name = &quot;BHEF&quot; , label = FALSE , legend = FALSE , popup = FALSE ) + mapview::mapview( las_ctg_dta , color = &quot;firebrick&quot; , lwd = 2 , col.regions = c(&quot;firebrick&quot;) , alpha.regions = 0.3 , layer.name = &quot;UAS Flight Boundaries&quot; , label = FALSE , legend = T , popup = FALSE ) + mapview::mapview( harvests , zcol = &quot;treatment_type_grp&quot; , col.regions = viridis::turbo(n=length(unique(harvests$treatment_type_grp))) , alpha.regions = 0.6 , layer.name = &quot;Harvests (2021)&quot; , legend = T , popup = leafpop::popupTable( harvests , zcol = c( &quot;year_id&quot; , &quot;treatment_type_grp&quot; , &quot;activity_name&quot; ) , row.numbers = FALSE , feature.id = FALSE ) ) 5.2 Digital Terrain Model (DTM) Map Map the SfM-derived digital terrain model (DTM) (sometimes called Digital Elevation Models [DEM]) which is a topographic model of the bare Earth containing the elevation data of the terrain. mapview::mapview( bhef_boundary , color = &quot;black&quot; , lwd = 3 , alpha.regions = 0 , layer.name = &quot;BHEF&quot; , label = FALSE , legend = FALSE , popup = FALSE ) + # aggregate raster and map mapview::mapview( dtm_rast %&gt;% terra::aggregate(fact=2) %&gt;% `*`(3.28) %&gt;% # transform to feet stars::st_as_stars() , layer.name = &quot;elev. (ft)&quot; , col.regions = viridis::viridis(n=100) , alpha.regions = 0.7 , na.color = &quot;transparent&quot; ) 5.3 Canopy height model (CHM) Map Map the SfM-derived canopy height model which is a measurement of the height of trees above the ground topography. mapview::mapview( bhef_boundary , color = &quot;black&quot; , lwd = 3 , alpha.regions = 0 , layer.name = &quot;BHEF&quot; , label = FALSE , legend = FALSE , popup = FALSE ) + # aggregate raster and map mapview::mapview( chm_rast_temp , layer.name = &quot;canopy ht. (ft)&quot; , col.regions = viridis::plasma(n=50) , alpha.regions = 0.7 , na.color = &quot;transparent&quot; ) # # tree_tops # mapview::mapview( # treetops_sf_with_dbh # , cex = 0.5 # , layer.name = &quot;tree tops&quot; # , label = F # , legend = F # , popup = F # ) 5.4 DBH Distribution DBH distribution of trees that are in a harvested unit. Trees within harvest unit boundaries have a DBH range from 2.5 in (6.5 cm) to 29.1 in (74.0 cm) with a median of 4.4 in (11.2 cm). harvests_trees %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(treeID, dbh_in) %&gt;% dplyr::distinct() %&gt;% ggplot( mapping = aes(x = dbh_in) ) + geom_density(alpha = 0.8, fill = &quot;navy&quot;, color = NA) + labs( x = &quot;DBH (in)&quot; , y = &quot;density&quot; , title = &quot;SfM-derived tree DBH distribution&quot; ) + scale_x_continuous(breaks = scales::extended_breaks(n=20)) + theme_light() + theme( legend.position = &quot;none&quot; ) 5.5 Height Distribution Height distribution of trees that are in a harvested unit. Trees within harvest unit boundaries have a height range from 6.6 ft (2.0 m) to 90.5 ft (27.6 m) with a median of 18.6 ft (5.7 m). harvests_trees %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(treeID, tree_height_ft) %&gt;% dplyr::distinct() %&gt;% ggplot( mapping = aes(x = tree_height_ft) ) + geom_density(alpha = 0.8, fill = &quot;steelblue&quot;, color = NA) + labs( x = &quot;Height (ft)&quot; , y = &quot;density&quot; , title = &quot;SfM-derived tree height distribution&quot; ) + scale_x_continuous(breaks = scales::extended_breaks(n=10)) + theme_light() + theme( legend.position = &quot;none&quot; ) 5.6 Relationship between height and DBH ### plot harvests_trees %&gt;% sf::st_drop_geometry() %&gt;% dplyr::slice_sample(prop = 0.2) %&gt;% dplyr::select(treeID, tree_height_ft, dbh_in) %&gt;% dplyr::distinct() %&gt;% ggplot( mapping = aes(y=tree_height_ft, x = dbh_in) ) + geom_point( alpha = 0.6 , size = 0.6 , color = &quot;gray&quot; ) + geom_smooth( method = &quot;loess&quot; , se = F , span = 1 , color = &quot;gray33&quot; , alpha = 0.7 ) + labs( x = &quot;DBH (in)&quot; , y = &quot;Tree Ht. (ft)&quot; , title = &quot;SfM-derived tree height and DBH relationship&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; ) "],["silvicultural-metrics.html", "Section 6 Silvicultural Metrics 6.1 Distribution of silvicultural metrics 6.2 Stand Basal Area Map 6.3 Stand QMD Map 6.4 Define Functions for Stand Summary 6.5 Harvest Unit Summary Reports", " Section 6 Silvicultural Metrics Silvicultural metrics are calculated based on the SfM-derived DBH and height measurements. # Common silvicultural metrics are calculated for the entire extent. # Note, that stand-level summaries can be computed if stand vector data is provided. # metrics include: # &quot;n_trees&quot; # &quot;stand_area_ha&quot; # &quot;trees_per_ha&quot; # &quot;mean_dbh_cm&quot; # &quot;qmd_cm&quot; # &quot;mean_tree_height_m&quot; # &quot;loreys_height_m&quot; # &quot;basal_area_m2&quot; # &quot;basal_area_m2_per_ha&quot; ### stand-level summaries silv_metrics = harvests_trees %&gt;% sf::st_drop_geometry() %&gt;% dplyr::ungroup() %&gt;% dplyr::group_by(suid,stand_area_ha) %&gt;% dplyr::summarise( n_trees = dplyr::n_distinct(treeID) , mean_dbh_cm = mean(dbh_cm, na.rm = T) , mean_tree_height_m = mean(tree_height_m, na.rm = T) , loreys_height_m = sum(basal_area_m2*tree_height_m, na.rm = T) / sum(basal_area_m2, na.rm = T) , basal_area_m2 = sum(basal_area_m2, na.rm = T) , sum_dbh_cm_sq = sum(dbh_cm^2, na.rm = T) ) %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate( trees_per_ha = (n_trees/stand_area_ha) , basal_area_m2_per_ha = (basal_area_m2/stand_area_ha) , qmd_cm = sqrt(sum_dbh_cm_sq/n_trees) ) %&gt;% dplyr::select(-c(sum_dbh_cm_sq)) %&gt;% # convert to imperial units dplyr::mutate( dplyr::across( .cols = tidyselect::ends_with(&quot;_cm&quot;) , ~ .x * 0.394 , .names = &quot;{.col}_in&quot; ) , dplyr::across( .cols = tidyselect::ends_with(&quot;_m&quot;) , ~ .x * 3.28 , .names = &quot;{.col}_ft&quot; ) , dplyr::across( .cols = tidyselect::ends_with(&quot;_m2_per_ha&quot;) , ~ .x * 4.359 , .names = &quot;{.col}_ftac&quot; ) , dplyr::across( .cols = tidyselect::ends_with(&quot;_per_ha&quot;) &amp; !tidyselect::ends_with(&quot;_m2_per_ha&quot;) , ~ .x * 0.405 , .names = &quot;{.col}_ac&quot; ) , dplyr::across( .cols = tidyselect::ends_with(&quot;_area_ha&quot;) , ~ .x * 2.471 , .names = &quot;{.col}_ac&quot; ) , dplyr::across( .cols = tidyselect::ends_with(&quot;_m2&quot;) , ~ .x * 10.764 , .names = &quot;{.col}_ft2&quot; ) ) %&gt;% dplyr::rename_with( .fn = function(x){dplyr::case_when( stringr::str_ends(x,&quot;_cm_in&quot;) ~ stringr::str_replace(x,&quot;_cm_in&quot;,&quot;_in&quot;) , stringr::str_ends(x,&quot;_m_ft&quot;) ~ stringr::str_replace(x,&quot;_m_ft&quot;,&quot;_ft&quot;) , stringr::str_ends(x,&quot;_m2_per_ha_ftac&quot;) ~ stringr::str_replace(x,&quot;_m2_per_ha_ftac&quot;,&quot;_ft2_per_ac&quot;) , stringr::str_ends(x,&quot;_per_ha_ac&quot;) ~ stringr::str_replace(x,&quot;_per_ha_ac&quot;,&quot;_per_ac&quot;) , stringr::str_ends(x,&quot;_area_ha_ac&quot;) ~ stringr::str_replace(x,&quot;_area_ha_ac&quot;,&quot;_area_ac&quot;) , stringr::str_ends(x,&quot;_m2_ft2&quot;) ~ stringr::str_replace(x,&quot;_m2_ft2&quot;,&quot;_ft2&quot;) , TRUE ~ x )} ) %&gt;% dplyr::select( &quot;suid&quot; , &quot;n_trees&quot; , &quot;stand_area_ha&quot; , &quot;trees_per_ha&quot; , &quot;mean_dbh_cm&quot; , &quot;qmd_cm&quot; , &quot;mean_tree_height_m&quot; , &quot;loreys_height_m&quot; , &quot;basal_area_m2&quot; , &quot;basal_area_m2_per_ha&quot; # imperial , &quot;stand_area_ac&quot; , &quot;trees_per_ac&quot; , &quot;mean_dbh_in&quot; , &quot;qmd_in&quot; , &quot;mean_tree_height_ft&quot; , &quot;loreys_height_ft&quot; , &quot;basal_area_ft2&quot; , &quot;basal_area_ft2_per_ac&quot; ) ### export tabular write.csv( silv_metrics , paste0(delivery_dir, &quot;/stand_silv_metrics.csv&quot;) , row.names = F ) # join with spatial data silv_metrics = harvests %&gt;% # join with plot data data dplyr::inner_join( silv_metrics , by = dplyr::join_by(&quot;suid&quot;) ) 6.1 Distribution of silvicultural metrics Distribution of silvicultural metrics across the 6 stands in this analysis. silv_metrics %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select( &quot;suid&quot; , &quot;stand_area_ac&quot; , &quot;n_trees&quot; , &quot;trees_per_ac&quot; , &quot;mean_dbh_in&quot; , &quot;qmd_in&quot; , &quot;mean_tree_height_ft&quot; , &quot;loreys_height_ft&quot; , &quot;basal_area_ft2_per_ac&quot; ) %&gt;% tidyr::pivot_longer( cols = -c(suid), names_to = &quot;metric&quot;, values_to = &quot;val&quot; ) %&gt;% # order metrics dplyr::mutate( metric = factor( metric , ordered = T , levels = c( &quot;stand_area_ac&quot; , &quot;n_trees&quot; , &quot;trees_per_ac&quot; , &quot;mean_tree_height_ft&quot; , &quot;loreys_height_ft&quot; , &quot;mean_dbh_in&quot; , &quot;qmd_in&quot; , &quot;basal_area_ft2_per_ac&quot; ) , labels = c( latex2exp::TeX(&quot;Stand Area (ac)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Number of Trees&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Trees $ac^{-1}$&quot;) , latex2exp::TeX(&quot;Mean Tree Height (ft)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Lorey&#39;s Mean Height (ft)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Mean DBH (in)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;QMD (in)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Basal Area $ft^{2} \\\\cdot ac^{-1}$&quot;) ) ) ) %&gt;% ggplot( mapping = aes( x = val , y = 1 ) ) + geom_boxplot(fill = &quot;gray&quot;, width = 0.7, outlier.shape = NA) + geom_point(mapping = aes(group = suid)) + facet_wrap(facets = vars(metric), ncol = 2, scales = &quot;free_x&quot;, labeller = label_parsed) + scale_x_continuous(breaks = scales::extended_breaks(6)) + scale_y_continuous(limits = c(0.5,1.5)) + labs( y = &quot;&quot; , x = &quot;&quot; , title = &quot;Distribution of Silvicultural Metrics&quot; , subtitle = paste(nrow(silv_metrics), &quot;stands included in analysis&quot;) ) + theme_light() + theme( legend.position = &quot;none&quot; , strip.text = element_text(color = &quot;black&quot;) , strip.background = element_rect(fill = &quot;gray88&quot;) , axis.text.y = element_blank() , axis.ticks.y = element_blank() , panel.grid.major.y = element_blank() , panel.grid.minor.y = element_blank() ) 6.2 Stand Basal Area Map mapview::mapview( bhef_boundary , color = &quot;black&quot; , lwd = 3 , alpha.regions = 0 , layer.name = &quot;BHEF&quot; , label = FALSE , legend = FALSE , popup = FALSE ) + mapview::mapview( silv_metrics , zcol = &quot;basal_area_ft2_per_ac&quot; , layer.name = &quot;BA (ft2 per ac)&quot; #latex2exp::TeX(&quot;Basal Area $ft^{2} \\\\cdot ac^{-1}$&quot;) , col.regions = viridis::cividis(n=nrow(silv_metrics)*1.1) , alpha.regions = 0.7 , na.color = &quot;transparent&quot; , popup = F ) 6.3 Stand QMD Map Quadratic mean diameter (QMD) is a measure of the diameter of the tree of mean basal area: \\[ \\textrm{quadratic mean diameter (QMD)} = \\sqrt{\\frac{\\sum{d_{i}^{2}}}{n}} \\] , where \\(d_{i}\\) is the diameter at breast height of an individual tree, and \\(n\\) is the total number of trees. mapview::mapview( bhef_boundary , color = &quot;black&quot; , lwd = 3 , alpha.regions = 0 , layer.name = &quot;BHEF&quot; , label = FALSE , legend = FALSE , popup = FALSE ) + mapview::mapview( silv_metrics , zcol = &quot;qmd_in&quot; , layer.name = &quot;QMD (in)&quot; #latex2exp::TeX(&quot;Basal Area $ft^{2} \\\\cdot ac^{-1}$&quot;) , col.regions = viridis::mako(n=nrow(silv_metrics)*1.1, direction = -1) , alpha.regions = 0.7 , na.color = &quot;transparent&quot; , popup = F ) 6.4 Define Functions for Stand Summary Create plots to combine for report orthomosaic + chm + tree tops + stand plot ###################################################################################### # function to plot ortho + chm + points + stand ###################################################################################### ortho_plt_fn = function(my_suid){ # convert to stars ortho_st = ortho_rast %&gt;% terra::subset(subset = c(1,2,3)) %&gt;% terra::crop( # stand %&gt;% harvests %&gt;% dplyr::filter(suid==my_suid) %&gt;% sf::st_buffer(20) %&gt;% sf::st_bbox() %&gt;% sf::st_as_sfc() %&gt;% terra::vect() ) %&gt;% terra::aggregate(fact = 2, fun = &quot;mean&quot;, na.rm = T) %&gt;% stars::st_as_stars() # convert to rgb ortho_rgb &lt;- stars::st_rgb( ortho_st[,,,1:3] , dimension = 3 , use_alpha = FALSE # , stretch = &quot;histogram&quot; , probs = c(0.005, 0.995) , stretch = &quot;percent&quot; ) # ggplot plt_rgb &lt;- ggplot() + stars::geom_stars(data = ortho_rgb[]) + scale_fill_identity(na.value = &quot;transparent&quot;) + # !!! don&#39;t take this out or RGB plot will kill your computer scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + labs( x = &quot;&quot; , y = &quot;&quot; ) + theme_void() # return(plt_rgb) # combine all plot elements plt_combine = plt_rgb + ggnewscale::new_scale_fill() + geom_tile( data = chm_rast %&gt;% terra::crop( harvests %&gt;% dplyr::filter(suid==my_suid) %&gt;% terra::vect() ) %&gt;% terra::mask( harvests %&gt;% dplyr::filter(suid==my_suid) %&gt;% terra::vect() ) %&gt;% `*`(3.28) %&gt;% # transform to feet as.data.frame(xy=T) %&gt;% rename(f=3) , mapping = aes(x=x,y=y,fill=f) ) + scale_fill_viridis_c(option=&quot;plasma&quot;, alpha = 0.6) + geom_sf( data = harvests %&gt;% dplyr::filter(suid==my_suid) , alpha = 0 , lwd = 1.5 , color = &quot;#b22222&quot; ) + geom_sf( data = treetops_sf_with_dbh %&gt;% sf::st_intersection(harvests %&gt;% dplyr::filter(suid==my_suid)) , color = &quot;#330099&quot; , shape = &quot;.&quot; ) + labs( fill = &quot;canopy ht. (ft)&quot; # , title = &quot;Trees identified within stand boundary&quot; , title = &quot;&lt;span&gt;&lt;span style=&#39;color:#330099;&#39;&gt;&lt;b&gt;&lt;i&gt;Trees&lt;/i&gt;&lt;/b&gt;&lt;/span&gt; identified within &lt;span style=&#39;color:#b22222;&#39;&gt;&lt;b&gt;&lt;i&gt;stand&lt;/i&gt;&lt;/b&gt;&lt;/span&gt; boundary&lt;/span&gt;&quot; ) + theme( legend.position = &quot;top&quot; # c(0.5,1) , legend.direction = &quot;horizontal&quot; , legend.margin = margin(0,0,-1,0) , legend.text = element_text(size = 8) , legend.title = element_text(size = 8) , plot.title = ggtext::element_markdown(size = 10, hjust = 0.5) ) return(plt_combine) } # ortho_plt_fn(harvests$suid[2]) dbh distribution plot dbh_dist_fn = function(my_suid){ harvests_trees %&gt;% dplyr::filter(suid == my_suid) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(treeID, dbh_in) %&gt;% dplyr::distinct() %&gt;% ggplot( mapping = aes(x = dbh_in) ) + geom_density(alpha = 0.8, fill = &quot;navy&quot;, color = NA) + labs( x = &quot;DBH (in)&quot; , y = &quot;density&quot; , title = &quot;SfM-derived tree DBH distribution&quot; ) + scale_x_continuous(breaks = scales::extended_breaks(n=20)) + theme_light() + theme( legend.position = &quot;none&quot; ) } # dbh_dist_fn(harvests$suid[1]) height distribution plot ht_dist_fn = function(my_suid){ harvests_trees %&gt;% dplyr::filter(suid == my_suid) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(treeID, tree_height_ft) %&gt;% dplyr::distinct() %&gt;% ggplot( mapping = aes(x = tree_height_ft) ) + geom_density(alpha = 0.8, fill = &quot;steelblue&quot;, color = NA) + labs( x = &quot;Height (ft)&quot; , y = &quot;density&quot; , title = &quot;SfM-derived tree height distribution&quot; ) + scale_x_continuous(breaks = scales::extended_breaks(n=10)) + theme_light() + theme( legend.position = &quot;none&quot; ) } # ht_dist_fn(harvests$suid[1]) silvicultural metrics imperial table tab_imp_fn = function(my_suid){ silv_metrics %&gt;% dplyr::filter(suid == my_suid) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select( &quot;suid&quot; , &quot;stand_area_ac&quot; , &quot;n_trees&quot; , &quot;trees_per_ac&quot; , &quot;mean_dbh_in&quot; , &quot;qmd_in&quot; , &quot;mean_tree_height_ft&quot; , &quot;loreys_height_ft&quot; , &quot;basal_area_ft2_per_ac&quot; ) %&gt;% tidyr::pivot_longer( cols = -c(suid), names_to = &quot;metric&quot;, values_to = &quot;val&quot; ) %&gt;% # order metrics dplyr::mutate( metric = factor( metric , ordered = T , levels = c( &quot;stand_area_ac&quot; , &quot;n_trees&quot; , &quot;trees_per_ac&quot; , &quot;mean_tree_height_ft&quot; , &quot;loreys_height_ft&quot; , &quot;mean_dbh_in&quot; , &quot;qmd_in&quot; , &quot;basal_area_ft2_per_ac&quot; ) , labels = c( latex2exp::TeX(&quot;Stand Area (ac)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Number of Trees&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Trees $ac^{-1}$&quot;) , latex2exp::TeX(&quot;Mean Tree Height (ft)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Lorey&#39;s Mean Height (ft)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Mean DBH (in)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;QMD (in)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Basal Area $ft^{2} \\\\cdot ac^{-1}$&quot;) ) ) ) %&gt;% dplyr::mutate(val = scales::comma(val,accuracy=0.1)) %&gt;% dplyr::select(metric, val) %&gt;% ggpubr::ggtexttable( rows = NULL , cols = rep(&quot;&quot;, 2) , theme = ggpubr::ttheme( base_style = &quot;blank&quot; , tbody.style = ggpubr::tbody_style( parse = T, fill = &quot;white&quot;, linecolor = &quot;gray&quot; , size = 10 ) ) ) %&gt;% ggpubr::tab_add_title( text = &quot;Silvicultural Metrics (imperial)&quot;, face = &quot;bold&quot; , size = 10, padding = unit(0.5, &quot;line&quot;) ) } # tab_imp_fn(harvests$suid[2]) silvicultural metrics metric table tab_met_fn = function(my_suid){ silv_metrics %&gt;% dplyr::filter(suid == my_suid) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select( &quot;suid&quot; , &quot;stand_area_ha&quot; , &quot;n_trees&quot; , &quot;trees_per_ha&quot; , &quot;mean_dbh_cm&quot; , &quot;qmd_cm&quot; , &quot;mean_tree_height_m&quot; , &quot;loreys_height_m&quot; , &quot;basal_area_m2_per_ha&quot; ) %&gt;% tidyr::pivot_longer( cols = -c(suid), names_to = &quot;metric&quot;, values_to = &quot;val&quot; ) %&gt;% # order metrics dplyr::mutate( metric = factor( metric , ordered = T , levels = c( &quot;stand_area_ha&quot; , &quot;n_trees&quot; , &quot;trees_per_ha&quot; , &quot;mean_tree_height_m&quot; , &quot;loreys_height_m&quot; , &quot;mean_dbh_cm&quot; , &quot;qmd_cm&quot; , &quot;basal_area_m2_per_ha&quot; ) , labels = c( latex2exp::TeX(&quot;Stand Area (ha)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Number of Trees&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Trees $ha^{-1}$&quot;) , latex2exp::TeX(&quot;Mean Tree Height (m)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Lorey&#39;s Mean Height (m)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Mean DBH (cm)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;QMD (cm)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Basal Area $m^{2} \\\\cdot ha^{-1}$&quot;) ) ) ) %&gt;% dplyr::mutate(val = scales::comma(val,accuracy=0.1)) %&gt;% dplyr::select(metric, val) %&gt;% ggpubr::ggtexttable( rows = NULL , cols = rep(&quot;&quot;, 2) , theme = ggpubr::ttheme( base_style = &quot;blank&quot; , tbody.style = ggpubr::tbody_style( parse = T, fill = &quot;white&quot;, linecolor = &quot;gray&quot; , size = 10 ) ) ) %&gt;% ggpubr::tab_add_title( text = &quot;Silvicultural Metrics (metric)&quot;, face = &quot;bold&quot; , size = 10, padding = unit(0.5, &quot;line&quot;) ) } # tab_met_fn(harvests$suid[2]) inset map plot plt_inset_map_fn &lt;- function(my_suid){ ( ggplot() + geom_sf(data = bhef_boundary, alpha = 0, lwd = 1, color = &quot;black&quot;) + geom_sf(data = harvests, alpha = 0, lwd = 0.4, color = &quot;gray&quot;) + geom_sf( data = harvests %&gt;% dplyr::filter(suid == my_suid) , fill = &quot;firebrick&quot; , alpha = 0.3 , lwd = 1.5 , color = &quot;firebrick&quot; ) + # geom_sf_label( # data = rx_fire # , aes(label = unit) # , label.size = NA # , alpha = 0 # , size = 2.5 # ) + xlab(&quot;&quot;) + ylab(&quot;&quot;) + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + theme_bw() + theme( axis.text = element_text(size = 5.5) , axis.text.x = element_text(angle = 35) , panel.border = element_blank() ) ) } # plt_inset_map_fn(harvests$suid[4]) contour + elevation map plot # sequence by 5&#39;s to get 5m breaks list for contour contour_int_m &lt;- 5 seq_brk &lt;- seq(0, 40000, contour_int_m) # create contour data elev_contour &lt;- dtm_rast %&gt;% stars::st_as_stars() %&gt;% stars::st_contour( na.rm = TRUE , contour_lines = FALSE , breaks = # classInt::classIntervals(na.omit(as.vector(x[[1]])))$brks seq_brk[ seq_brk &gt; min(na.omit(as.vector(dtm_rast[[1]]))) - contour_int_m &amp; seq_brk &lt; max(na.omit(as.vector(dtm_rast[[1]]))) + contour_int_m ] ) plt_contour_map_fn &lt;- function(my_suid){ ( ######################################### ######################################### # map of unit w/ contour ######################################### ######################################### # plot ggplot() + geom_tile( data = dtm_rast %&gt;% terra::crop( harvests %&gt;% dplyr::filter(suid == my_suid) %&gt;% sf::st_buffer(dist = 20) %&gt;% sf::st_bbox() %&gt;% sf::st_as_sfc() %&gt;% terra::vect() ) %&gt;% terra::aggregate(fact=2) %&gt;% `*`(3.28) %&gt;% # transform to feet as.data.frame(xy=T) %&gt;% dplyr::rename(elev = 3) , mapping = aes(x=x,y=y,fill=elev) ) + geom_sf(data = elev_contour %&gt;% sf::st_crop( harvests %&gt;% dplyr::filter(suid == my_suid) %&gt;% sf::st_buffer(dist = 20) %&gt;% sf::st_bbox() ) , alpha = 0 , lwd = 0.5 , color = &quot;gray30&quot; , show.legend = FALSE ) + geom_sf(data = harvests %&gt;% dplyr::filter(suid == my_suid) , alpha = 0 , lwd = 1.5 , color = &quot;firebrick&quot; , show.legend = FALSE ) + scale_fill_viridis_c( option = &quot;viridis&quot; , alpha = 0.9 , na.value = &quot;transparent&quot; , breaks = scales::extended_breaks(n = 6) , labels = scales::comma ) + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + labs( subtitle = paste0( as.character(round(contour_int_m * 3.28, 1)) , &quot; ft (&quot; , as.character(contour_int_m) , &quot; m) contours&quot; ) , fill = &quot;elev. (ft)&quot; , x = &quot;&quot; , y = &quot;&quot; ) + theme_void() + theme( legend.position = &quot;top&quot; , legend.direction = &quot;horizontal&quot; , legend.margin = margin(0,0,-1,0) # , legend.box.margin = margin(-1,0,2,0) , legend.text = element_text(size = 7, angle = 25, hjust = 0.7) , legend.title = element_text(size = 7) , plot.subtitle = element_text( size=9, face=&quot;italic&quot;, color=&quot;gray20&quot;, margin = margin(0,0,0,0) , hjust = 0.5 ) ) ) } # plt_contour_map_fn(harvests$suid[1]) build report report_fn = function(my_suid){ # generate plots ortho_plt_temp = ortho_plt_fn(my_suid) # ortho_plt_fn(harvests$suid[4]) dbh_dist_temp = dbh_dist_fn(my_suid) # dbh_dist_fn(harvests$suid[4]) ht_dist_temp = ht_dist_fn(my_suid) # ht_dist_fn(harvests$suid[4]) plt_inset_map_temp = plt_inset_map_fn(my_suid) # plt_inset_map_fn(harvests$suid[4]) plt_contour_map_temp = plt_contour_map_fn(my_suid) # plt_contour_map_fn(harvests$suid[4]) tab_imp_temp = tab_imp_fn(my_suid) # tab_imp_fn(harvests$suid[4]) tab_met_temp = tab_met_fn(my_suid) # tab_met_fn(harvests$suid[4]) # plot layout # area(t,l,b,r) layout_temp = c( # map area(1, 1, 3, 2) # space , area(1, 3, 1, 4) # distributions , area(2, 3, 2, 4) , area(3, 3, 3, 4) # space , area(4, 3, 4, 4) # map inset , area(4, 1, 5, 1) # contour , area(4, 2, 5, 2) # tables , area(5, 3) , area(5, 4) # space , area(6, 1, 6, 4) ) # check the layout # plot(layout_temp) # patchwork rpt = ortho_plt_temp + patchwork::plot_spacer() + dbh_dist_temp + ht_dist_temp + patchwork::plot_spacer() + plt_inset_map_temp + plt_contour_map_temp + tab_imp_temp + tab_met_temp + patchwork::plot_spacer() + patchwork::plot_layout( design = layout_temp , heights = c(0.01,1,1,0.4,1,0.1) , widths = c(0.5,1,1,1) ) # export ggplot2::ggsave( filename = paste0(delivery_dir, &quot;/suid_&quot;, my_suid, &quot;.pdf&quot;) , plot = rpt , device = &quot;pdf&quot; , width = 11, height = 8.5, units = &quot;in&quot; ) return(rpt) } 6.5 Harvest Unit Summary Reports # generate and print reports harvests$suid %&gt;% purrr::map(report_fn) %&gt;% print() # combine all pdfs together # combine with pdftools pdftools::pdf_combine( sort(list.files(delivery_dir, pattern = &quot;\\\\.pdf$&quot;, full.names = TRUE)) , output = paste0( delivery_dir , &quot;/BHEF_UAS_202306_report_&quot; , gsub(&quot;-&quot;, &quot;&quot;, Sys.Date()) , &quot;.pdf&quot; ) ) "],["overstory-field-validation-data.html", "Section 7 Overstory Field Validation Data 7.1 Load Field Data 7.2 Build UAS-Field Validation Data 7.3 Summary of Validation Data", " Section 7 Overstory Field Validation Data Tinkham and Swayze (2021; p.6) describe a methodology for matching UAS detected trees with stem mapped trees identified via traditional field survey methods. Note, detected trees in the excerpt below references UAS detected trees while survey trees references field-based stem mapped trees: Each of the detected tree outputs was matched with survey tree locations through an iterative process. Iteratively, a detected tree was selected, and all survey trees within a 3 m radius and 10% height of the detected tree were identified. If a survey tree met both the location and height precision requirements, it was considered a true positive (TP) detection, and both the survey and detected trees were removed from further matching. However, if no match was made, the detected tree was considered a commission (Co) and removed from further matching. This process was repeated until all detected trees were classified as true positive or commission, with all unmatched survey trees classified as omission (Om). Overall tree detection performance was described using the F-score metric. The F-score incorporates true positive, commission, and omission rates to determine how well the UAS detected trees represent the field-based stem mapped trees. As a measure of predictive performance, the highest possible value of an F-score is 1.0, indicating perfect precision and recall, and the lowest possible value is 0, if either precision or recall are zero. \\[ \\textrm{F-score} = 2 \\times \\frac{\\bigl(\\frac{TP}{TP+Om} \\times \\frac{TP}{TP+Co} \\bigr)}{\\bigl(\\frac{TP}{TP+Om} + \\frac{TP}{TP+Co} \\bigr)} \\] The process to match UAS detected trees to field stem mapped trees implemented here is slightly different than the process described above. To match the data parametrization from the UAS point cloud processing workflow, only stem-mapped trees above 2 m were considered for analysis. Each UAS detected tree was matched with stem-mapped tree locations that were within a 3 m radius and 2 m height of the UAS detected tree. The matched UAS and stem-mapped tree pairs were jointly compared (rather than iteratively) to select the pair that minimized the height difference for both the stem-mapped tree and the UAS detected tree to ensure that only one UAS detected tree was selected for each stem-mapped tree. If more than one UAS detected tree had the same height difference to a stem-mapped tree, the UAS detected tree spatially nearest to the stem-mapped tree was selected as the match. These UAS detected trees with a paired stem-mapped tree after this filtering process were considered true positive (\\(TP\\)) detections. To determine UAS detected tree commissions (i.e. UAS detected trees within the overstory plot for which there was no stem-mapped tree pair; \\(Co\\)) this analysis used the 2023-06 BHEF overstory field survey plot center and plot radius with a minimum DBH of 5 in (12.69 cm) as only trees above this size were sampled as part of the overstory survey. UAS detected trees within this radius with an estimated DBH over 5 in (12.69 cm) that did not have a matched stem-mapped tree pair were considered commissions (\\(Co\\)). The 2023-06 BHEF field surveys used \\(\\frac{1}{10}\\) acre (404.686 m2) plots with a 37.24 ft (11.35 m) radius for overstory sampling and \\(\\frac{1}{400}\\) acre (10.117 m2) plots with a 5.89 ft (1.795 m) radius for regeneration sampling. All unmatched stem-mapped survey trees were classified as omissions (\\(Om\\)). 7.1 Load Field Data Load the overstory data, set parameters for processing, and map ################################################################################################## ## USER DEFINED PARAMETERS ################################################################################################## ### Only include trees above a specific height # e.g., set to match the minimum height used in point cloud processing min_tree_height_m = min(chm_rast %&gt;% terra::values(), na.rm = T) ### Only include trees above a specific DBH # e.g., set to match the minimum tree DBH for field sampling of overstory trees min_tree_dbh_cm = 12.689 # 3 in = 7.62 cm ### Find all nearest neighbors within maximum distance and then filter them based on ### distance and height error max_dist_m = 3 max_height_error_m = 2 ################################################################################################## ## USER DEFINED PARAMETERS ################################################################################################## # load Field Validation Data field_overstory = readr::read_csv( file = &quot;../data/field_data/Voodoo_overstory_data.csv&quot; ) %&gt;% dplyr::rename_with(~ .x %&gt;% # replace all non alphanumeric with _ stringr::str_replace_all(&quot;[^[:alnum:] ]+&quot;, &quot;_&quot;) %&gt;% # remove any _ at the end of the string stringr::str_remove(&quot;[_]$&quot;) %&gt;% tolower() ) %&gt;% dplyr::filter( !is.na(tree_diameter_inches) &amp; !is.na(tree_height_feet) &amp; !is.na(tree_utm_x) &amp; !is.na(tree_utm_y) ) %&gt;% dplyr::mutate( field_dbh_cm = tree_diameter_inches/0.394 , field_tree_height_m = tree_height_feet/3.281 , field_plottree_id = paste0( stringr::str_pad(plot_id, width = 4, side = &quot;left&quot;, pad = &quot;0&quot;) , &quot;-&quot; , stringr::str_pad(tree_id, width = 4, side = &quot;left&quot;, pad = &quot;0&quot;) ) ) %&gt;% dplyr::filter( field_tree_height_m &gt;= min_tree_height_m &amp; field_dbh_cm &gt;= min_tree_dbh_cm ) %&gt;% dplyr::rename( field_dbh_in = tree_diameter_inches , field_tree_height_ft = tree_height_feet ) %&gt;% sf::st_as_sf( coords = c(&quot;tree_utm_x&quot;, &quot;tree_utm_y&quot;) , crs = sf::st_crs(treetops_sf_with_dbh) , remove=F ) %&gt;% # keep only tree points that are within the uas flight boundary sf::st_intersection(las_ctg_dta) # field_overstory %&gt;% # sf::st_drop_geometry() %&gt;% # dplyr::summarize(n = dplyr::n(), unique_tree = dplyr::n_distinct(field_plottree_id)) field_overstory %&gt;% dplyr::glimpse() ## Rows: 368 ## Columns: 26 ## $ plot_id &lt;dbl&gt; 43, 32, 18, 19, 38, 43, 18~ ## $ observers_on_plot &lt;chr&gt; &quot;HK,TD,VH,CM&quot;, &quot;VH,HK,CM,T~ ## $ collection_date &lt;chr&gt; &quot;6/6/2023 18:00&quot;, &quot;6/8/202~ ## $ comments_on_plot_condition_or_abnormalities &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA~ ## $ x &lt;dbl&gt; -103.6168, -103.6362, -103~ ## $ y &lt;dbl&gt; 44.14265, 44.14125, 44.144~ ## $ tree_id &lt;dbl&gt; 1, 1, 1, 1, 1, 2, 2, 1, 1,~ ## $ species &lt;chr&gt; &quot;Pinus ponderosa&quot;, &quot;Pinus ~ ## $ tree_condition &lt;chr&gt; &quot;Live&quot;, &quot;Live&quot;, &quot;Live&quot;, &quot;L~ ## $ field_dbh_in &lt;dbl&gt; 9.3, 5.3, 9.3, 10.5, 5.2, ~ ## $ tree_distance_from_plot_center_ft &lt;dbl&gt; 13.0, 19.0, 36.7, 16.5, 6.~ ## $ azimuth_to_tree_degrees &lt;dbl&gt; 1, 2, 3, 5, 6, 7, 8, 12, 1~ ## $ field_tree_height_ft &lt;dbl&gt; 40.5, 28.0, 34.0, 48.0, 17~ ## $ tree_crown_base_height_feet &lt;dbl&gt; 11.5, 12.0, 7.0, 13.0, NA,~ ## $ tree_remarks &lt;chr&gt; NA, NA, NA, NA, &quot;Broken to~ ## $ parentglobalid &lt;chr&gt; &quot;bd4bdd71-588e-4d4a-b255-0~ ## $ uniqueid &lt;chr&gt; &quot;bd4bdd71-588e-4d4a-b255-0~ ## $ ba &lt;dbl&gt; 0.4717165, 0.1532029, 0.47~ ## $ utm_x &lt;dbl&gt; 610631.4, 609087.3, 608962~ ## $ utm_y &lt;dbl&gt; 4888644, 4888472, 4888774,~ ## $ tree_utm_y &lt;dbl&gt; 4888648, 4888478, 4888786,~ ## $ tree_utm_x &lt;dbl&gt; 610631.5, 609087.5, 608963~ ## $ field_dbh_cm &lt;dbl&gt; 23.60406, 13.45178, 23.604~ ## $ field_tree_height_m &lt;dbl&gt; 12.343798, 8.533984, 10.36~ ## $ field_plottree_id &lt;chr&gt; &quot;0043-0001&quot;, &quot;0032-0001&quot;, ~ ## $ geometry &lt;POINT [m]&gt; POINT (610631.5 4888~ Overstory field data map field_overstory %&gt;% sf::st_drop_geometry() %&gt;% dplyr::distinct(plot_id, utm_x, utm_y) %&gt;% sf::st_as_sf(coords = c(&quot;utm_x&quot;, &quot;utm_y&quot;), crs = sf::st_crs(treetops_sf_with_dbh)) %&gt;% sf::st_buffer(11.35) %&gt;% dplyr::mutate(x=1) %&gt;% mapview::mapview(col.regions = &quot;blue&quot;, layer.name = &quot;plot&quot;, alpha.regions = 0.6) + mapview::mapview(field_overstory, col.regions = &quot;orange&quot;, cex = 2, layer.name = &quot;trees&quot;) + mapview::mapview( harvests , color = &quot;black&quot; , lwd = 3 , alpha.regions = 0 , label = FALSE , legend = FALSE , popup = FALSE ) 7.2 Build UAS-Field Validation Data 7.2.1 True Positive Identification The UAS detected and stem-mapped tree pairs identified in this filtering process (detailed above) were considered true positive (\\(TP\\)) detections. ## BUFFER THE UAS TREES AND SPATIALLY MATCH FIELD TREES BASED ON THAT BUFFER ## get FIELD trees within radius OF UAS TREES potential_tree_pairs_temp = treetops_sf_with_dbh %&gt;% dplyr::select(treeID, tree_height_m) %&gt;% # buffer point sf::st_buffer(max_dist_m) %&gt;% # spatial join with all FIELD tree points sf::st_join( field_overstory %&gt;% dplyr::filter( field_tree_height_m &gt;= min_tree_height_m &amp; field_dbh_cm &gt;= min_tree_dbh_cm ) %&gt;% dplyr::select( field_plottree_id, field_tree_height_m , tree_utm_x, tree_utm_y ) , join = st_intersects , left = F # performs inner join to only keep uas trees with a match ) %&gt;% # calculate height difference dplyr::mutate( height_diff_m = abs(tree_height_m-field_tree_height_m) , height_diff_pct = height_diff_m/field_tree_height_m ) %&gt;% # removes tree pairs that are outside of the allowable error # dplyr::filter(height_diff_pct &lt;= max_height_error_pct) %&gt;% dplyr::filter(height_diff_m &lt;= max_height_error_m) %&gt;% dplyr::select(-c(height_diff_m)) %&gt;% dplyr::relocate(treeID, field_plottree_id) ## apply pair selection criteria if there are potential tree pairs if(nrow(potential_tree_pairs_temp)&gt;0){ ## calculate row by row distances and height differences potential_tree_pairs_temp = potential_tree_pairs_temp %&gt;% # this is the position of the uas tree sf::st_centroid() %&gt;% sf::st_set_geometry(&quot;geom1&quot;) %&gt;% dplyr::bind_cols( potential_tree_pairs_temp %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(&quot;tree_utm_x&quot;, &quot;tree_utm_y&quot;) %&gt;% # this is the position of the field tree sf::st_as_sf( coords = c(&quot;tree_utm_x&quot;, &quot;tree_utm_y&quot;), crs = sf::st_crs(treetops_sf_with_dbh) ) %&gt;% sf::st_set_geometry(&quot;geom2&quot;) ) %&gt;% dplyr::mutate( distance_m = sf::st_distance(geom1, geom2, by_element = T) %&gt;% as.numeric() ) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(-c(tree_utm_x, tree_utm_y, geom2)) ## define function to select the best tree pair select_best_tree_pair_fn &lt;- function(df) { df %&gt;% dplyr::group_by(field_plottree_id) %&gt;% dplyr::arrange(field_plottree_id, height_diff_pct, distance_m, desc(tree_height_m), treeID) %&gt;% dplyr::mutate( # at the field tree level...the number of uas trees n_uas_trees = dplyr::n() # at the field tree level... # the closest uas tree in height tie breaker distance, uas_tree_height_m, id , rank_within_field_tree = dplyr::row_number() ) %&gt;% dplyr::group_by(treeID) %&gt;% dplyr::arrange(treeID, height_diff_pct, distance_m, desc(field_tree_height_m), field_plottree_id) %&gt;% dplyr::mutate( # at the uas tree level...the number of field trees n_field_trees = dplyr::n() # at the field tree level... # the closest field tree in height tie breaker distance, uas_tree_height_m, id , rank_within_uas_tree = dplyr::row_number() ) %&gt;% dplyr::ungroup() %&gt;% # select the uas-field tree pair with the minimum height difference dplyr::filter( rank_within_field_tree == 1 &amp; rank_within_uas_tree == 1 ) %&gt;% # remove columns dplyr::select( -c(tidyselect::starts_with(&quot;rank_&quot;), tidyselect::starts_with(&quot;n_&quot;)) ) } ## first filter for tree pairs true_positive_trees = select_best_tree_pair_fn(potential_tree_pairs_temp) ##remove matches from potential tree pairs potential_tree_pairs_temp = potential_tree_pairs_temp %&gt;% dplyr::filter( !(treeID %in% true_positive_trees$treeID) &amp; !(field_plottree_id %in% true_positive_trees$field_plottree_id) ) ## keep filtering for best pair until no unique pairs remain while(nrow(potential_tree_pairs_temp)&gt;0) { # keep filtering for best pair until no unique pairs remain true_positive_trees = true_positive_trees %&gt;% dplyr::bind_rows( select_best_tree_pair_fn(potential_tree_pairs_temp) ) #remove matches from potential tree pairs potential_tree_pairs_temp = potential_tree_pairs_temp %&gt;% dplyr::filter( !(treeID %in% true_positive_trees$treeID) &amp; !(field_plottree_id %in% true_positive_trees$field_plottree_id) ) } ## rename columns and flag true_positive_trees = true_positive_trees %&gt;% dplyr::rename( uas_tree_height_m = tree_height_m , uas_tree_id = treeID , field_uas_distance_m = distance_m ) %&gt;% dplyr::mutate( field_uas_group = &quot;true positive&quot; ) }else{ # if there are spatially matched trees true_positive_trees = dplyr::tibble( uas_tree_id = as.character(NA) , field_plottree_id = as.character(NA) , uas_tree_height_m = as.numeric(NA) , field_tree_height_m = as.numeric(NA) , height_diff_pct = as.numeric(NA) , field_uas_distance_m = as.numeric(NA) , field_uas_group = as.character(NA) ) } remove(potential_tree_pairs_temp) gc() True positive detections #check data true_positive_trees %&gt;% dplyr::summarise( n_rows = n() , unique_uas_trees = n_distinct(uas_tree_id) , unique_field_trees = n_distinct(field_plottree_id) , unique_pairs = n_distinct(field_plottree_id, uas_tree_id) ) %&gt;% kableExtra::kbl(caption = &quot;results of true positive stem-uas tree matching&quot;) %&gt;% kableExtra::kable_styling() Table 7.1: results of true positive stem-uas tree matching n_rows unique_uas_trees unique_field_trees unique_pairs 304 304 304 304 7.2.2 Combine with Commission and Omission To determine UAS detected tree commissions (i.e. UAS detected trees within the overstory plot for which there was no stem-mapped tree pair; \\(Co\\)) this analysis used the 2023-06 BHEF overstory field survey plot center and plot radius of 11.35 m. UAS detected trees within this radius with an estimated DBH over 5 in (12.69 cm) that did not have a matched stem-mapped tree pair were considered commissions (\\(Co\\)). Omissions (\\(Om\\)) are stem-mapped trees without a UAS detected tree match. field_uas_comparison = dplyr::bind_rows( ## true positive true_positive_trees ## omission , field_overstory %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select( plot_id, field_plottree_id, field_tree_height_m ) %&gt;% dplyr::anti_join( true_positive_trees , by = dplyr::join_by(field_plottree_id) ) %&gt;% dplyr::mutate( field_uas_group = &quot;omission&quot; ) ## commission , field_overstory %&gt;% sf::st_drop_geometry() %&gt;% # get field plot center locations dplyr::distinct(plot_id, utm_x, utm_y) %&gt;% sf::st_as_sf(coords = c(&quot;utm_x&quot;, &quot;utm_y&quot;), crs = sf::st_crs(treetops_sf_with_dbh)) %&gt;% # buffer plot center with plot area 11.35m radius + mean error in true positive trees # sf::st_buffer(11.35+mean(true_positive_trees$field_uas_distance_m, na.rm = T)) %&gt;% # buffer plot center with plot area 11.35m radius sf::st_buffer(11.35) %&gt;% # join with uas tree points sf::st_join( treetops_sf_with_dbh %&gt;% dplyr::filter( !treeID %in% true_positive_trees$uas_tree_id &amp; dbh_cm &gt;= min_tree_dbh_cm &amp; tree_height_m &gt;= min_tree_height_m ) %&gt;% dplyr::select(treeID) %&gt;% dplyr::rename(uas_tree_id=treeID) , join = st_intersects , left = F # performs inner join to only keep uas trees and plots with a match ) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::mutate( field_uas_group = &quot;commission&quot; ) ) %&gt;% # attach uas data dplyr::left_join( treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(treeID, tree_height_m, dbh_cm) %&gt;% dplyr::rename( uas_tree_id = treeID , uas_tree_height_m = tree_height_m , uas_dbh_cm = dbh_cm ) , by = dplyr::join_by(uas_tree_id) ) %&gt;% # attach field data dplyr::left_join( field_overstory %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(field_plottree_id, field_tree_height_m, field_dbh_cm, plot_id) , by = dplyr::join_by(field_plottree_id) ) %&gt;% # update data dplyr::mutate( uas_tree_height_m = uas_tree_height_m.y , field_tree_height_m = field_tree_height_m.y , plot_id = dplyr::coalesce(plot_id.x, plot_id.y) , field_uas_group = factor( field_uas_group , ordered = T , levels = c( &quot;true positive&quot; , &quot;commission&quot; , &quot;omission&quot; ) ) %&gt;% forcats::fct_rev() , dbh_diff_cm = uas_dbh_cm - field_dbh_cm , tree_height_diff_m = uas_tree_height_m - field_tree_height_m , dbh_diff_pct = dbh_diff_cm/field_dbh_cm , height_diff_pct = tree_height_diff_m/field_tree_height_m , abs_dbh_diff_pct = abs(dbh_diff_pct) , abs_height_diff_pct = abs(height_diff_pct) , plot_lab = stringr::str_pad(plot_id, width = 4, side = &quot;left&quot;, pad = &quot;0&quot;) ) %&gt;% dplyr::relocate(field_uas_group) %&gt;% dplyr::select(-c(tidyselect::ends_with(&quot;.x&quot;), tidyselect::ends_with(&quot;.y&quot;))) %&gt;% # convert to imperial units calc_imperial_units_fn() ## write write.csv(field_uas_comparison, paste0(delivery_dir,&quot;/field_uas_comparison_data.csv&quot;), row.names = F) ## aggregate data to plot level field_uas_comparison_plot = field_uas_comparison %&gt;% dplyr::count(plot_id, plot_lab, field_uas_group) %&gt;% dplyr::group_by(plot_id, plot_lab) %&gt;% dplyr::mutate( pct = n/sum(n) , tot = sum(n) , tp_pct=max(ifelse(field_uas_group==&quot;true positive&quot;,pct,0)) ) %&gt;% dplyr::ungroup() %&gt;% # attach f score dplyr::inner_join( field_uas_comparison %&gt;% dplyr::count(plot_id, field_uas_group) %&gt;% dplyr::mutate(field_uas_group = dplyr::case_when( field_uas_group == &quot;true positive&quot; ~ &quot;tp&quot; , field_uas_group == &quot;commission&quot; ~ &quot;co&quot; , field_uas_group == &quot;omission&quot; ~ &quot;om&quot; )) %&gt;% tidyr::pivot_wider( names_from = field_uas_group , values_from = n , values_fill = 0 ) %&gt;% dplyr::mutate( plot_f_score = dplyr::coalesce( 2 * ( (tp/(tp+om)) * (tp/(tp+co)) ) / ( (tp/(tp+om)) + (tp/(tp+co)) ) , 0 ) ) %&gt;% dplyr::select(plot_id, plot_f_score) , by = dplyr::join_by(plot_id) ) 7.3 Summary of Validation Data 7.3.1 True Positive, Commission, Ommission Summary of tree true positive (\\(TP\\)), commission (\\(Co\\)), and omission (\\(Om\\)) detection by BHEF overstory plot. field_uas_comparison_plot %&gt;% ggplot( mapping = aes(x = pct, y = reorder(plot_lab, tp_pct), fill=field_uas_group, group=field_uas_group) ) + geom_col( width = 0.7, alpha=0.8 ) + geom_text( mapping = aes( label = scales::percent(ifelse(pct&gt;=0.12,pct,NA), accuracy = 1) , fontface = &quot;bold&quot; ) , position = position_stack(vjust = 0.5) , color = &quot;black&quot;, size = 2.3 ) + scale_fill_viridis_d(option = &quot;cividis&quot;) + scale_x_continuous(labels = scales::percent_format()) + labs( fill = &quot;&quot; , y = &quot;&quot; , x = &quot;Percent of Trees&quot; , title = &quot;UAS and Stem-Mapped Tree Validation Summary&quot; , subtitle = &quot;by overstory plot&quot; ) + theme_light() + theme( legend.position = &quot;top&quot; , legend.direction = &quot;horizontal&quot; , legend.title = element_text(size=7) , axis.title.x = element_text(size=10, face = &quot;bold&quot;) , axis.title.y = element_blank() , axis.text.x = element_blank() , axis.text.y = element_text(color = &quot;black&quot;,size=10, face = &quot;bold&quot;) , axis.ticks.x = element_blank() ) + guides( fill = guide_legend(reverse = T, override.aes = list(alpha = 0.9)) ) 7.3.2 F-score field_uas_comparison_plot %&gt;% dplyr::distinct(plot_lab, plot_f_score) %&gt;% ggplot( mapping = aes(x = plot_f_score, y = reorder(plot_lab, plot_f_score), fill=plot_f_score, label = scales::comma(plot_f_score, accuracy = 0.01)) ) + geom_vline( xintercept = field_uas_comparison_plot %&gt;% dplyr::distinct(plot_lab, plot_f_score) %&gt;% dplyr::pull(plot_f_score) %&gt;% median() , color = &quot;gray44&quot; , linetype = &quot;dashed&quot; ) + geom_col( width = 0.7, alpha=0.8 ) + geom_text( color = &quot;black&quot;, size = 3.5 , hjust = -0.1 ) + annotate( &quot;text&quot; , x = field_uas_comparison_plot %&gt;% dplyr::distinct(plot_lab, plot_f_score) %&gt;% dplyr::pull(plot_f_score) %&gt;% median() , y = 0 , label = paste0( &quot;median: &quot; , field_uas_comparison_plot %&gt;% dplyr::distinct(plot_lab, plot_f_score) %&gt;% dplyr::pull(plot_f_score) %&gt;% median() %&gt;% scales::comma(accuracy = 0.01) ) , hjust = -0.1 , vjust = -1 ) + scale_fill_viridis_c(option = &quot;mako&quot;, direction = -1) + labs( fill = &quot;&quot; , y = &quot;&quot; , x = &quot;F-Score&quot; , title = &quot;UAS and Stem-Mapped Tree F-Score Summary&quot; , subtitle = &quot;by overstory plot&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.title.x = element_text(size=10, face = &quot;bold&quot;) , axis.title.y = element_blank() , axis.text.x = element_blank() , axis.text.y = element_text(color = &quot;black&quot;,size=10, face = &quot;bold&quot;) , axis.ticks.x = element_blank() ) 7.3.3 Height vs. DBH of \\(Tp\\), \\(Co\\), \\(Om\\) field_uas_comparison %&gt;% dplyr::mutate( dbh_temp = dplyr::coalesce(field_dbh_in, uas_dbh_in) , ht_temp = dplyr::coalesce(field_tree_height_ft, uas_tree_height_ft) ) %&gt;% ggplot( mapping = aes(x = ht_temp, y = dbh_temp, color = field_uas_group) ) + geom_point( mapping = aes(shape = field_uas_group) , alpha=0.8 , size=2 ) + scale_color_viridis_d(option = &quot;cividis&quot;) + scale_x_continuous(breaks = scales::extended_breaks(n=8)) + scale_y_continuous(breaks = scales::extended_breaks(n=8)) + labs( color = &quot;detection&quot; , shape = &quot;detection&quot; , y = &quot;DBH (in)&quot; , x = &quot;Tree Ht. (ft)&quot; , title = &quot;UAS and Stem-Mapped Tree Validation Summary&quot; , subtitle = &quot;height and DBH relationship&quot; ) + theme_light() + theme( legend.position = &quot;top&quot; , legend.direction = &quot;horizontal&quot; , legend.title = element_blank() ) + guides( color = guide_legend(reverse = T, override.aes = list(alpha = 0.9, size = 5)) , shape = guide_legend(reverse = T, override.aes = list(alpha = 0.9, size = 5)) ) 7.3.4 Height and DBH Distribution \\(Tp\\), \\(Co\\), \\(Om\\) field_uas_comparison %&gt;% dplyr::mutate( dbh = dplyr::coalesce(field_dbh_in, uas_dbh_in) , height = dplyr::coalesce(field_tree_height_ft, uas_tree_height_ft) ) %&gt;% dplyr::select(dbh, height, field_uas_group) %&gt;% tidyr::pivot_longer(cols = -c(field_uas_group), names_to = &quot;metric&quot;, values_to = &quot;value&quot;) %&gt;% dplyr::group_by(field_uas_group,metric) %&gt;% dplyr::mutate( metric = dplyr::case_when( metric == &quot;dbh&quot; ~ &quot;DBH (in)&quot; , metric == &quot;height&quot; ~ &quot;Height (ft)&quot; ) , n_rows = dplyr::n() , plot_lab = paste0( field_uas_group ,&quot; (n=&quot;, scales::comma(n_rows,accuracy=1),&quot;)&quot; ) ) %&gt;% ggplot(mapping = aes(x = value, y = plot_lab, fill = field_uas_group)) + geom_violin(outlier.shape = NA) + geom_boxplot(width = 0.1, outlier.shape = NA) + facet_grid(cols = vars(metric), scales = &quot;free_x&quot;) + scale_fill_viridis_d(option = &quot;cividis&quot;) + scale_x_continuous(breaks = scales::extended_breaks(n=8)) + labs( fill = &quot;&quot; , y = &quot;&quot; , x = &quot;&quot; , title = &quot;UAS and Stem-Mapped Tree Validation Summary&quot; , subtitle = &quot;height and DBH distribution comparison&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.title.x = element_text(size=10, face = &quot;bold&quot;) , axis.title.y = element_blank() , axis.text.y = element_text(color = &quot;black&quot;,size=10, face = &quot;bold&quot;, hjust = 0) , strip.text = element_text(color = &quot;black&quot;, size = 12) , strip.background = element_rect(fill = &quot;gray88&quot;) ) 7.3.5 Detected Overstory (\\(TP\\)) Height Difference Detected overstory tree (\\(TP\\)) height reliability. Where overstory trees considered in this analysis had a tree height &gt;= 6.6 ft and a tree DBH &gt;= 5.0 in. field_uas_comparison %&gt;% dplyr::filter(field_uas_group == &quot;true positive&quot;) %&gt;% dplyr::group_by(plot_lab) %&gt;% dplyr::mutate( reorder_y = median(height_diff_pct, na.rm=T) , color_box = reorder_y&lt;0 , n_rows = dplyr::n() , plot_lab = paste0( plot_lab ,&quot; (n=&quot;, scales::comma(n_rows,accuracy=1),&quot;)&quot; ) ) %&gt;% ggplot(mapping = aes(x = height_diff_pct, y = reorder(plot_lab, reorder_y) )) + # height_diff_pct geom_vline(xintercept = 0, color = &quot;gray22&quot;) + geom_boxplot(mapping = aes(fill = color_box), alpha = 0.8, width = 0.7, outlier.shape = NA) + scale_fill_manual(values = c(&quot;steelblue&quot;, &quot;coral&quot;)) + geom_point(color = &quot;black&quot;, shape = &quot;.&quot;) + scale_x_continuous( labels = scales::percent_format() , breaks = scales::extended_breaks(n=8) , limits = c( -max(field_uas_comparison$abs_height_diff_pct, na.rm = T) , max(field_uas_comparison$abs_height_diff_pct, na.rm = T) ) ) + labs( fill = &quot;&quot; , y = &quot;&quot; , x = &quot;Percent Difference in Height&quot; , title = &quot;Detected Overstory Height Difference&quot; , subtitle = &quot;by overstory plot&quot; , caption = &quot;-values = UAS&lt;field | +values = UAS&gt;field&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.title.x = element_text(size=10, face = &quot;bold&quot;) , axis.title.y = element_blank() , axis.text.y = element_text(color = &quot;black&quot;,size=10, face = &quot;bold&quot;, hjust = 0) ) 7.3.6 Detected Overstory (\\(TP\\)) DBH Difference Detected overstory tree (\\(TP\\)) DBH reliability. Where overstory trees considered in this analysis had a tree height &gt;= 6.6 ft and a tree DBH &gt;= 5.0 in. field_uas_comparison %&gt;% dplyr::filter(field_uas_group == &quot;true positive&quot;) %&gt;% dplyr::group_by(plot_lab) %&gt;% dplyr::mutate( reorder_y = median(dbh_diff_pct, na.rm=T) , color_box = reorder_y&lt;0 , n_rows = dplyr::n() , plot_lab = paste0( plot_lab ,&quot; (n=&quot;, scales::comma(n_rows,accuracy=1),&quot;)&quot; ) ) %&gt;% ggplot(mapping = aes(x = dbh_diff_pct, y = reorder(plot_lab, reorder_y) )) + # dbh_diff_pct geom_vline(xintercept = 0, color = &quot;gray22&quot;) + geom_boxplot(mapping = aes(fill = color_box), alpha = 0.8, width = 0.7, outlier.shape = NA) + scale_fill_manual(values = c(&quot;steelblue&quot;, &quot;coral&quot;)) + geom_point(color = &quot;black&quot;, shape = &quot;.&quot;) + scale_x_continuous( labels = scales::percent_format() , breaks = scales::extended_breaks(n=8) , limits = c( -max(field_uas_comparison$abs_dbh_diff_pct, na.rm = T) , max(field_uas_comparison$abs_dbh_diff_pct, na.rm = T) ) ) + labs( fill = &quot;&quot; , y = &quot;&quot; , x = &quot;Percent Difference in DBH&quot; , title = &quot;Detected Overstory DBH Difference&quot; , subtitle = &quot;by overstory plot&quot; , caption = &quot;-values = UAS&lt;field | +values = UAS&gt;field&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.title.x = element_text(size=10, face = &quot;bold&quot;) , axis.title.y = element_blank() , axis.text.y = element_text(color = &quot;black&quot;,size=10, face = &quot;bold&quot;, hjust = 0) ) 7.3.7 Detected Overstory (\\(TP\\)) Reliability Overstory trees considered in this analysis had a tree height &gt;= 6.6 ft and a tree DBH &gt;= 5.0 in. dbh_f_temp = field_uas_comparison %&gt;% dplyr::filter(field_uas_group==&quot;true positive&quot;) %&gt;% dplyr::pull(field_dbh_in) dbh_u_temp = field_uas_comparison %&gt;% dplyr::filter(field_uas_group==&quot;true positive&quot;) %&gt;% dplyr::pull(uas_dbh_in) ht_f_temp = field_uas_comparison %&gt;% dplyr::filter(field_uas_group==&quot;true positive&quot;) %&gt;% dplyr::pull(field_tree_height_ft) ht_u_temp = field_uas_comparison %&gt;% dplyr::filter(field_uas_group==&quot;true positive&quot;) %&gt;% dplyr::pull(uas_tree_height_ft) data.frame( mae_dbh = Metrics::mae( dbh_f_temp , dbh_u_temp ) , mape_dbh = Metrics::mape( dbh_f_temp , dbh_u_temp ) , rmse_dbh = Metrics::rmse( dbh_f_temp , dbh_u_temp ) ## height , mae_height = Metrics::mae( ht_f_temp , ht_u_temp ) , mape_height = Metrics::mape( ht_f_temp , ht_u_temp ) , rmse_height = Metrics::rmse( ht_f_temp , ht_u_temp ) ) %&gt;% tidyr::pivot_longer(dplyr::everything()) %&gt;% tidyr::separate_wider_delim(cols = name, delim = &quot;_&quot;, names = c(&quot;error&quot;, &quot;metric&quot;)) %&gt;% tidyr::pivot_wider(names_from = error, values_from = value) %&gt;% dplyr::mutate( metric = dplyr::case_when( metric == &quot;dbh&quot; ~ &quot;DBH (in)&quot; , metric == &quot;height&quot; ~ &quot;Height (ft)&quot; ) , n = field_uas_comparison %&gt;% dplyr::filter(field_uas_group==&quot;true positive&quot;) %&gt;% nrow() ) %&gt;% kableExtra::kbl( caption = &quot;Detected overstory tree height and DBH prediction performance&quot; , col.names = c( &quot; &quot; , &quot;Mean Abs. Error&quot; , &quot;Mean Abs. Percent Error&quot; , &quot;Root Mean Squared Error&quot; , &quot;N&quot; ) , digits = 2 ) %&gt;% kableExtra::kable_styling() Table 7.2: Detected overstory tree height and DBH prediction performance Mean Abs. Error Mean Abs. Percent Error Root Mean Squared Error N DBH (in) 1.39 0.16 1.91 304 Height (ft) 1.20 0.03 1.61 304 7.3.8 Detected Overstory (\\(TP\\)) Distribution Comparison field_uas_comparison %&gt;% dplyr::filter(field_uas_group==&quot;true positive&quot;) %&gt;% dplyr::select(c( tidyselect::ends_with(&quot;_dbh_in&quot;) , tidyselect::ends_with(&quot;_height_ft&quot;) )) %&gt;% dplyr::rename_with( .fn = function(x){dplyr::case_when( stringr::str_ends(x,&quot;_dbh_in&quot;) ~ stringr::str_replace(x,&quot;_dbh_in&quot;,&quot;_dbh&quot;) , stringr::str_ends(x,&quot;_tree_height_ft&quot;) ~ stringr::str_replace(x,&quot;_tree_height_ft&quot;,&quot;_height&quot;) , TRUE ~ x )} ) %&gt;% tidyr::pivot_longer(dplyr::everything()) %&gt;% tidyr::separate_wider_delim( cols = name , delim = &quot;_&quot; , names = c(&quot;source&quot;, &quot;metric&quot;) ) %&gt;% dplyr::mutate( metric = dplyr::case_when( metric == &quot;dbh&quot; ~ &quot;DBH (in)&quot; , metric == &quot;height&quot; ~ &quot;Height (ft)&quot; ) , source = dplyr::case_when( source == &quot;uas&quot; ~ &quot;UAS&quot; , source == &quot;field&quot; ~ &quot;Stem Map&quot; ) , n = field_uas_comparison %&gt;% dplyr::filter(field_uas_group==&quot;true positive&quot;) %&gt;% nrow() ) %&gt;% ggplot(mapping = aes(x = value, y = source )) + geom_boxplot(mapping = aes(fill = source), alpha = 0.8, width = 0.7, outlier.shape = NA) + # geom_point(color = &quot;black&quot;, shape = &quot;.&quot;) + facet_grid(cols = vars(metric), scales = &quot;free_x&quot;) + scale_fill_manual(values = c(&quot;seagreen&quot;, &quot;slateblue&quot;)) + labs( fill = &quot;&quot; , y = &quot;&quot; , x = &quot;&quot; , title = &quot;Detected Overstory Distribution Comparison&quot; , subtitle = paste0( &quot;tree height &gt;= &quot; , scales::comma(min_tree_height_m*3.28, accuracy = 0.1) , &quot; ft and tree DBH &gt;= &quot; , scales::comma(min_tree_dbh_cm*0.394, accuracy = 0.1) , &quot; in&quot; ) ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.title.x = element_text(size=10, face = &quot;bold&quot;) , axis.title.y = element_blank() , axis.text.y = element_text(color = &quot;black&quot;,size=10, face = &quot;bold&quot;, hjust = 0) , strip.text = element_text(color = &quot;black&quot;, size = 12) , strip.background = element_rect(fill = &quot;gray88&quot;) ) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
