[["index.html", "Black Hills Experimental Forest UAS Mission Data Summary Section 1 Introduction", " Black Hills Experimental Forest UAS Mission Data Summary George Woolsey 27 February, 2024 Section 1 Introduction This project summarizes processed point cloud data created using structure from motion (SfM) photogrammetry methods on imagery collected from Unmanned Aircraft System (UAS) flights completed in June 2023. UAS imagery was collected using a DJI Phantom 4 Pro equipped with a 20 megapixel metal oxide semiconductor red-green-blue camera at a fixed 8.8 mm focal length. Flights followed a pre-programmed serpentine flight paths at an altitude of 120 m above ground level, using a nadir camera orientation, with 80% forward and side image overlap.The UAV imagery was processed in Agisoft Metashape using the routine outlined by Tinkham and Swayze (2021) to produce an SfM point cloud for optimized tree detection. The SfM-derived point cloud was processed using the methods outlined by Swayze and Tinkham (2022). Specifically, this script which is outlined in detail at its parent Github repository was used to process the raw point cloud data. UAS point cloud files (laz files) for this project were processed in two batches with the outputs combined using this script from the same repository. SfM techniques using UAS data reliably identify most tree locations and heights in open-canopied forests. However, their ability to characterize diameter at breast height (DBH) is limited to estimates of a fraction of trees within the area. SfM-derived DBH was estimated at the tree level following the methods outlined by Tinkham et al. (2022). "],["objective.html", "Section 2 Objective", " Section 2 Objective The objective of this analysis is to summarize forest stand characteristics using the UAS-derived tree list which includes tree location, height, and DBH measurements. Forest stands in this analysis include stands which were harvested in 2021 using single-tree and group-selection silvicultural prescriptions. The Forest Activity Tracking System (FACTS) database maintained by the U.S. Department of Agriculture, Forest Service (USFS) was used to delineate georeferenced boundaries of forest harvest activities. "],["data_prep.html", "Section 3 Data Preparation 3.1 Data Load 3.2 Load orthomosaic rasters", " Section 3 Data Preparation 3.1 Data Load Data loaded includes outputs from the UAS point cloud processing script: raw_las_ctg_info.gpkg, final_detected_crowns.gpkg, final_detected_tree_tops.gpkg. Also, loaded are experimental forest boundaries and timber harvest boundaries from the USFS FACTS database. # where is the processed data from point_cloud_processing_run_combine.R ? input_dir = &quot;../data/point_cloud_processing_BHEF_202306_combined&quot; # set output directory delivery_dir = &quot;../data/delivery&quot; dir.create(delivery_dir, showWarnings = FALSE) ### read data from point_cloud_processing #rasters dtm_rast = terra::rast(paste0(input_dir, &quot;/dtm_1m.tif&quot;)) chm_rast = terra::rast(paste0(input_dir, &quot;/chm_0.25m.tif&quot;)) # crowns = terra::rast(paste0(input_dir, &quot;/top_down_detected_tree_crowns.tif&quot;)) # las extent las_ctg_dta = sf::st_read(paste0(input_dir, &quot;/raw_las_ctg_info.gpkg&quot;)) # vectors # crown polygons crowns_sf_with_dbh = sf::st_read(paste0(input_dir, &quot;/final_detected_crowns.gpkg&quot;)) %&gt;% dplyr::select(-c(basal_area_ft2)) %&gt;% dplyr::rename( reg_est_lower_dbh_cm = reg_est_dbh_cm_lower , reg_est_upper_dbh_cm = reg_est_dbh_cm_upper ) # tree top points treetops_sf_with_dbh = sf::st_read(paste0(input_dir, &quot;/final_detected_tree_tops.gpkg&quot;)) %&gt;% dplyr::select(-c(basal_area_ft2)) %&gt;% dplyr::rename( reg_est_lower_dbh_cm = reg_est_dbh_cm_lower , reg_est_upper_dbh_cm = reg_est_dbh_cm_upper ) # height range for use in estimation height_range = dplyr::tibble( tree_height_m = seq( from = 0 , to = round(max(treetops_sf_with_dbh$tree_height_m)*1.05,0) , by = 0.1 # by 0.1 m increments ) ) # set crs proj_crs = sf::st_crs(las_ctg_dta) # read data from FACTS # harvests harvests = sf::st_read(&quot;../data/bhef_harvests.gpkg&quot;) %&gt;% dplyr::filter( year_id == 2021 # year_id &gt;= year(Sys.time()) - 15 &amp; !(treatment_type_grp %in% c(&quot;Improvement/Liberation Cut&quot;, &quot;Other&quot;, &quot;Sanitation Cut&quot;)) ) %&gt;% sf::st_transform(proj_crs) # bhef bounds bhef_boundary = sf::st_read(&quot;../data/bhef_boundary.gpkg&quot;) %&gt;% sf::st_transform(proj_crs) Define a function to convert columns in data frame from metric to imperial calc_imperial_units_fn &lt;- function(df) { df %&gt;% # convert to imperial units dplyr::mutate( dplyr::across( .cols = tidyselect::ends_with(&quot;_cm&quot;) , ~ .x * 0.394 , .names = &quot;{.col}_in&quot; ) , dplyr::across( .cols = tidyselect::ends_with(&quot;_m&quot;) , ~ .x * 3.28 , .names = &quot;{.col}_ft&quot; ) , dplyr::across( .cols = tidyselect::ends_with(&quot;_m2_per_ha&quot;) , ~ .x * 4.359 , .names = &quot;{.col}_ftac&quot; ) , dplyr::across( .cols = tidyselect::ends_with(&quot;_per_ha&quot;) &amp; !tidyselect::ends_with(&quot;_m2_per_ha&quot;) , ~ .x * 0.405 , .names = &quot;{.col}_ac&quot; ) , dplyr::across( .cols = tidyselect::ends_with(&quot;_area_ha&quot;) , ~ .x * 2.471 , .names = &quot;{.col}_ac&quot; ) , dplyr::across( .cols = tidyselect::ends_with(&quot;_m2&quot;) , ~ .x * 10.764 , .names = &quot;{.col}_ft2&quot; ) ) %&gt;% dplyr::rename_with( .fn = function(x){dplyr::case_when( stringr::str_ends(x,&quot;_cm_in&quot;) ~ stringr::str_replace(x,&quot;_cm_in&quot;,&quot;_in&quot;) , stringr::str_ends(x,&quot;_m_ft&quot;) ~ stringr::str_replace(x,&quot;_m_ft&quot;,&quot;_ft&quot;) , stringr::str_ends(x,&quot;_m2_per_ha_ftac&quot;) ~ stringr::str_replace(x,&quot;_m2_per_ha_ftac&quot;,&quot;_ft2_per_ac&quot;) , stringr::str_ends(x,&quot;_per_ha_ac&quot;) ~ stringr::str_replace(x,&quot;_per_ha_ac&quot;,&quot;_per_ac&quot;) , stringr::str_ends(x,&quot;_area_ha_ac&quot;) ~ stringr::str_replace(x,&quot;_area_ha_ac&quot;,&quot;_area_ac&quot;) , stringr::str_ends(x,&quot;_m2_ft2&quot;) ~ stringr::str_replace(x,&quot;_m2_ft2&quot;,&quot;_ft2&quot;) , TRUE ~ x )} ) } 3.2 Load orthomosaic rasters Orthomosaic tif files from the UAS flight imagery that were created in Agisoft Metashape are loaded and stitched together via terra::mosaic. if(!file.exists(paste0(delivery_dir,&quot;/BHEF_202306_Full_RBG.tif&quot;))){ # read list of orthos ortho_list_temp = list.files(&quot;../data/ortho/&quot;, pattern = &quot;.*\\\\.(tif|tiff)$&quot;, full.names = T)[] %&gt;% purrr::map(function(x){terra::rast(x)}) # ortho_list_temp[[1]] %&gt;% # terra::aggregate(20) %&gt;% # terra::plotRGB(r = 1, g = 2, b = 3, stretch = &quot;hist&quot;, colNA = &quot;transparent&quot;) ####### ensure the resolution of the rasters matches # terra::res(ortho_list_temp[[1]]) ## function change_res_fn = function(r, my_res=1){ r2 = r terra::res(r2) = my_res r2 = terra::resample(r, r2) return(r2) } ## apply the function ortho_list_temp = 1:length(ortho_list_temp) %&gt;% purrr::map(function(x){change_res_fn(ortho_list_temp[[x]], my_res=0.25)}) # terra::res(ortho_list_temp[[1]]) # ortho_list_temp[[1]] %&gt;% # terra::aggregate(2) %&gt;% # terra::plotRGB(r = 1, g = 2, b = 3, stretch = &quot;hist&quot;, colNA = &quot;transparent&quot;) ######## mosaic the raster list ortho_rast = terra::mosaic( terra::sprc(ortho_list_temp) , fun = &quot;min&quot; # min only thing that works ) ## write the mosaic terra::writeRaster(ortho_rast, filename = paste0(delivery_dir,&quot;/BHEF_202306_Full_RBG.tif&quot;), overwrite = T) }else{ ortho_rast = terra::rast(paste0(delivery_dir,&quot;/BHEF_202306_Full_RBG.tif&quot;)) } # ortho_rast %&gt;% # terra::aggregate(4) %&gt;% # terra::plotRGB(r = 1, g = 2, b = 3, stretch = &quot;lin&quot;, colNA = &quot;transparent&quot;) "],["local_mod.html", "Section 4 Local DBH to Height Model 4.1 Random Forest Model 4.2 Linear Model 4.3 Quadratic Model 4.4 No Intercept Quadratic Model 4.5 Nonlinear Power Model 4.6 Nonlinear Weibull Model 4.7 Model Comparison 4.8 Update DBH to best model 4.9 Combine harvest units with tree locations", " Section 4 Local DBH to Height Model 4.1 Random Forest Model The UAS point cloud processing script used a random forest model to estimate tree DBH based on the sample of DBH values extracted from the point cloud (outlined in detail here. This random forest model included tree height (m), crown area (m2), minimum crown height (m), and local tree competition metrics to estimate missing DBH values. Using methods outlined by Tinkham et al. (2022), local competition metrics included the distance to the nearest neighbor, trees ha1 within a 5 m radius, and the relative tree height within a 5 m radius. A 5 m radius was selected as it represents a distance slightly less than the point at which two mature ponderosa pine trees in the region would begin to have interlocking crowns, representing a proxy for direct competition. The relative tree height within a 5 m radius was estimated using: \\[ \\textrm{Relative Height} = \\frac{\\textrm{Height}}{\\textrm{Height}_\\textrm{max}} \\times 100 \\] , where \\(\\textrm{Height}\\) is the height of the subject tree and \\(\\textrm{Height}_\\textrm{max}\\) is the height of the tallest tree within a 5 m radius of the subject tree. 4.1.1 Training vs Non-Training DBH ### plot plt_rf = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) %&gt;% dplyr::bind_rows( treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==F) %&gt;% dplyr::slice_sample(prop = 0.15) ) %&gt;% ggplot( mapping = aes( x=tree_height_m, y = dbh_cm , color = is_training_data , fill = is_training_data , group = is_training_data ) ) + geom_point( alpha = 0.6 , size = 0.7 , color = &quot;transparent&quot; , shape = 21 , show.legend = F ) + geom_smooth( method = &quot;loess&quot; , se = F , span = 1 , lwd = 1.5 , show.legend = T ) + scale_color_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_fill_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_y_continuous(limits = c(0,max(treetops_sf_with_dbh$dbh_cm)*1.02)) + scale_x_continuous(limits = c(0,max(treetops_sf_with_dbh$tree_height_m)*1.02)) + labs( y = &quot;DBH (cm)&quot; , x = &quot;Tree Ht. (m)&quot; , title = &quot;Random Forest Model&quot; , subtitle = &quot;SfM-derived tree height and DBH relationship&quot; , color = &quot;Training Data&quot; , fill = &quot;Training Data&quot; ) + theme_light() + theme( legend.position = &quot;bottom&quot; , legend.direction = &quot;horizontal&quot; ) + guides( color = guide_legend(override.aes = list(shape = 15, lwd = 6, size = 6, alpha = 1)) ) # plot plt_rf 4.2 Linear Model Tinkham et al. (2022) found the simple linear form resulted in the best estimates for both tree and stand level summarizations: \\[\\begin{align*} DBH_{i} &amp;\\sim {\\sf Gamma} \\bigl(g(\\beta_0, \\beta_1, Height_{i}), shape \\bigr) \\\\ g(\\beta_0, \\beta_1, Height_{i}) &amp;= {\\exp \\bigl(\\beta_0 + \\beta_1 \\cdot Height_{i}\\bigr)} \\\\ \\beta_{0} &amp;\\sim {\\sf Normal} (0,10) \\\\ \\beta_{1} &amp;\\sim {\\sf Normal} (0,10) \\\\ shape &amp;\\sim {\\sf Gamma} (0.01,0.01) \\end{align*}\\] , where \\(i\\) is the individual tree estimate from UAS SfM data. The \\(\\sf Gamma\\) response distribution represents \\(DBH_{i}\\) as strictly non-negative. # population model with no random effects (i.e. no group-level variation) # Gamma distribution for strictly positive response variable dbh mod_lin = brms::brm( formula = dbh_cm ~ 1 + tree_height_m , data = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) , family = brms::brmsfamily(&quot;Gamma&quot;, link = &quot;identity&quot;) , prior = c(prior(gamma(0.01, 0.01), class = shape)) , iter = 3000 , file = &quot;../data/mod_lin&quot; ) # plot(mod_lin) # summary(mod_lin) # plot(brms::conditional_effects(mod_lin), points = T) # compute and save the WAIC information for the next three models mod_lin = brms::add_criterion(mod_lin, c(&quot;loo&quot;, &quot;waic&quot;)) # predict values over range pred_mod_lin = predict( mod_lin , newdata = height_range , probs = c(.05, .95) ) %&gt;% dplyr::as_tibble() %&gt;% dplyr::rename( lower_b = 3, upper_b = 4 ) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::select(-c(est.error)) %&gt;% dplyr::bind_cols(height_range) %&gt;% dplyr::mutate(tree_height_m_tnth = round(tree_height_m,1) %&gt;% as.character()) # attach predicted values to original data treetops_sf_with_dbh = treetops_sf_with_dbh %&gt;% dplyr::mutate(tree_height_m_tnth = round(tree_height_m,1) %&gt;% as.character()) %&gt;% dplyr::left_join( pred_mod_lin %&gt;% dplyr::select(tree_height_m_tnth, estimate) , by = dplyr::join_by(tree_height_m_tnth) ) %&gt;% dplyr::mutate( mod_lin_est_dbh_cm = ifelse(is_training_data == T, dbh_cm, estimate) ) %&gt;% dplyr::select(-c(estimate, tree_height_m_tnth)) gc() 4.2.1 Model Parameter Estimates Simple linear form: \\[ DBH_i = \\beta_0 + \\beta_1 \\cdot Height_i \\] , where \\(i\\) is the individual tree estimate from UAS SfM data # parameter estimates mod_lin_sum_temp = brms::posterior_summary(mod_lin) %&gt;% as.data.frame() %&gt;% tibble::rownames_to_column(var = &quot;parameter&quot;) %&gt;% dplyr::filter(stringr::str_starts(parameter, &quot;b_&quot;)) %&gt;% # | parameter == &quot;shape&quot;) %&gt;% dplyr::rename_with(tolower) # table mod_lin_sum_temp %&gt;% kableExtra::kbl(digits = 4) %&gt;% kableExtra::kable_styling() parameter estimate est.error q2.5 q97.5 b_Intercept -3.7689 0.4497 -4.6500 -2.8868 b_tree_height_m 2.3505 0.0312 2.2907 2.4120 4.2.2 SfM-derived Height to DBH Allometry # plot predictions with data ggplot( data = pred_mod_lin, mapping = aes(x = tree_height_m) ) + geom_point( data = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) , mapping = aes(y = dbh_cm) , color = &quot;firebrick&quot; ) + geom_ribbon( mapping = aes(ymin = lower_b, ymax = upper_b) , fill = &quot;gray88&quot; , alpha = 0.5 ) + geom_line( aes(y = estimate) , color = &quot;gray33&quot; , lwd = 1 ) + labs( y = &quot;DBH (cm)&quot; , x = &quot;Tree Ht. (m)&quot; , title = &quot;Local height to DBH allometry from SfM-extracted DBH samples&quot; , subtitle = latex2exp::TeX(paste0( &quot;$DBH = &quot; , mod_lin_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_Intercept&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot; + &quot; , mod_lin_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_tree_height_m&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height&quot; )) ) + theme_light() + theme(legend.position = &quot;none&quot;) 4.2.3 Training vs Non-Training DBH ### plot plt_lin = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) %&gt;% dplyr::bind_rows( treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==F) %&gt;% dplyr::slice_sample(prop = 0.15) ) %&gt;% ggplot( mapping = aes( x=tree_height_m, y = mod_lin_est_dbh_cm , color = is_training_data , fill = is_training_data , group = is_training_data ) ) + geom_smooth( method = &quot;loess&quot; , se = F , span = 1 , lwd = 1.5 , show.legend = T ) + geom_point( alpha = 0.6 , size = 0.7 , color = &quot;transparent&quot; , shape = 21 , show.legend = F ) + annotate( &quot;text&quot;, x = 0, y = max(treetops_sf_with_dbh$dbh_cm) , label = latex2exp::TeX(paste0( &quot;$DBH = &quot; , mod_lin_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_Intercept&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot; + &quot; , mod_lin_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_tree_height_m&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height&quot; )) , parse = T , hjust = 0 ) + scale_color_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_fill_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_y_continuous(limits = c(0,max(treetops_sf_with_dbh$dbh_cm)*1.02)) + scale_x_continuous(limits = c(0,max(treetops_sf_with_dbh$tree_height_m)*1.02)) + labs( y = &quot;DBH (cm)&quot; , x = &quot;Tree Ht. (m)&quot; , title = &quot;Linear Model&quot; , subtitle = &quot;SfM-derived tree height and DBH relationship&quot; , color = &quot;Training Data&quot; , fill = &quot;Training Data&quot; ) + theme_light() + theme( legend.position = &quot;bottom&quot; , legend.direction = &quot;horizontal&quot; ) + guides( color = guide_legend(override.aes = list(shape = 15, lwd = 6, size = 6, alpha = 1)) ) # plot plt_lin 4.3 Quadratic Model A quadratic linear model with the inclusion of \\(Height_{i}^{2}\\) in the model allows us to account for a nonlinear (e.g. parabolic) relationship between DBH and tree height. \\[\\begin{align*} DBH_{i} &amp;\\sim {\\sf Gamma} \\bigl(g(\\beta_0, \\beta_1, \\beta_2, Height_{i}), shape \\bigr) \\\\ g(\\beta_0, \\beta_1, \\beta_2, Height_{i}) &amp;= {\\exp \\bigl(\\beta_0 + \\beta_1 \\cdot Height_{i} + \\beta_2 \\cdot Height_{i}^{2}\\bigr)} \\\\ \\beta_{0} &amp;\\sim {\\sf Normal} (0,10) \\\\ \\beta_{1} &amp;\\sim {\\sf Normal} (0,10) \\\\ \\beta_{2} &amp;\\sim {\\sf Normal} (0,10) \\\\ shape &amp;\\sim {\\sf Gamma} (0.01,0.01) \\end{align*}\\] , where \\(i\\) is the individual tree estimate from UAS SfM data. The \\(\\sf Gamma\\) response distribution represents \\(DBH_{i}\\) as strictly non-negative. # population model with no random effects (i.e. no group-level variation) # Gamma distribution for strictly positive response variable dbh mod_quad = brms::brm( formula = dbh_cm ~ 1 + tree_height_m + I(tree_height_m^2) , data = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) , family = brms::brmsfamily(&quot;Gamma&quot;, link = &quot;log&quot;) , prior = c(prior(gamma(0.01, 0.01), class = shape)) , iter = 3000 , file = &quot;../data/mod_quad&quot; ) # plot(mod_quad) # summary(mod_quad) # plot(brms::conditional_effects(mod_quad), points = T) # compute and save the WAIC information for the next three models mod_quad = brms::add_criterion(mod_quad, c(&quot;loo&quot;, &quot;waic&quot;)) # predict values over range pred_mod_quad = predict( mod_quad , newdata = height_range , probs = c(.05, .95) ) %&gt;% dplyr::as_tibble() %&gt;% dplyr::rename( lower_b = 3, upper_b = 4 ) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::select(-c(est.error)) %&gt;% dplyr::bind_cols(height_range) %&gt;% dplyr::mutate(tree_height_m_tnth = round(tree_height_m,1) %&gt;% as.character()) # attach predicted values to original data treetops_sf_with_dbh = treetops_sf_with_dbh %&gt;% dplyr::mutate(tree_height_m_tnth = round(tree_height_m,1) %&gt;% as.character()) %&gt;% dplyr::left_join( pred_mod_quad %&gt;% dplyr::select(tree_height_m_tnth, estimate) , by = dplyr::join_by(tree_height_m_tnth) ) %&gt;% dplyr::mutate( mod_quad_est_dbh_cm = ifelse(is_training_data == T, dbh_cm, estimate) ) %&gt;% dplyr::select(-c(estimate, tree_height_m_tnth)) gc() 4.3.1 Model Parameter Estimates Quadratic linear model form: \\[ DBH_{i} = \\exp\\bigl(\\beta_0 + \\beta_1 \\cdot Height_{i} + \\beta_2 \\cdot Height_{i}^{2} \\bigr) \\] , where \\(i\\) is the individual tree estimate from UAS SfM data # parameter estimates mod_quad_sum_temp = brms::posterior_summary(mod_quad) %&gt;% as.data.frame() %&gt;% tibble::rownames_to_column(var = &quot;parameter&quot;) %&gt;% dplyr::filter(stringr::str_starts(parameter, &quot;b_&quot;)) %&gt;% # | parameter == &quot;shape&quot;) %&gt;% dplyr::rename_with(tolower) # dplyr::mutate( # dplyr::across(.cols = tidyselect::where(is.numeric), .fns = exp) # ) # table mod_quad_sum_temp %&gt;% kableExtra::kbl(digits = 4) %&gt;% kableExtra::kable_styling() parameter estimate est.error q2.5 q97.5 b_Intercept 1.8837 0.6399 1.4717 3.8981 b_tree_height_m 0.1298 0.0793 -0.1194 0.1807 b_Itree_height_mE2 -0.0018 0.0024 -0.0033 0.0057 4.3.2 SfM-derived Height to DBH Allometry # predict and put estimates in a data frame predict( mod_quad , newdata = height_range , probs = c(.05, .95) ) %&gt;% dplyr::as_tibble() %&gt;% dplyr::rename( lower_b = 3, upper_b = 4 ) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::select(-c(est.error)) %&gt;% dplyr::bind_cols(height_range) %&gt;% # plot predictions with data ggplot( mapping = aes(x = tree_height_m) ) + geom_point( data = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) , mapping = aes(y = dbh_cm) , color = &quot;firebrick&quot; ) + geom_ribbon( mapping = aes(ymin = lower_b, ymax = upper_b) , fill = &quot;gray88&quot; , alpha = 0.5 ) + geom_line( aes(y = estimate) , color = &quot;gray33&quot; , lwd = 1 ) + labs( y = &quot;DBH (cm)&quot; , x = &quot;Tree Ht. (m)&quot; , title = &quot;Local height to DBH allometry from SfM-extracted DBH samples&quot; , subtitle = latex2exp::TeX(paste0( &quot;$DBH = \\\\exp(&quot; , mod_quad_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_Intercept&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot; + &quot; , mod_quad_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_tree_height_m&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height&quot; , &quot; + &quot; , mod_quad_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_Itree_height_mE2&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height^2)$&quot; )) ) + theme_light() + theme(legend.position = &quot;none&quot;) 4.3.3 Training vs Non-Training DBH ### plot plt_quad = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) %&gt;% dplyr::bind_rows( treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==F) %&gt;% dplyr::slice_sample(prop = 0.15) ) %&gt;% ggplot( mapping = aes( x=tree_height_m, y = mod_quad_est_dbh_cm , color = is_training_data , fill = is_training_data , group = is_training_data ) ) + geom_smooth( method = &quot;loess&quot; , se = F , span = 1 , lwd = 1.5 , show.legend = T ) + geom_point( alpha = 0.6 , size = 0.7 , color = &quot;transparent&quot; , shape = 21 , show.legend = F ) + annotate( &quot;text&quot;, x = 0, y = max(treetops_sf_with_dbh$dbh_cm) , label = latex2exp::TeX(paste0( &quot;$DBH = \\\\exp(&quot; , mod_quad_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_Intercept&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot; + &quot; , mod_quad_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_tree_height_m&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height&quot; , &quot; + &quot; , mod_quad_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_Itree_height_mE2&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height^2)$&quot; )) , parse = T , hjust = 0 ) + scale_color_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_fill_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_y_continuous(limits = c(0,max(treetops_sf_with_dbh$dbh_cm)*1.02)) + scale_x_continuous(limits = c(0,max(treetops_sf_with_dbh$tree_height_m)*1.02)) + labs( y = &quot;DBH (cm)&quot; , x = &quot;Tree Ht. (m)&quot; , title = &quot;Quadratic Model&quot; , subtitle = &quot;SfM-derived tree height and DBH relationship&quot; , color = &quot;Training Data&quot; , fill = &quot;Training Data&quot; ) + theme_light() + theme( legend.position = &quot;bottom&quot; , legend.direction = &quot;horizontal&quot; ) + guides( color = guide_legend(override.aes = list(shape = 15, lwd = 6, size = 6, alpha = 1)) ) # plot plt_quad 4.4 No Intercept Quadratic Model A quadratic linear model with the inclusion of \\(Height_{i}^{2}\\) in the model allows us to account for a nonlinear (e.g. parabolic) relationship between DBH and tree height. Forcing the intercept to \\(0\\) allows for the model to better account for the minimum tree height threshold set at 2 m in the point cloud processing workflow. \\[\\begin{align*} DBH_{i} &amp;\\sim {\\sf Gamma} \\bigl(g(\\beta_1, \\beta_2, Height_{i}), shape \\bigr) \\\\ g(\\beta_1, \\beta_2, Height_{i}) &amp;= {\\exp \\bigl(0 + \\beta_1 \\cdot Height_{i} + \\beta_2 \\cdot Height_{i}^{2}\\bigr)} \\\\ \\beta_{1} &amp;\\sim {\\sf Normal} (0,10) \\\\ \\beta_{2} &amp;\\sim {\\sf Normal} (0,10) \\\\ shape &amp;\\sim {\\sf Gamma} (0.01,0.01) \\end{align*}\\] , where \\(i\\) is the individual tree estimate from UAS SfM data. The \\(\\sf Gamma\\) response distribution represents \\(DBH_{i}\\) as strictly non-negative. # population model with no random effects (i.e. no group-level variation) # Gamma distribution for strictly positive response variable dbh mod_quad_noint = brms::brm( formula = dbh_cm ~ 0 + tree_height_m + I(tree_height_m^2) , data = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) , family = brms::brmsfamily(&quot;Gamma&quot;, link = &quot;log&quot;) , prior = c(prior(gamma(0.01, 0.01), class = shape)) , iter = 3000 , file = &quot;../data/mod_quad_noint&quot; ) # plot(mod_quad_noint) # summary(mod_quad_noint) # plot(brms::conditional_effects(mod_quad_noint), points = T) # compute and save the WAIC information for the next three models mod_quad_noint = brms::add_criterion(mod_quad_noint, c(&quot;loo&quot;, &quot;waic&quot;)) # predict values over range pred_mod_quad_noint = predict( mod_quad_noint , newdata = height_range , probs = c(.05, .95) ) %&gt;% dplyr::as_tibble() %&gt;% dplyr::rename( lower_b = 3, upper_b = 4 ) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::select(-c(est.error)) %&gt;% dplyr::bind_cols(height_range) %&gt;% dplyr::mutate(tree_height_m_tnth = round(tree_height_m,1) %&gt;% as.character()) # attach predicted values to original data treetops_sf_with_dbh = treetops_sf_with_dbh %&gt;% dplyr::mutate(tree_height_m_tnth = round(tree_height_m,1) %&gt;% as.character()) %&gt;% dplyr::left_join( pred_mod_quad_noint %&gt;% dplyr::select(tree_height_m_tnth, estimate) , by = dplyr::join_by(tree_height_m_tnth) ) %&gt;% dplyr::mutate( mod_quad_noint_est_dbh_cm = ifelse(is_training_data == T, dbh_cm, estimate) ) %&gt;% dplyr::select(-c(estimate, tree_height_m_tnth)) gc() 4.4.1 Model Parameter Estimates No intercept quadratic linear model form: \\[ DBH_{i} = \\exp\\bigl( 0 + \\beta_1 \\cdot Height_{i} + \\beta_2 \\cdot Height_{i}^{2} \\bigr) \\] , where \\(i\\) is the individual tree estimate from UAS SfM data # parameter estimates mod_quad_noint_sum_temp = brms::posterior_summary(mod_quad_noint) %&gt;% as.data.frame() %&gt;% tibble::rownames_to_column(var = &quot;parameter&quot;) %&gt;% dplyr::filter(stringr::str_starts(parameter, &quot;b_&quot;)) %&gt;% # | parameter == &quot;shape&quot;) %&gt;% dplyr::rename_with(tolower) # dplyr::mutate( # dplyr::across(.cols = tidyselect::where(is.numeric), .fns = exp) # ) # table mod_quad_noint_sum_temp %&gt;% kableExtra::kbl(digits = 4) %&gt;% kableExtra::kable_styling() parameter estimate est.error q2.5 q97.5 b_tree_height_m 0.3561 0.0013 0.3536 0.3587 b_Itree_height_mE2 -0.0082 0.0001 -0.0084 -0.0081 4.4.2 SfM-derived Height to DBH Allometry # predict and put estimates in a data frame predict( mod_quad_noint , newdata = height_range , probs = c(.05, .95) ) %&gt;% dplyr::as_tibble() %&gt;% dplyr::rename( lower_b = 3, upper_b = 4 ) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::select(-c(est.error)) %&gt;% dplyr::bind_cols(height_range) %&gt;% # plot predictions with data ggplot( mapping = aes(x = tree_height_m) ) + geom_point( data = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) , mapping = aes(y = dbh_cm) , color = &quot;firebrick&quot; ) + geom_ribbon( mapping = aes(ymin = lower_b, ymax = upper_b) , fill = &quot;gray88&quot; , alpha = 0.5 ) + geom_line( aes(y = estimate) , color = &quot;gray33&quot; , lwd = 1 ) + labs( y = &quot;DBH (cm)&quot; , x = &quot;Tree Ht. (m)&quot; , title = &quot;Local height to DBH allometry from SfM-extracted DBH samples&quot; , subtitle = latex2exp::TeX(paste0( &quot;$DBH = \\\\exp(0&quot; , &quot; + &quot; , mod_quad_noint_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_tree_height_m&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height&quot; , &quot; + &quot; , mod_quad_noint_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_Itree_height_mE2&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height^2)$&quot; )) ) + theme_light() + theme(legend.position = &quot;none&quot;) 4.4.3 Training vs Non-Training DBH ### plot plt_quad_noint = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) %&gt;% dplyr::bind_rows( treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==F) %&gt;% dplyr::slice_sample(prop = 0.15) ) %&gt;% ggplot( mapping = aes( x=tree_height_m, y = mod_quad_noint_est_dbh_cm , color = is_training_data , fill = is_training_data , group = is_training_data ) ) + geom_smooth( method = &quot;loess&quot; , se = F , span = 1 , lwd = 1.5 , show.legend = T ) + geom_point( alpha = 0.6 , size = 0.7 , color = &quot;transparent&quot; , shape = 21 , show.legend = F ) + annotate( &quot;text&quot;, x = 0, y = max(treetops_sf_with_dbh$dbh_cm) , label = latex2exp::TeX(paste0( &quot;$DBH = \\\\exp(0&quot; , &quot; + &quot; , mod_quad_noint_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_tree_height_m&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height&quot; , &quot; + &quot; , mod_quad_noint_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_Itree_height_mE2&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height^2)$&quot; )) , parse = T , hjust = 0 ) + scale_color_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_fill_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_y_continuous(limits = c(0,max(treetops_sf_with_dbh$dbh_cm)*1.02)) + scale_x_continuous(limits = c(0,max(treetops_sf_with_dbh$tree_height_m)*1.02)) + labs( y = &quot;DBH (cm)&quot; , x = &quot;Tree Ht. (m)&quot; , title = &quot;No Intercept Quadratic Model&quot; , subtitle = &quot;SfM-derived tree height and DBH relationship&quot; , color = &quot;Training Data&quot; , fill = &quot;Training Data&quot; ) + theme_light() + theme( legend.position = &quot;bottom&quot; , legend.direction = &quot;horizontal&quot; ) + guides( color = guide_legend(override.aes = list(shape = 15, lwd = 6, size = 6, alpha = 1)) ) # plot plt_quad_noint 4.5 Nonlinear Power Model A power-law function model allows us to account for a nonlinear relationship between DBH and tree height: \\[\\begin{align*} DBH_{i} &amp;\\sim {\\sf Gamma} \\bigl(g(\\alpha, \\kappa, Height_{i}), shape \\bigr) \\\\ g(\\alpha, \\kappa, Height_{i}) &amp;= {\\exp \\bigl(\\alpha \\cdot Height_{i}^{\\kappa}\\bigr)} \\\\ \\alpha &amp;\\sim {\\sf Normal} (0,10) \\\\ \\kappa &amp;\\sim {\\sf Normal} (0,10) \\\\ shape &amp;\\sim {\\sf Gamma} (0.01,0.01) \\end{align*}\\] , where \\(i\\) is the individual tree estimate from UAS SfM data. The \\(\\sf Gamma\\) response distribution represents \\(DBH_{i}\\) as strictly non-negative. # population model with no random effects (i.e. no group-level variation) # Gamma distribution for strictly positive response variable dbh mod_pwr = brms::brm( formula = brms::bf( formula = dbh_cm ~ a * (tree_height_m^k) , a + k ~ 1 , nl = TRUE # !! specify non-linear ) , data = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) , family = brms::brmsfamily(&quot;Gamma&quot;, link = &quot;log&quot;) , prior = c(prior(gamma(0.01, 0.01), class = shape)) , iter = 3000 , file = &quot;../data/mod_pwr&quot; ) # plot(mod_pwr) # summary(mod_pwr) # plot(brms::conditional_effects(mod_pwr), points = T) # compute and save the WAIC information for the next three models mod_pwr = brms::add_criterion(mod_pwr, c(&quot;loo&quot;, &quot;waic&quot;)) # predict values over range pred_mod_pwr = predict( mod_pwr , newdata = height_range , probs = c(.05, .95) ) %&gt;% dplyr::as_tibble() %&gt;% dplyr::rename( lower_b = 3, upper_b = 4 ) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::select(-c(est.error)) %&gt;% dplyr::bind_cols(height_range) %&gt;% dplyr::mutate(tree_height_m_tnth = round(tree_height_m,1) %&gt;% as.character()) # attach predicted values to original data treetops_sf_with_dbh = treetops_sf_with_dbh %&gt;% dplyr::mutate(tree_height_m_tnth = round(tree_height_m,1) %&gt;% as.character()) %&gt;% dplyr::left_join( pred_mod_pwr %&gt;% dplyr::select(tree_height_m_tnth, estimate) , by = dplyr::join_by(tree_height_m_tnth) ) %&gt;% dplyr::mutate( mod_pwr_est_dbh_cm = ifelse(is_training_data == T, dbh_cm, estimate) ) %&gt;% dplyr::select(-c(estimate, tree_height_m_tnth)) gc() 4.5.1 Model Parameter Estimates Power-law function model form: \\[ DBH_{i} = \\exp\\bigl(\\alpha \\cdot Height_{i}^{\\kappa}\\bigr) \\] , where \\(i\\) is the individual tree estimate from UAS SfM data # parameter estimates mod_pwr_sum_temp = brms::posterior_summary(mod_pwr) %&gt;% as.data.frame() %&gt;% tibble::rownames_to_column(var = &quot;parameter&quot;) %&gt;% dplyr::filter(stringr::str_starts(parameter, &quot;b_&quot;)) %&gt;% # | parameter == &quot;shape&quot;) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::mutate( parameter = stringr::str_remove_all(tolower(parameter), &quot;_intercept&quot;) # , dplyr::across(.cols = tidyselect::where(is.numeric), .fns = exp) ) # table mod_pwr_sum_temp %&gt;% kableExtra::kbl(digits = 4) %&gt;% kableExtra::kable_styling() parameter estimate est.error q2.5 q97.5 b_a 1.4022 0.0205 1.3610 1.4424 b_k 0.3310 0.0052 0.3208 0.3416 4.5.2 SfM-derived Height to DBH Allometry # predict and put estimates in a data frame predict( mod_pwr , newdata = height_range , probs = c(.05, .95) ) %&gt;% dplyr::as_tibble() %&gt;% dplyr::rename( lower_b = 3, upper_b = 4 ) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::select(-c(est.error)) %&gt;% dplyr::bind_cols(height_range) %&gt;% # plot predictions with data ggplot( mapping = aes(x = tree_height_m) ) + geom_point( data = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) , mapping = aes(y = dbh_cm) , color = &quot;firebrick&quot; ) + geom_ribbon( mapping = aes(ymin = lower_b, ymax = upper_b) , fill = &quot;gray88&quot; , alpha = 0.5 ) + geom_line( aes(y = estimate) , color = &quot;gray33&quot; , lwd = 1 ) + labs( y = &quot;DBH (cm)&quot; , x = &quot;Tree Ht. (m)&quot; , title = &quot;Local height to DBH allometry from SfM-extracted DBH samples&quot; , subtitle = latex2exp::TeX(paste0( &quot;$DBH = \\\\exp(&quot; , mod_pwr_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_a&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height^{&quot; , mod_pwr_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_k&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;})$&quot; )) ) + theme_light() + theme(legend.position = &quot;none&quot;) 4.5.3 Training vs Non-Training DBH ### plot plt_pwr = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) %&gt;% dplyr::bind_rows( treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==F) %&gt;% dplyr::slice_sample(prop = 0.15) ) %&gt;% ggplot( mapping = aes( x=tree_height_m, y = mod_pwr_est_dbh_cm , color = is_training_data , fill = is_training_data , group = is_training_data ) ) + geom_smooth( method = &quot;loess&quot; , se = F , span = 1 , lwd = 1.5 , show.legend = T ) + geom_point( alpha = 0.6 , size = 0.7 , color = &quot;transparent&quot; , shape = 21 , show.legend = F ) + annotate( &quot;text&quot;, x = 0, y = max(treetops_sf_with_dbh$dbh_cm) , label = latex2exp::TeX(paste0( &quot;$DBH = \\\\exp(&quot; , mod_pwr_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_a&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot Height^{&quot; , mod_pwr_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_k&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;})$&quot; )) , parse = T , hjust = 0 ) + scale_color_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_fill_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_y_continuous(limits = c(0,max(treetops_sf_with_dbh$dbh_cm)*1.02)) + scale_x_continuous(limits = c(0,max(treetops_sf_with_dbh$tree_height_m)*1.02)) + labs( y = &quot;DBH (cm)&quot; , x = &quot;Tree Ht. (m)&quot; , title = &quot;Nonlinear Power Model&quot; , subtitle = &quot;SfM-derived tree height and DBH relationship&quot; , color = &quot;Training Data&quot; , fill = &quot;Training Data&quot; ) + theme_light() + theme( legend.position = &quot;bottom&quot; , legend.direction = &quot;horizontal&quot; ) + guides( color = guide_legend(override.aes = list(shape = 15, lwd = 6, size = 6, alpha = 1)) ) # plot plt_pwr 4.6 Nonlinear Weibull Model Pilli et al. (2006) suggest a Weibull function for estimating DBH to height allometric relationships to allow for a nonlinear relationship: \\[\\begin{align*} DBH_{i} &amp;\\sim {\\sf Gamma} \\bigl(g(a, b, Height_{i}), shape \\bigr) \\\\ g(a, b, Height_{i}) &amp;= {\\exp\\biggl(a \\cdot \\bigl(1-\\exp(-Height_{i}/b)\\bigr)\\biggr)} \\\\ a &amp;\\sim {\\sf Normal} (0,10) \\\\ b &amp;\\sim {\\sf Normal} (0,10) \\\\ shape &amp;\\sim {\\sf Gamma} (0.01,0.01) \\end{align*}\\] , where \\(i\\) is the individual tree estimate from UAS SfM data. The \\(\\sf Gamma\\) response distribution represents \\(DBH_{i}\\) as strictly non-negative. # population model with no random effects (i.e. no group-level variation) # Gamma distribution for strictly positive response variable dbh # a × (1exp(DBH/b)) mod_weib = brms::brm( formula = brms::bf( formula = dbh_cm ~ a * (1-exp(-tree_height_m/b)) , a + b ~ 1 , nl = TRUE # !! specify non-linear ) , data = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) , family = brms::brmsfamily(&quot;Gamma&quot;, link = &quot;log&quot;) , prior = c(prior(gamma(0.01, 0.01), class = shape)) , iter = 3000 , file = &quot;../data/mod_weib&quot; ) # plot(mod_weib) # summary(mod_weib) # plot(brms::conditional_effects(mod_weib), points = T) # compute and save the WAIC information for the next three models mod_weib = brms::add_criterion(mod_weib, c(&quot;loo&quot;, &quot;waic&quot;)) # predict values over range pred_mod_weib = predict( mod_weib , newdata = height_range , probs = c(.05, .95) ) %&gt;% dplyr::as_tibble() %&gt;% dplyr::rename( lower_b = 3, upper_b = 4 ) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::select(-c(est.error)) %&gt;% dplyr::bind_cols(height_range) %&gt;% dplyr::mutate(tree_height_m_tnth = round(tree_height_m,1) %&gt;% as.character()) # attach predicted values to original data treetops_sf_with_dbh = treetops_sf_with_dbh %&gt;% dplyr::mutate(tree_height_m_tnth = round(tree_height_m,1) %&gt;% as.character()) %&gt;% dplyr::left_join( pred_mod_weib %&gt;% dplyr::select(tree_height_m_tnth, estimate) , by = dplyr::join_by(tree_height_m_tnth) ) %&gt;% dplyr::mutate( mod_weib_est_dbh_cm = ifelse(is_training_data == T, dbh_cm, estimate) ) %&gt;% dplyr::select(-c(estimate, tree_height_m_tnth)) gc() 4.6.1 Model Parameter Estimates Weibull function model form: \\[ DBH_{i} = \\exp\\biggl(a \\cdot \\bigl(1-\\exp(-Height_{i}/b)\\bigr)\\biggr) \\] , where \\(i\\) is the individual tree estimate from UAS SfM data # parameter estimates mod_weib_sum_temp = brms::posterior_summary(mod_weib) %&gt;% as.data.frame() %&gt;% tibble::rownames_to_column(var = &quot;parameter&quot;) %&gt;% dplyr::filter(stringr::str_starts(parameter, &quot;b_&quot;)) %&gt;% # | parameter == &quot;shape&quot;) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::mutate( parameter = stringr::str_remove_all(tolower(parameter), &quot;_intercept&quot;) # , dplyr::across(.cols = tidyselect::where(is.numeric), .fns = exp) ) # table mod_weib_sum_temp %&gt;% kableExtra::kbl(digits = 4) %&gt;% kableExtra::kable_styling() parameter estimate est.error q2.5 q97.5 b_a 4.0870 0.0172 4.0549 4.1214 b_b 7.9347 0.1050 7.7372 8.1441 4.6.2 SfM-derived Height to DBH Allometry # predict and put estimates in a data frame predict( mod_weib , newdata = height_range , probs = c(.05, .95) ) %&gt;% dplyr::as_tibble() %&gt;% dplyr::rename( lower_b = 3, upper_b = 4 ) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::select(-c(est.error)) %&gt;% dplyr::bind_cols(height_range) %&gt;% # plot predictions with data ggplot( mapping = aes(x = tree_height_m) ) + geom_point( data = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) , mapping = aes(y = dbh_cm) , color = &quot;firebrick&quot; ) + geom_ribbon( mapping = aes(ymin = lower_b, ymax = upper_b) , fill = &quot;gray88&quot; , alpha = 0.5 ) + geom_line( aes(y = estimate) , color = &quot;gray33&quot; , lwd = 1 ) + labs( y = &quot;DBH (cm)&quot; , x = &quot;Tree Ht. (m)&quot; , title = &quot;Local height to DBH allometry from SfM-extracted DBH samples&quot; , subtitle = latex2exp::TeX(paste0( &quot;$DBH = \\\\exp(&quot; , mod_weib_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_a&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot (1-\\\\exp(-Height/&quot; , mod_weib_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_b&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;)))$&quot; )) ) + theme_light() + theme(legend.position = &quot;none&quot;) 4.6.3 Training vs Non-Training DBH ### plot plt_weib = treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==T) %&gt;% dplyr::bind_rows( treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_training_data==F) %&gt;% dplyr::slice_sample(prop = 0.15) ) %&gt;% ggplot( mapping = aes( x=tree_height_m, y = mod_weib_est_dbh_cm , color = is_training_data , fill = is_training_data , group = is_training_data ) ) + geom_smooth( method = &quot;loess&quot; , se = F , span = 1 , lwd = 1.5 , show.legend = T ) + geom_point( alpha = 0.6 , size = 0.7 , color = &quot;transparent&quot; , shape = 21 , show.legend = F ) + annotate( &quot;text&quot;, x = 0, y = max(treetops_sf_with_dbh$dbh_cm) , label = latex2exp::TeX(paste0( &quot;$DBH = \\\\exp(&quot; , mod_weib_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_a&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;\\\\cdot (1-\\\\exp(-Height/&quot; , mod_weib_sum_temp %&gt;% dplyr::filter(parameter==&quot;b_b&quot;) %&gt;% dplyr::pull(estimate) %&gt;% round(3) , &quot;)))$&quot; )) , parse = T , hjust = 0 ) + scale_color_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_fill_manual(values = c(&quot;gray&quot;,&quot;firebrick&quot;)) + scale_y_continuous(limits = c(0,max(treetops_sf_with_dbh$dbh_cm)*1.02)) + scale_x_continuous(limits = c(0,max(treetops_sf_with_dbh$tree_height_m)*1.02)) + labs( y = &quot;DBH (cm)&quot; , x = &quot;Tree Ht. (m)&quot; , title = &quot;Nonlinear Weibull Model&quot; , subtitle = &quot;SfM-derived tree height and DBH relationship&quot; , color = &quot;Training Data&quot; , fill = &quot;Training Data&quot; ) + theme_light() + theme( legend.position = &quot;bottom&quot; , legend.direction = &quot;horizontal&quot; ) + guides( color = guide_legend(override.aes = list(shape = 15, lwd = 6, size = 6, alpha = 1)) ) # plot plt_weib 4.7 Model Comparison The pointwise log-likelihood can be used, among others, to calculate the leave-one-out cross-validation (LOO; Vehtari, Gelman, and Gabry 2015) allowing for comparison of different models applied to the same data (lower LOOs indicate better model fit). brms::loo_compare(mod_lin, mod_quad, mod_quad_noint, mod_pwr, mod_weib, criterion = &quot;loo&quot;) %&gt;% kableExtra::kbl(digits = 3) %&gt;% kableExtra::kable_styling() elpd_diff se_diff elpd_loo se_elpd_loo p_loo se_p_loo looic se_looic mod_lin 0.000 0.000 -9143.944 32.486 2.557 0.109 18287.89 64.972 mod_pwr -15.256 5.003 -9159.200 32.598 2.671 0.092 18318.40 65.196 mod_weib -27.266 8.488 -9171.210 32.204 2.820 0.093 18342.42 64.409 mod_quad -164.854 16.991 -9308.798 35.442 146.992 17.286 18617.60 70.885 mod_quad_noint -405.877 36.401 -9549.820 39.550 5.555 0.918 19099.64 79.101 # # can also check model weights # brms::model_weights(mod_lin, mod_quad, mod_quad_noint, mod_pwr, mod_weib, weights = &quot;loo&quot;) %&gt;% # round(3) Based on these results, the linear model \\(DBH_i = \\beta_0 + \\beta_1 \\cdot Height_i\\) has the best fit among models tested. DBH estimates based on this model for trees where DBH could not be extracted from the UAS SfM data will be used in the following analysis and stand-level summaries 4.8 Update DBH to best model # update treetops treetops_sf_with_dbh = treetops_sf_with_dbh %&gt;% dplyr::mutate( mod_rf_est_dbh_cm = dbh_cm , dbh_cm = mod_lin_est_dbh_cm , dbh_m = dbh_cm/100 , radius_m = dbh_m/2 , basal_area_m2 = pi * (radius_m)^2 ) %&gt;% # convert to imperial units calc_imperial_units_fn() ########## # update crowns crowns_sf_with_dbh = crowns_sf_with_dbh %&gt;% dplyr::select(-c( dbh_cm , dbh_m , radius_m , basal_area_m2 )) %&gt;% dplyr::inner_join( treetops_sf_with_dbh %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select( treeID , dbh_cm , dbh_m , radius_m , basal_area_m2 , (tidyselect::starts_with(&quot;mod_&quot;) &amp; tidyselect::ends_with(&quot;_cm&quot;)) ) , by = dplyr::join_by(treeID) ) %&gt;% # convert to imperial units calc_imperial_units_fn() ## write data sf::st_write(treetops_sf_with_dbh, paste0(delivery_dir,&quot;/dbh_updated_detected_tree_tops.gpkg&quot;), append = F) sf::st_write(crowns_sf_with_dbh, paste0(delivery_dir,&quot;/dbh_updated_detected_crowns.gpkg&quot;), append = F) ## keep the best model mod_best = mod_lin pred_mod_best = pred_mod_lin 4.9 Combine harvest units with tree locations Spatially combine harvest units with tree locations. One tree can be located in multiple harvest units if the harvest units spatially overlap; Ill allow it. Trees are matched to a harvest unit based on the location of the tree top which may or may not align with the location of the tree bole at DBH. ################################################################################# ################################################################################# # Join tree tops with forest stands ################################################################################# ################################################################################# harvests_trees = harvests %&gt;% dplyr::mutate( stand_area_m2 = sf::st_area(.) %&gt;% as.numeric() , stand_area_ha = stand_area_m2/10000 ) %&gt;% sf::st_intersection(las_ctg_dta) %&gt;% dplyr::mutate( intrsct_stand_area_m2 = sf::st_area(.) %&gt;% as.numeric() ) %&gt;% dplyr::filter(round(intrsct_stand_area_m2, 0) == round(stand_area_m2, 0)) %&gt;% dplyr::select( suid, forest_commonname, admin_region_code, activity_name , treatment_type, treatment_type_grp, date_compl, year_id , stand_area_m2, stand_area_ha ) %&gt;% sf::st_intersection(treetops_sf_with_dbh) # filter harvests harvests = harvests %&gt;% dplyr::filter(suid %in% unique(harvests_trees$suid)) "],["exploratory-analysis.html", "Section 5 Exploratory Analysis 5.1 Study Location Map 5.2 Digital Terrain Model (DTM) Map 5.3 Canopy height model (CHM) Map 5.4 DBH Distribution 5.5 Height Distribution 5.6 Relationship between height and DBH", " Section 5 Exploratory Analysis High-level summaries of the data. 5.1 Study Location Map Map of the BHEF, 2021 harvest boundaries, and 2023-06 UAS flight boundaries. The UAS flights covered 719.9 acres (291.3 ha). There are 6 stands harvested in 2021 that are entirely within the UAS flight boundaries. The harvested stands range in size from 9.6 acres (3.9 ha) to 167.8 acres (67.9 ha). # map mapview::mapview( bhef_boundary , color = &quot;black&quot; , lwd = 3 , alpha.regions = 0 , layer.name = &quot;BHEF&quot; , label = FALSE , legend = FALSE , popup = FALSE ) + mapview::mapview( las_ctg_dta , color = &quot;firebrick&quot; , lwd = 2 , col.regions = c(&quot;firebrick&quot;) , alpha.regions = 0.3 , layer.name = &quot;UAS Flight Boundaries&quot; , label = FALSE , legend = T , popup = FALSE ) + mapview::mapview( harvests , zcol = &quot;treatment_type_grp&quot; , col.regions = viridis::turbo(n=length(unique(harvests$treatment_type_grp))) , alpha.regions = 0.6 , layer.name = &quot;Harvests (2021)&quot; , legend = T , popup = leafpop::popupTable( harvests , zcol = c( &quot;year_id&quot; , &quot;treatment_type_grp&quot; , &quot;activity_name&quot; ) , row.numbers = FALSE , feature.id = FALSE ) ) 5.2 Digital Terrain Model (DTM) Map Map the SfM-derived digital terrain model (DTM) (sometimes called Digital Elevation Models [DEM]) which is a topographic model of the bare Earth containing the elevation data of the terrain. mapview::mapview( bhef_boundary , color = &quot;black&quot; , lwd = 3 , alpha.regions = 0 , layer.name = &quot;BHEF&quot; , label = FALSE , legend = FALSE , popup = FALSE ) + # aggregate raster and map mapview::mapview( dtm_rast %&gt;% terra::aggregate(fact=2) %&gt;% `*`(3.28) %&gt;% # transform to feet stars::st_as_stars() , layer.name = &quot;elev. (ft)&quot; , col.regions = viridis::viridis(n=100) , alpha.regions = 0.7 , na.color = &quot;transparent&quot; ) 5.3 Canopy height model (CHM) Map Map the SfM-derived canopy height model which is a measurement of the height of trees above the ground topography. mapview::mapview( bhef_boundary , color = &quot;black&quot; , lwd = 3 , alpha.regions = 0 , layer.name = &quot;BHEF&quot; , label = FALSE , legend = FALSE , popup = FALSE ) + # aggregate raster and map mapview::mapview( chm_rast_temp , layer.name = &quot;canopy ht. (ft)&quot; , col.regions = viridis::plasma(n=50) , alpha.regions = 0.7 , na.color = &quot;transparent&quot; ) # # tree_tops # mapview::mapview( # treetops_sf_with_dbh # , cex = 0.5 # , layer.name = &quot;tree tops&quot; # , label = F # , legend = F # , popup = F # ) 5.4 DBH Distribution DBH distribution of trees that are in a harvested unit. Trees within harvest unit boundaries have a DBH range from 0.1 in (0.2 cm) to 28.3 in (71.8 cm) with a median of 3.2 in (8.2 cm). harvests_trees %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(treeID, dbh_in) %&gt;% dplyr::distinct() %&gt;% ggplot( mapping = aes(x = dbh_in) ) + geom_density(alpha = 0.8, fill = &quot;navy&quot;, color = NA) + labs( x = &quot;DBH (in)&quot; , y = &quot;density&quot; , title = &quot;SfM-derived tree DBH distribution&quot; ) + scale_x_continuous(breaks = scales::extended_breaks(n=20)) + theme_light() + theme( legend.position = &quot;none&quot; ) 5.5 Height Distribution Height distribution of trees that are in a harvested unit. Trees within harvest unit boundaries have a height range from 4.5 ft (1.4 m) to 90.9 ft (27.7 m) with a median of 16.8 ft (5.1 m). harvests_trees %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(treeID, tree_height_ft) %&gt;% dplyr::distinct() %&gt;% ggplot( mapping = aes(x = tree_height_ft) ) + geom_density(alpha = 0.8, fill = &quot;steelblue&quot;, color = NA) + labs( x = &quot;Height (ft)&quot; , y = &quot;density&quot; , title = &quot;SfM-derived tree height distribution&quot; ) + scale_x_continuous(breaks = scales::extended_breaks(n=10)) + theme_light() + theme( legend.position = &quot;none&quot; ) 5.6 Relationship between height and DBH ### plot harvests_trees %&gt;% sf::st_drop_geometry() %&gt;% dplyr::slice_sample(prop = 0.2) %&gt;% dplyr::select(treeID, tree_height_ft, dbh_in) %&gt;% dplyr::distinct() %&gt;% ggplot( mapping = aes(y=tree_height_ft, x = dbh_in) ) + geom_point( alpha = 0.6 , size = 0.6 , color = &quot;gray&quot; ) + geom_smooth( method = &quot;loess&quot; , se = F , span = 1 , color = &quot;gray33&quot; , alpha = 0.7 ) + labs( x = &quot;DBH (in)&quot; , y = &quot;Tree Ht. (ft)&quot; , title = &quot;SfM-derived tree height and DBH relationship&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; ) "],["ostory_valid.html", "Section 6 Overstory Field Validation Data 6.1 Load Field Data 6.2 Build UAS-Field Validation Data 6.3 Summary of Validation Data 6.4 Commission and Omission Locations", " Section 6 Overstory Field Validation Data Tinkham and Swayze (2021; p.6) describe a methodology for matching UAS detected trees with stem mapped trees identified via traditional field survey methods. Note, detected trees in the excerpt below references UAS detected trees while survey trees references field-based stem mapped trees: Each of the detected tree outputs was matched with survey tree locations through an iterative process. Iteratively, a detected tree was selected, and all survey trees within a 3 m radius and 10% height of the detected tree were identified. If a survey tree met both the location and height precision requirements, it was considered a true positive (TP) detection, and both the survey and detected trees were removed from further matching. However, if no match was made, the detected tree was considered a commission (Co) and removed from further matching. This process was repeated until all detected trees were classified as true positive or commission, with all unmatched survey trees classified as omission (Om). Overall tree detection performance was described using the F-score metric. The F-score incorporates true positive, commission, and omission rates to determine how well the UAS detected trees represent the field-based stem mapped trees. As a measure of predictive performance, the highest possible value of an F-score is 1.0, indicating perfect precision and recall, and the lowest possible value is 0, if either precision or recall are zero. \\[ \\textrm{F-score} = 2 \\times \\frac{\\bigl(\\frac{TP}{TP+Om} \\times \\frac{TP}{TP+Co} \\bigr)}{\\bigl(\\frac{TP}{TP+Om} + \\frac{TP}{TP+Co} \\bigr)} \\] The process to match UAS detected trees to field stem mapped trees implemented here is slightly different than the process described above. To match the data parametrization from the UAS point cloud processing workflow, only stem-mapped trees above 1.4 m were considered for analysis. Each UAS detected tree was matched with stem-mapped tree locations that were within a 3 m radius and 2 m height of the UAS detected tree. The matched UAS and stem-mapped tree pairs were jointly compared (rather than iteratively) to select the pair that minimized the height difference for both the stem-mapped tree and the UAS detected tree to ensure that only one UAS detected tree was selected for each stem-mapped tree. If more than one UAS detected tree had the same height difference to a stem-mapped tree, the UAS detected tree spatially nearest to the stem-mapped tree was selected as the match. These UAS detected trees with a paired stem-mapped tree after this filtering process were considered true positive (\\(TP\\)) detections. To determine UAS detected tree commissions (i.e. UAS detected trees within the overstory plot for which there was no stem-mapped tree pair; \\(Co\\)) this analysis used the 2023-06 BHEF overstory field survey plot center and plot radius with a minimum DBH of 5 in (12.69 cm) as only trees above this size were sampled as part of the overstory survey. UAS detected trees within this radius with an estimated DBH over 5 in (12.69 cm) that did not have a matched stem-mapped tree pair were considered commissions (\\(Co\\)). The 2023-06 BHEF field surveys used \\(\\frac{1}{10}\\) acre (404.686 m2) plots with a 37.24 ft (11.35 m) radius for overstory sampling and \\(\\frac{1}{400}\\) acre (10.117 m2) plots with a 5.89 ft (1.795 m) radius for regeneration sampling. All unmatched stem-mapped survey trees were classified as omissions (\\(Om\\)). 6.1 Load Field Data Load the overstory data, set parameters for processing, and map ################################################################################################## ## USER DEFINED PARAMETERS ################################################################################################## ### Only include trees above a specific height # e.g., set to match the minimum height used in point cloud processing min_tree_height_m = min(chm_rast %&gt;% terra::values(), na.rm = T) ### Only include trees above a specific DBH # e.g., set to match the minimum tree DBH for field sampling of overstory trees min_tree_dbh_cm = 5*2.54 # 3 in = 7.62 cm ### Find all nearest neighbors within maximum distance and then filter them based on ### distance and height error max_dist_m = 3 max_height_error_m = 2 ################################################################################################## ## USER DEFINED PARAMETERS ################################################################################################## # load Field Validation Data field_overstory = readr::read_csv( file = &quot;../data/field_data/Voodoo_overstory_data_old.csv&quot; ) %&gt;% dplyr::rename_with(~ .x %&gt;% # replace all non alphanumeric with _ stringr::str_replace_all(&quot;[^[:alnum:] ]+&quot;, &quot;_&quot;) %&gt;% # remove any _ at the end of the string stringr::str_remove(&quot;[_]$&quot;) %&gt;% tolower() ) %&gt;% dplyr::filter( !is.na(tree_diameter_inches) &amp; !is.na(tree_height_feet) &amp; !is.na(tree_utm_x) &amp; !is.na(tree_utm_y) ) %&gt;% dplyr::mutate( field_dbh_cm = tree_diameter_inches/0.394 , field_tree_height_m = tree_height_feet/3.281 , field_plottree_id = paste0( stringr::str_pad(plot_id, width = 4, side = &quot;left&quot;, pad = &quot;0&quot;) , &quot;-&quot; , stringr::str_pad(tree_id, width = 4, side = &quot;left&quot;, pad = &quot;0&quot;) ) ) %&gt;% dplyr::filter( field_tree_height_m &gt;= min_tree_height_m &amp; field_dbh_cm &gt;= min_tree_dbh_cm ) %&gt;% dplyr::rename( field_dbh_in = tree_diameter_inches , field_tree_height_ft = tree_height_feet ) %&gt;% sf::st_as_sf( coords = c(&quot;tree_utm_x&quot;, &quot;tree_utm_y&quot;) , crs = sf::st_crs(treetops_sf_with_dbh) , remove=F ) %&gt;% # keep only tree points that are within the uas flight boundary sf::st_intersection(las_ctg_dta) # field_overstory %&gt;% # sf::st_drop_geometry() %&gt;% # dplyr::summarize(n = dplyr::n(), unique_tree = dplyr::n_distinct(field_plottree_id)) field_overstory %&gt;% dplyr::glimpse() ## Rows: 363 ## Columns: 26 ## $ plot_id &lt;dbl&gt; 43, 32, 18, 19, 38, 43, 18~ ## $ observers_on_plot &lt;chr&gt; &quot;HK,TD,VH,CM&quot;, &quot;VH,HK,CM,T~ ## $ collection_date &lt;chr&gt; &quot;6/6/2023 18:00&quot;, &quot;6/8/202~ ## $ comments_on_plot_condition_or_abnormalities &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA~ ## $ x &lt;dbl&gt; -103.6168, -103.6362, -103~ ## $ y &lt;dbl&gt; 44.14265, 44.14125, 44.144~ ## $ tree_id &lt;dbl&gt; 1, 1, 1, 1, 1, 2, 2, 1, 1,~ ## $ species &lt;chr&gt; &quot;Pinus ponderosa&quot;, &quot;Pinus ~ ## $ tree_condition &lt;chr&gt; &quot;Live&quot;, &quot;Live&quot;, &quot;Live&quot;, &quot;L~ ## $ field_dbh_in &lt;dbl&gt; 9.3, 5.3, 9.3, 10.5, 5.2, ~ ## $ tree_distance_from_plot_center_ft &lt;dbl&gt; 13.0, 19.0, 36.7, 16.5, 6.~ ## $ azimuth_to_tree_degrees &lt;dbl&gt; 1, 2, 3, 5, 6, 7, 8, 12, 1~ ## $ field_tree_height_ft &lt;dbl&gt; 40.5, 28.0, 34.0, 48.0, 17~ ## $ tree_crown_base_height_feet &lt;dbl&gt; 11.5, 12.0, 7.0, 13.0, NA,~ ## $ tree_remarks &lt;chr&gt; NA, NA, NA, NA, &quot;Broken to~ ## $ parentglobalid &lt;chr&gt; &quot;bd4bdd71-588e-4d4a-b255-0~ ## $ uniqueid &lt;chr&gt; &quot;bd4bdd71-588e-4d4a-b255-0~ ## $ ba &lt;dbl&gt; 0.4717165, 0.1532029, 0.47~ ## $ utm_x &lt;dbl&gt; 610631.4, 609087.3, 608962~ ## $ utm_y &lt;dbl&gt; 4888644, 4888472, 4888774,~ ## $ tree_utm_y &lt;dbl&gt; 4888648, 4888478, 4888786,~ ## $ tree_utm_x &lt;dbl&gt; 610631.5, 609087.5, 608963~ ## $ field_dbh_cm &lt;dbl&gt; 23.60406, 13.45178, 23.604~ ## $ field_tree_height_m &lt;dbl&gt; 12.343798, 8.533984, 10.36~ ## $ field_plottree_id &lt;chr&gt; &quot;0043-0001&quot;, &quot;0032-0001&quot;, ~ ## $ geometry &lt;POINT [m]&gt; POINT (610631.5 4888~ Overstory field data map field_overstory %&gt;% sf::st_drop_geometry() %&gt;% dplyr::distinct(plot_id, utm_x, utm_y) %&gt;% sf::st_as_sf(coords = c(&quot;utm_x&quot;, &quot;utm_y&quot;), crs = sf::st_crs(treetops_sf_with_dbh)) %&gt;% sf::st_buffer(11.35) %&gt;% dplyr::mutate(x=1) %&gt;% mapview::mapview(col.regions = &quot;blue&quot;, layer.name = &quot;plot&quot;, alpha.regions = 0.6) + mapview::mapview(field_overstory, col.regions = &quot;orange&quot;, cex = 2, layer.name = &quot;trees&quot;) + mapview::mapview( harvests , color = &quot;black&quot; , lwd = 3 , alpha.regions = 0 , label = FALSE , legend = FALSE , popup = FALSE ) 6.2 Build UAS-Field Validation Data 6.2.1 True Positive Identification The UAS detected and stem-mapped tree pairs identified in this filtering process (detailed above) were considered true positive (\\(TP\\)) detections. ## BUFFER THE UAS TREES AND SPATIALLY MATCH FIELD TREES BASED ON THAT BUFFER ## get FIELD trees within radius OF UAS TREES potential_tree_pairs_temp = treetops_sf_with_dbh %&gt;% dplyr::select(treeID, tree_height_m) %&gt;% # buffer point sf::st_buffer(max_dist_m) %&gt;% # spatial join with all FIELD tree points sf::st_join( field_overstory %&gt;% dplyr::filter( field_tree_height_m &gt;= min_tree_height_m &amp; field_dbh_cm &gt;= min_tree_dbh_cm ) %&gt;% dplyr::select( field_plottree_id, field_tree_height_m , tree_utm_x, tree_utm_y ) , join = st_intersects , left = F # performs inner join to only keep uas trees with a match ) %&gt;% # calculate height difference dplyr::mutate( height_diff_m = abs(tree_height_m-field_tree_height_m) , height_diff_pct = height_diff_m/field_tree_height_m ) %&gt;% # removes tree pairs that are outside of the allowable error # dplyr::filter(height_diff_pct &lt;= max_height_error_pct) %&gt;% dplyr::filter(height_diff_m &lt;= max_height_error_m) %&gt;% dplyr::select(-c(height_diff_m)) %&gt;% dplyr::relocate(treeID, field_plottree_id) ## apply pair selection criteria if there are potential tree pairs if(nrow(potential_tree_pairs_temp)&gt;0){ ## calculate row by row distances and height differences potential_tree_pairs_temp = potential_tree_pairs_temp %&gt;% # this is the position of the uas tree sf::st_centroid() %&gt;% sf::st_set_geometry(&quot;geom1&quot;) %&gt;% dplyr::bind_cols( potential_tree_pairs_temp %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(&quot;tree_utm_x&quot;, &quot;tree_utm_y&quot;) %&gt;% # this is the position of the field tree sf::st_as_sf( coords = c(&quot;tree_utm_x&quot;, &quot;tree_utm_y&quot;), crs = sf::st_crs(treetops_sf_with_dbh) ) %&gt;% sf::st_set_geometry(&quot;geom2&quot;) ) %&gt;% dplyr::mutate( distance_m = sf::st_distance(geom1, geom2, by_element = T) %&gt;% as.numeric() ) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(-c(tree_utm_x, tree_utm_y, geom2)) ## define function to select the best tree pair select_best_tree_pair_fn &lt;- function(df) { df %&gt;% dplyr::group_by(field_plottree_id) %&gt;% dplyr::arrange(field_plottree_id, height_diff_pct, distance_m, desc(tree_height_m), treeID) %&gt;% dplyr::mutate( # at the field tree level...the number of uas trees n_uas_trees = dplyr::n() # at the field tree level... # the closest uas tree in height tie breaker distance, uas_tree_height_m, id , rank_within_field_tree = dplyr::row_number() ) %&gt;% dplyr::group_by(treeID) %&gt;% dplyr::arrange(treeID, height_diff_pct, distance_m, desc(field_tree_height_m), field_plottree_id) %&gt;% dplyr::mutate( # at the uas tree level...the number of field trees n_field_trees = dplyr::n() # at the field tree level... # the closest field tree in height tie breaker distance, uas_tree_height_m, id , rank_within_uas_tree = dplyr::row_number() ) %&gt;% dplyr::ungroup() %&gt;% # select the uas-field tree pair with the minimum height difference dplyr::filter( rank_within_field_tree == 1 &amp; rank_within_uas_tree == 1 ) %&gt;% # remove columns dplyr::select( -c(tidyselect::starts_with(&quot;rank_&quot;), tidyselect::starts_with(&quot;n_&quot;)) ) } ## first filter for tree pairs true_positive_trees = select_best_tree_pair_fn(potential_tree_pairs_temp) ##remove matches from potential tree pairs potential_tree_pairs_temp = potential_tree_pairs_temp %&gt;% dplyr::filter( !(treeID %in% true_positive_trees$treeID) &amp; !(field_plottree_id %in% true_positive_trees$field_plottree_id) ) ## keep filtering for best pair until no unique pairs remain while(nrow(potential_tree_pairs_temp)&gt;0) { # keep filtering for best pair until no unique pairs remain true_positive_trees = true_positive_trees %&gt;% dplyr::bind_rows( select_best_tree_pair_fn(potential_tree_pairs_temp) ) #remove matches from potential tree pairs potential_tree_pairs_temp = potential_tree_pairs_temp %&gt;% dplyr::filter( !(treeID %in% true_positive_trees$treeID) &amp; !(field_plottree_id %in% true_positive_trees$field_plottree_id) ) } ## rename columns and flag true_positive_trees = true_positive_trees %&gt;% dplyr::rename( uas_tree_height_m = tree_height_m , uas_tree_id = treeID , field_uas_distance_m = distance_m ) %&gt;% dplyr::mutate( field_uas_group = &quot;true positive&quot; ) }else{ # if there are spatially matched trees true_positive_trees = dplyr::tibble( uas_tree_id = as.character(NA) , field_plottree_id = as.character(NA) , uas_tree_height_m = as.numeric(NA) , field_tree_height_m = as.numeric(NA) , height_diff_pct = as.numeric(NA) , field_uas_distance_m = as.numeric(NA) , field_uas_group = as.character(NA) ) } remove(potential_tree_pairs_temp) gc() True positive detections #check data true_positive_trees %&gt;% dplyr::summarise( n_rows = n() , unique_uas_trees = n_distinct(uas_tree_id) , unique_field_trees = n_distinct(field_plottree_id) , unique_pairs = n_distinct(field_plottree_id, uas_tree_id) ) %&gt;% kableExtra::kbl(caption = &quot;results of true positive stem-uas tree matching&quot;) %&gt;% kableExtra::kable_styling() Table 6.1: results of true positive stem-uas tree matching n_rows unique_uas_trees unique_field_trees unique_pairs 300 300 300 300 6.2.2 Combine with Commission and Omission To determine UAS detected tree commissions (i.e. UAS detected trees within the overstory plot for which there was no stem-mapped tree pair; \\(Co\\)) this analysis used the 2023-06 BHEF overstory field survey plot center and plot radius of 11.35 m. UAS detected trees within this radius with an estimated DBH over 5 in (12.69 cm) that did not have a matched stem-mapped tree pair were considered commissions (\\(Co\\)). Omissions (\\(Om\\)) are stem-mapped trees without a UAS detected tree match. field_uas_comparison = dplyr::bind_rows( ## true positive true_positive_trees ## omission , field_overstory %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select( plot_id, field_plottree_id, field_tree_height_m ) %&gt;% dplyr::anti_join( true_positive_trees , by = dplyr::join_by(field_plottree_id) ) %&gt;% dplyr::mutate( field_uas_group = &quot;omission&quot; ) ## commission , field_overstory %&gt;% sf::st_drop_geometry() %&gt;% # get field plot center locations dplyr::distinct(plot_id, utm_x, utm_y) %&gt;% sf::st_as_sf(coords = c(&quot;utm_x&quot;, &quot;utm_y&quot;), crs = sf::st_crs(treetops_sf_with_dbh)) %&gt;% # buffer plot center with plot area 11.35m radius + mean error in true positive trees # sf::st_buffer(11.35+mean(true_positive_trees$field_uas_distance_m, na.rm = T)) %&gt;% # buffer plot center with plot area 11.35m radius sf::st_buffer(11.35) %&gt;% # join with uas tree points sf::st_join( treetops_sf_with_dbh %&gt;% dplyr::filter( !treeID %in% true_positive_trees$uas_tree_id &amp; dbh_cm &gt;= min_tree_dbh_cm &amp; tree_height_m &gt;= min_tree_height_m ) %&gt;% dplyr::select(treeID) %&gt;% dplyr::rename(uas_tree_id=treeID) , join = st_intersects , left = F # performs inner join to only keep uas trees and plots with a match ) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::mutate( field_uas_group = &quot;commission&quot; ) ) %&gt;% # attach uas data dplyr::left_join( treetops_sf_with_dbh %&gt;% sf::st_set_geometry(&quot;geometry&quot;) %&gt;% dplyr::mutate( uas_tree_utm_x = sf::st_coordinates(geometry)[,1] #lon , uas_tree_utm_y = sf::st_coordinates(geometry)[,2] #lat ) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(treeID, tree_height_m, dbh_cm, uas_tree_utm_x, uas_tree_utm_y) %&gt;% dplyr::rename( uas_tree_id = treeID , uas_tree_height_m = tree_height_m , uas_dbh_cm = dbh_cm ) , by = dplyr::join_by(uas_tree_id) ) %&gt;% # attach field data dplyr::left_join( field_overstory %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select( field_plottree_id, field_tree_height_m, field_dbh_cm, plot_id , tree_utm_x, tree_utm_y ) %&gt;% dplyr::rename( field_tree_utm_x = tree_utm_x , field_tree_utm_y = tree_utm_y ) , by = dplyr::join_by(field_plottree_id) ) %&gt;% # update data dplyr::mutate( uas_tree_height_m = uas_tree_height_m.y , field_tree_height_m = field_tree_height_m.y , plot_id = dplyr::coalesce(plot_id.x, plot_id.y) , field_uas_group = factor( field_uas_group , ordered = T , levels = c( &quot;true positive&quot; , &quot;commission&quot; , &quot;omission&quot; ) ) %&gt;% forcats::fct_rev() , dbh_diff_cm = uas_dbh_cm - field_dbh_cm , tree_height_diff_m = uas_tree_height_m - field_tree_height_m , dbh_diff_pct = dbh_diff_cm/field_dbh_cm , height_diff_pct = tree_height_diff_m/field_tree_height_m , abs_dbh_diff_pct = abs(dbh_diff_pct) , abs_height_diff_pct = abs(height_diff_pct) , plot_lab = stringr::str_pad(plot_id, width = 4, side = &quot;left&quot;, pad = &quot;0&quot;) ) %&gt;% dplyr::relocate(field_uas_group) %&gt;% dplyr::select(-c(tidyselect::ends_with(&quot;.x&quot;), tidyselect::ends_with(&quot;.y&quot;))) %&gt;% # convert to imperial units calc_imperial_units_fn() ## write write.csv(field_uas_comparison, paste0(delivery_dir,&quot;/field_uas_comparison_data.csv&quot;), row.names = F) ## aggregate data to plot level field_uas_comparison_plot = field_uas_comparison %&gt;% dplyr::count(plot_id, plot_lab, field_uas_group) %&gt;% dplyr::group_by(plot_id, plot_lab) %&gt;% dplyr::mutate( pct = n/sum(n) , tot = sum(n) , tp_pct=max(ifelse(field_uas_group==&quot;true positive&quot;,pct,0)) ) %&gt;% dplyr::ungroup() %&gt;% # attach f score dplyr::inner_join( field_uas_comparison %&gt;% dplyr::count(plot_id, field_uas_group) %&gt;% dplyr::mutate(field_uas_group = dplyr::case_when( field_uas_group == &quot;true positive&quot; ~ &quot;tp&quot; , field_uas_group == &quot;commission&quot; ~ &quot;co&quot; , field_uas_group == &quot;omission&quot; ~ &quot;om&quot; )) %&gt;% tidyr::pivot_wider( names_from = field_uas_group , values_from = n , values_fill = 0 ) %&gt;% dplyr::mutate( plot_f_score = dplyr::coalesce( 2 * ( (tp/(tp+om)) * (tp/(tp+co)) ) / ( (tp/(tp+om)) + (tp/(tp+co)) ) , 0 ) ) %&gt;% dplyr::select(plot_id, plot_f_score) , by = dplyr::join_by(plot_id) ) 6.3 Summary of Validation Data 6.3.1 True Positive, Commission, Ommission Summary of tree true positive (\\(TP\\)), commission (\\(Co\\)), and omission (\\(Om\\)) detection by BHEF overstory plot. field_uas_comparison_plot %&gt;% ggplot( mapping = aes(x = pct, y = reorder(plot_lab, tp_pct), fill=field_uas_group, group=field_uas_group) ) + geom_col( width = 0.7, alpha=0.8 ) + geom_text( mapping = aes( label = scales::percent(ifelse(pct&gt;=0.12,pct,NA), accuracy = 1) , fontface = &quot;bold&quot; ) , position = position_stack(vjust = 0.5) , color = &quot;black&quot;, size = 2.3 ) + scale_fill_viridis_d(option = &quot;cividis&quot;) + scale_x_continuous(labels = scales::percent_format()) + labs( fill = &quot;&quot; , y = &quot;&quot; , x = &quot;Percent of Trees&quot; , title = &quot;UAS and Stem-Mapped Tree Validation Summary&quot; , subtitle = &quot;by overstory plot&quot; ) + theme_light() + theme( legend.position = &quot;top&quot; , legend.direction = &quot;horizontal&quot; , legend.title = element_text(size=7) , axis.title.x = element_text(size=10, face = &quot;bold&quot;) , axis.title.y = element_blank() , axis.text.x = element_blank() , axis.text.y = element_text(color = &quot;black&quot;,size=10, face = &quot;bold&quot;) , axis.ticks.x = element_blank() ) + guides( fill = guide_legend(reverse = T, override.aes = list(alpha = 0.9)) ) 6.3.2 F-score field_uas_comparison_plot %&gt;% dplyr::distinct(plot_lab, plot_f_score) %&gt;% ggplot( mapping = aes(x = plot_f_score, y = reorder(plot_lab, plot_f_score), fill=plot_f_score, label = scales::comma(plot_f_score, accuracy = 0.01)) ) + geom_vline( xintercept = field_uas_comparison_plot %&gt;% dplyr::distinct(plot_lab, plot_f_score) %&gt;% dplyr::pull(plot_f_score) %&gt;% median() , color = &quot;gray44&quot; , linetype = &quot;dashed&quot; ) + geom_col( width = 0.7, alpha=0.8 ) + geom_text( color = &quot;black&quot;, size = 3.5 , hjust = -0.1 ) + annotate( &quot;text&quot; , x = field_uas_comparison_plot %&gt;% dplyr::distinct(plot_lab, plot_f_score) %&gt;% dplyr::pull(plot_f_score) %&gt;% median() , y = 0 , label = paste0( &quot;median: &quot; , field_uas_comparison_plot %&gt;% dplyr::distinct(plot_lab, plot_f_score) %&gt;% dplyr::pull(plot_f_score) %&gt;% median() %&gt;% scales::comma(accuracy = 0.01) ) , hjust = -0.1 , vjust = -1 ) + scale_fill_viridis_c(option = &quot;mako&quot;, direction = -1) + labs( fill = &quot;&quot; , y = &quot;&quot; , x = &quot;F-Score&quot; , title = &quot;UAS and Stem-Mapped Tree F-Score Summary&quot; , subtitle = &quot;by overstory plot&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.title.x = element_text(size=10, face = &quot;bold&quot;) , axis.title.y = element_blank() , axis.text.x = element_blank() , axis.text.y = element_text(color = &quot;black&quot;,size=10, face = &quot;bold&quot;) , axis.ticks.x = element_blank() ) 6.3.3 Height vs. DBH of \\(Tp\\), \\(Co\\), \\(Om\\) field_uas_comparison %&gt;% dplyr::mutate( dbh_temp = dplyr::coalesce(field_dbh_in, uas_dbh_in) , ht_temp = dplyr::coalesce(field_tree_height_ft, uas_tree_height_ft) ) %&gt;% ggplot( mapping = aes(x = ht_temp, y = dbh_temp, color = field_uas_group) ) + geom_point( mapping = aes(shape = field_uas_group) , alpha=0.8 , size=2 ) + scale_color_viridis_d(option = &quot;cividis&quot;) + scale_x_continuous(breaks = scales::extended_breaks(n=8)) + scale_y_continuous(breaks = scales::extended_breaks(n=8)) + labs( color = &quot;detection&quot; , shape = &quot;detection&quot; , y = &quot;DBH (in)&quot; , x = &quot;Tree Ht. (ft)&quot; , title = &quot;UAS and Stem-Mapped Tree Validation Summary&quot; , subtitle = &quot;height and DBH relationship&quot; ) + theme_light() + theme( legend.position = &quot;top&quot; , legend.direction = &quot;horizontal&quot; , legend.title = element_blank() ) + guides( color = guide_legend(reverse = T, override.aes = list(alpha = 0.9, size = 5)) , shape = guide_legend(reverse = T, override.aes = list(alpha = 0.9, size = 5)) ) 6.3.4 Height and DBH Distribution \\(Tp\\), \\(Co\\), \\(Om\\) field_uas_comparison %&gt;% dplyr::mutate( dbh = dplyr::coalesce(field_dbh_in, uas_dbh_in) , height = dplyr::coalesce(field_tree_height_ft, uas_tree_height_ft) ) %&gt;% dplyr::select(dbh, height, field_uas_group) %&gt;% tidyr::pivot_longer(cols = -c(field_uas_group), names_to = &quot;metric&quot;, values_to = &quot;value&quot;) %&gt;% dplyr::group_by(field_uas_group,metric) %&gt;% dplyr::mutate( metric = dplyr::case_when( metric == &quot;dbh&quot; ~ &quot;DBH (in)&quot; , metric == &quot;height&quot; ~ &quot;Height (ft)&quot; ) , n_rows = dplyr::n() , plot_lab = paste0( field_uas_group ,&quot; (n=&quot;, scales::comma(n_rows,accuracy=1),&quot;)&quot; ) ) %&gt;% ggplot(mapping = aes(x = value, y = plot_lab, fill = field_uas_group)) + geom_violin(outlier.shape = NA) + geom_boxplot(width = 0.1, outlier.shape = NA, color = &quot;gray66&quot;) + facet_grid(cols = vars(metric), scales = &quot;free_x&quot;) + scale_fill_viridis_d(option = &quot;cividis&quot;) + scale_x_continuous(breaks = scales::extended_breaks(n=8)) + labs( fill = &quot;&quot; , y = &quot;&quot; , x = &quot;&quot; , title = &quot;UAS and Stem-Mapped Tree Validation Summary&quot; , subtitle = &quot;height and DBH distribution comparison&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.title.x = element_text(size=10, face = &quot;bold&quot;) , axis.title.y = element_blank() , axis.text.y = element_text(color = &quot;black&quot;,size=10, face = &quot;bold&quot;, hjust = 0) , strip.text = element_text(color = &quot;black&quot;, size = 12) , strip.background = element_rect(fill = &quot;gray88&quot;) ) 6.3.5 Detected Overstory (\\(TP\\)) Height Difference Detected overstory tree (\\(TP\\)) height reliability. Where overstory trees considered in this analysis had a tree height &gt;= 4.5 ft and a tree DBH &gt;= 5.0 in. field_uas_comparison %&gt;% dplyr::filter(field_uas_group == &quot;true positive&quot;) %&gt;% dplyr::group_by(plot_lab) %&gt;% dplyr::mutate( reorder_y = median(height_diff_pct, na.rm=T) , color_box = reorder_y&lt;0 , n_rows = dplyr::n() , plot_lab = paste0( plot_lab ,&quot; (n=&quot;, scales::comma(n_rows,accuracy=1),&quot;)&quot; ) ) %&gt;% ggplot(mapping = aes(x = height_diff_pct, y = reorder(plot_lab, reorder_y) )) + # height_diff_pct geom_vline(xintercept = 0, color = &quot;gray22&quot;) + geom_boxplot(mapping = aes(fill = color_box), alpha = 0.8, width = 0.7, outlier.shape = NA) + scale_fill_manual(values = c(&quot;steelblue&quot;, &quot;coral&quot;)) + geom_point(color = &quot;black&quot;, shape = &quot;.&quot;) + scale_x_continuous( labels = scales::percent_format() , breaks = scales::extended_breaks(n=8) , limits = c( -max(field_uas_comparison$abs_height_diff_pct, na.rm = T) , max(field_uas_comparison$abs_height_diff_pct, na.rm = T) ) ) + labs( fill = &quot;&quot; , y = &quot;&quot; , x = &quot;Percent Difference in Height&quot; , title = &quot;Detected Overstory Height Difference&quot; , subtitle = &quot;by overstory plot&quot; , caption = &quot;-values = UAS&lt;field | +values = UAS&gt;field&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.title.x = element_text(size=10, face = &quot;bold&quot;) , axis.title.y = element_blank() , axis.text.y = element_text(color = &quot;black&quot;,size=10, face = &quot;bold&quot;, hjust = 0) ) 6.3.6 Detected Overstory (\\(TP\\)) DBH Difference Detected overstory tree (\\(TP\\)) DBH reliability. Where overstory trees considered in this analysis had a tree height &gt;= 4.5 ft and a tree DBH &gt;= 5.0 in. field_uas_comparison %&gt;% dplyr::filter(field_uas_group == &quot;true positive&quot;) %&gt;% dplyr::group_by(plot_lab) %&gt;% dplyr::mutate( reorder_y = median(dbh_diff_pct, na.rm=T) , color_box = reorder_y&lt;0 , n_rows = dplyr::n() , plot_lab = paste0( plot_lab ,&quot; (n=&quot;, scales::comma(n_rows,accuracy=1),&quot;)&quot; ) ) %&gt;% ggplot(mapping = aes(x = dbh_diff_pct, y = reorder(plot_lab, reorder_y) )) + # dbh_diff_pct geom_vline(xintercept = 0, color = &quot;gray22&quot;) + geom_boxplot(mapping = aes(fill = color_box), alpha = 0.8, width = 0.7, outlier.shape = NA) + scale_fill_manual(values = c(&quot;steelblue&quot;, &quot;coral&quot;)) + geom_point(color = &quot;black&quot;, shape = &quot;.&quot;) + scale_x_continuous( labels = scales::percent_format() , breaks = scales::extended_breaks(n=8) , limits = c( -max(field_uas_comparison$abs_dbh_diff_pct, na.rm = T) , max(field_uas_comparison$abs_dbh_diff_pct, na.rm = T) ) ) + labs( fill = &quot;&quot; , y = &quot;&quot; , x = &quot;Percent Difference in DBH&quot; , title = &quot;Detected Overstory DBH Difference&quot; , subtitle = &quot;by overstory plot&quot; , caption = &quot;-values = UAS&lt;field | +values = UAS&gt;field&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.title.x = element_text(size=10, face = &quot;bold&quot;) , axis.title.y = element_blank() , axis.text.y = element_text(color = &quot;black&quot;,size=10, face = &quot;bold&quot;, hjust = 0) ) 6.3.7 Detected Overstory (\\(TP\\)) Reliability Overstory trees considered in this analysis had a tree height &gt;= 4.5 ft and a tree DBH &gt;= 5.0 in. dbh_f_temp = field_uas_comparison %&gt;% dplyr::filter(field_uas_group==&quot;true positive&quot;) %&gt;% dplyr::pull(field_dbh_in) dbh_u_temp = field_uas_comparison %&gt;% dplyr::filter(field_uas_group==&quot;true positive&quot;) %&gt;% dplyr::pull(uas_dbh_in) ht_f_temp = field_uas_comparison %&gt;% dplyr::filter(field_uas_group==&quot;true positive&quot;) %&gt;% dplyr::pull(field_tree_height_ft) ht_u_temp = field_uas_comparison %&gt;% dplyr::filter(field_uas_group==&quot;true positive&quot;) %&gt;% dplyr::pull(uas_tree_height_ft) data.frame( mae_dbh = Metrics::mae( dbh_f_temp , dbh_u_temp ) , mape_dbh = Metrics::mape( dbh_f_temp , dbh_u_temp ) , rmse_dbh = Metrics::rmse( dbh_f_temp , dbh_u_temp ) ## height , mae_height = Metrics::mae( ht_f_temp , ht_u_temp ) , mape_height = Metrics::mape( ht_f_temp , ht_u_temp ) , rmse_height = Metrics::rmse( ht_f_temp , ht_u_temp ) ) %&gt;% tidyr::pivot_longer(dplyr::everything()) %&gt;% tidyr::separate_wider_delim(cols = name, delim = &quot;_&quot;, names = c(&quot;error&quot;, &quot;metric&quot;)) %&gt;% tidyr::pivot_wider(names_from = error, values_from = value) %&gt;% dplyr::mutate( metric = dplyr::case_when( metric == &quot;dbh&quot; ~ &quot;DBH (in)&quot; , metric == &quot;height&quot; ~ &quot;Height (ft)&quot; ) , n = field_uas_comparison %&gt;% dplyr::filter(field_uas_group==&quot;true positive&quot;) %&gt;% nrow() ) %&gt;% kableExtra::kbl( caption = &quot;Detected overstory tree height and DBH prediction performance&quot; , col.names = c( &quot; &quot; , &quot;Mean Abs. Error&quot; , &quot;Mean Abs. Percent Error&quot; , &quot;Root Mean Squared Error&quot; , &quot;N&quot; ) , digits = 2 ) %&gt;% kableExtra::kable_styling() Table 6.2: Detected overstory tree height and DBH prediction performance Mean Abs. Error Mean Abs. Percent Error Root Mean Squared Error N DBH (in) 1.52 0.17 2.08 300 Height (ft) 1.19 0.03 1.60 300 6.3.8 Detected Overstory (\\(TP\\)) Distribution Comparison field_uas_comparison %&gt;% dplyr::filter(field_uas_group==&quot;true positive&quot;) %&gt;% dplyr::select(c( tidyselect::ends_with(&quot;_dbh_in&quot;) , tidyselect::ends_with(&quot;_height_ft&quot;) )) %&gt;% dplyr::rename_with( .fn = function(x){dplyr::case_when( stringr::str_ends(x,&quot;_dbh_in&quot;) ~ stringr::str_replace(x,&quot;_dbh_in&quot;,&quot;_dbh&quot;) , stringr::str_ends(x,&quot;_tree_height_ft&quot;) ~ stringr::str_replace(x,&quot;_tree_height_ft&quot;,&quot;_height&quot;) , TRUE ~ x )} ) %&gt;% tidyr::pivot_longer(dplyr::everything()) %&gt;% tidyr::separate_wider_delim( cols = name , delim = &quot;_&quot; , names = c(&quot;source&quot;, &quot;metric&quot;) ) %&gt;% dplyr::mutate( metric = dplyr::case_when( metric == &quot;dbh&quot; ~ &quot;DBH (in)&quot; , metric == &quot;height&quot; ~ &quot;Height (ft)&quot; ) , source = dplyr::case_when( source == &quot;uas&quot; ~ &quot;UAS&quot; , source == &quot;field&quot; ~ &quot;Stem Map&quot; ) , n = field_uas_comparison %&gt;% dplyr::filter(field_uas_group==&quot;true positive&quot;) %&gt;% nrow() ) %&gt;% ggplot(mapping = aes(x = value, y = source )) + geom_boxplot(mapping = aes(fill = source), alpha = 0.8, width = 0.7, outlier.shape = NA) + # geom_point(color = &quot;black&quot;, shape = &quot;.&quot;) + facet_grid(cols = vars(metric), scales = &quot;free_x&quot;) + scale_fill_manual(values = c(&quot;seagreen&quot;, &quot;slateblue&quot;)) + labs( fill = &quot;&quot; , y = &quot;&quot; , x = &quot;&quot; , title = &quot;Detected Overstory Distribution Comparison&quot; , subtitle = paste0( &quot;tree height &gt;= &quot; , scales::comma(min_tree_height_m*3.28, accuracy = 0.1) , &quot; ft and tree DBH &gt;= &quot; , scales::comma(min_tree_dbh_cm*0.394, accuracy = 0.1) , &quot; in&quot; ) ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.title.x = element_text(size=10, face = &quot;bold&quot;) , axis.title.y = element_blank() , axis.text.y = element_text(color = &quot;black&quot;,size=10, face = &quot;bold&quot;, hjust = 0) , strip.text = element_text(color = &quot;black&quot;, size = 12) , strip.background = element_rect(fill = &quot;gray88&quot;) ) 6.4 Commission and Omission Locations field_uas_comparison = field_uas_comparison %&gt;% dplyr::mutate( x = ifelse(!is.na(uas_tree_utm_x), uas_tree_utm_x, field_tree_utm_x) , y = ifelse(!is.na(uas_tree_utm_x), uas_tree_utm_y, field_tree_utm_y) ) %&gt;% sf::st_as_sf( coords = c(&quot;x&quot;, &quot;y&quot;) , crs = sf::st_crs(treetops_sf_with_dbh) , remove=T ) View omissions and commissions on satellite imagery field_overstory %&gt;% sf::st_drop_geometry() %&gt;% dplyr::distinct(plot_id, utm_x, utm_y) %&gt;% sf::st_as_sf(coords = c(&quot;utm_x&quot;, &quot;utm_y&quot;), crs = sf::st_crs(treetops_sf_with_dbh)) %&gt;% sf::st_buffer(11.35) %&gt;% dplyr::mutate(x=1) %&gt;% mapview::mapview( col.regions = &quot;blue&quot;, layer.name = &quot;plot&quot;, alpha.regions = 0.6 , popup = F ) + mapview::mapview( field_uas_comparison %&gt;% dplyr::filter(field_uas_group %in% c(&quot;commission&quot;, &quot;omission&quot;)) , zcol = &quot;field_uas_group&quot; , col.regions = viridis::cividis(n=3)[1:2] , cex = 2 , alpha.regions = 0.8 , layer.name = &quot;validation&quot; ) + mapview::mapview( harvests , color = &quot;black&quot; , lwd = 3 , alpha.regions = 0 , label = FALSE , legend = FALSE , popup = FALSE ) 6.4.1 Othomosaic Commission and Omission Locations Define function to plot orthomosaic + CHM + tree points + plot ###################################################################################### # function to plot ortho + chm + points + stand ###################################################################################### ortho_plt_fn = function(my_plotid){ # plot vector plot_temp = field_overstory %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(plot_id == my_plotid) %&gt;% dplyr::group_by(plot_id) %&gt;% dplyr::summarise( utm_x = dplyr::first(utm_x, na_rm = T), utm_y = dplyr::first(utm_y, na_rm = T) ) %&gt;% dplyr::mutate( plot_lab = stringr::str_pad(plot_id, width = 4, side = &quot;left&quot;, pad = &quot;0&quot;) ) %&gt;% sf::st_as_sf(coords = c(&quot;utm_x&quot;, &quot;utm_y&quot;), crs = sf::st_crs(treetops_sf_with_dbh)) %&gt;% sf::st_buffer(11.35) # convert to stars ortho_st = ortho_rast %&gt;% terra::subset(subset = c(1,2,3)) %&gt;% terra::crop( # stand %&gt;% plot_temp %&gt;% sf::st_buffer(5) %&gt;% sf::st_bbox() %&gt;% sf::st_as_sfc() %&gt;% terra::vect() ) %&gt;% # terra::aggregate(fact = 2, fun = &quot;mean&quot;, na.rm = T) %&gt;% stars::st_as_stars() # convert to rgb ortho_rgb &lt;- stars::st_rgb( ortho_st[,,,1:3] , dimension = 3 , use_alpha = FALSE # , stretch = &quot;histogram&quot; , probs = c(0.005, 0.995) , stretch = &quot;percent&quot; ) # ggplot plt_rgb &lt;- ggplot() + stars::geom_stars(data = ortho_rgb[]) + scale_fill_identity(na.value = &quot;transparent&quot;) + # !!! don&#39;t take this out or RGB plot will kill your computer scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + labs( x = &quot;&quot; , y = &quot;&quot; ) + theme_void() # return(plt_rgb) ## combine all plot elements plt_combine = plt_rgb + ggnewscale::new_scale_fill() + geom_tile( data = chm_rast %&gt;% terra::crop( plot_temp %&gt;% terra::vect() ) %&gt;% terra::mask( plot_temp %&gt;% terra::vect() ) %&gt;% `*`(3.28) %&gt;% # transform to feet as.data.frame(xy=T) %&gt;% rename(f=3) , mapping = aes(x=x,y=y,fill=f) ) + scale_fill_viridis_c( option=&quot;plasma&quot;, alpha = 0.6, name = &quot;canopy ht. (ft)&quot; , limits = c( min(terra::values(chm_rast), na.rm = T)*3.28 , max(terra::values(chm_rast), na.rm = T)*3.28 ) ) + geom_sf( data = plot_temp , alpha = 0 , lwd = 1.2 , color = &quot;blue&quot; ) + ggnewscale::new_scale_fill() + geom_sf( data = field_uas_comparison %&gt;% dplyr::filter(plot_id == my_plotid) , mapping = aes(fill = field_uas_group) , color = &quot;black&quot; , shape = 21 , size = 2 ) + # scale_fill_manual(values = viridis::cividis(n=3)[1:2], name = &quot;trees&quot;) + scale_fill_viridis_d(option = &quot;cividis&quot;, name = &quot;trees&quot;, drop = F) + labs( title = paste0( &quot;Plot ID: &quot; , field_uas_comparison %&gt;% dplyr::filter(plot_id == my_plotid) %&gt;% dplyr::pull(plot_lab) %&gt;% unique() ) ) + theme( legend.position = &quot;top&quot; , legend.direction = &quot;horizontal&quot; , legend.margin = margin(0,0,-1,0) , legend.text = element_text(size = 8) , legend.title = element_text(size = 8, face = &quot;bold&quot;) , plot.title = ggtext::element_markdown(size = 10, hjust = 0.5) ) + guides( fill = guide_legend(override.aes = list(size = c(5,NULL))) ) return(plt_combine) } # ortho_plt_fn(2) Plot orthomosaic + CHM + tree points + plot for all plots with at least one omisson or commission # map over plots with omissions and commisssions field_uas_plts = field_uas_comparison %&gt;% dplyr::filter(field_uas_group %in% c(&quot;commission&quot;, &quot;omission&quot;)) %&gt;% dplyr::pull(plot_id) %&gt;% unique() %&gt;% sort() %&gt;% purrr::map(ortho_plt_fn) Combine plots patchwork::wrap_plots( field_uas_plts[] , ncol = 4 ) + patchwork::plot_layout(guides=&quot;collect&quot;) &amp; theme( legend.position = &quot;bottom&quot; , legend.direction = &quot;horizontal&quot; ) "],["ustory_valid.html", "Section 7 Regeneration Field Validation Data 7.1 Load Field Data 7.2 Create Data to Compare to UAS 7.3 UAS Estimated Regeneration", " Section 7 Regeneration Field Validation Data The 2023-06 BHEF field surveys used \\(\\frac{1}{400}\\) acre (10.117 m2) plots with a 5.89 ft (1.795 m) radius for regeneration sampling. 7.1 Load Field Data Load the regeneration data, set parameters for processing, and map # load Field Validation Data field_regen = readr::read_csv( file = &quot;../data/field_data/Voodoo_regen_data.csv&quot; ) %&gt;% dplyr::rename_with(~ .x %&gt;% # replace all non alphanumeric with _ stringr::str_replace_all(&quot;[^[:alnum:] ]+&quot;, &quot;_&quot;) %&gt;% # remove any _ at the end of the string stringr::str_remove(&quot;[_]$&quot;) %&gt;% tolower() ) %&gt;% dplyr::filter( !is.na(plot_id) &amp; !is.na(utm_x) &amp; !is.na(utm_y) &amp; !is.na(regen_size_class) &amp; regen_size_class != &quot;&quot; ) %&gt;% dplyr::mutate( plot_dir_id = paste0( stringr::str_pad(plot_id, width = 4, side = &quot;left&quot;, pad = &quot;0&quot;) , &quot;-&quot; , tolower(select_the_regen_plot_center_north_or_south) ) , regen_size_class = regen_size_class %&gt;% stringr::str_squish() %&gt;% tolower() , regen_size_class_diam = dplyr::case_when( stringr::str_detect(regen_size_class, &quot;inch&quot;) ~ regen_size_class %&gt;% stringr::word(1, sep = &quot;inch&quot;) %&gt;% stringr::str_squish() , T ~ as.character(NA) ) ) %&gt;% dplyr::relocate(plot_dir_id) %&gt;% # remove duplicates dplyr::group_by(plot_dir_id, regen_size_class) %&gt;% dplyr::filter(dplyr::row_number()==1) %&gt;% dplyr::ungroup() %&gt;% # separate diameter size class inches tidyr::separate_wider_delim( cols = regen_size_class_diam , delim = &quot;-&quot; , names = c( &quot;diam_inch_class_lower&quot; , &quot;diam_inch_class_upper&quot; ) , too_few = &quot;align_start&quot; , cols_remove = F ) %&gt;% sf::st_as_sf( coords = c(&quot;utm_x&quot;, &quot;utm_y&quot;) , crs = sf::st_crs(treetops_sf_with_dbh) , remove=F ) %&gt;% # keep only points that are within the uas flight boundary sf::st_intersection(las_ctg_dta) # data structure field_regen %&gt;% dplyr::glimpse() ## Rows: 298 ## Columns: 20 ## $ plot_dir_id &lt;chr&gt; &quot;0045-north&quot;, &quot;0045-north&quot;~ ## $ plot_id &lt;dbl&gt; 45, 45, 45, 45, 45, 45, 45~ ## $ mainid &lt;chr&gt; &quot;48815e9d-39ba-4978-bab4-8~ ## $ subid &lt;chr&gt; &quot;d388d460-3d15-454c-ac9c-d~ ## $ observers_on_plot &lt;chr&gt; &quot;WT,HK,TD,CM,VH&quot;, &quot;WT,HK,T~ ## $ collection_date &lt;chr&gt; &quot;6/6/2023 18:00&quot;, &quot;6/6/202~ ## $ comments_on_plot_condition_or_abnormalities &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA~ ## $ x &lt;dbl&gt; -103.6228, -103.6228, -103~ ## $ y &lt;dbl&gt; 44.14282, 44.14282, 44.142~ ## $ select_the_regen_plot_center_north_or_south &lt;chr&gt; &quot;North&quot;, &quot;North&quot;, &quot;South&quot;,~ ## $ regen_size_class &lt;chr&gt; &quot;&lt; 4.5 ft tall&quot;, &quot;1-2 inch~ ## $ number_of_trees_in_size_class &lt;dbl&gt; 13, 1, 6, 18, 9, 3, 9, 2, ~ ## $ average_tree_height_feet &lt;dbl&gt; 2.0, 6.0, 2.0, 5.5, 6.0, 1~ ## $ regen_remarks &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA~ ## $ utm_x &lt;dbl&gt; 610342.6, 610342.6, 610342~ ## $ utm_y &lt;dbl&gt; 4888774, 4888774, 4888756,~ ## $ diam_inch_class_lower &lt;chr&gt; NA, &quot;1&quot;, NA, &quot;0&quot;, &quot;1&quot;, &quot;2&quot;~ ## $ diam_inch_class_upper &lt;chr&gt; NA, &quot;2&quot;, NA, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;~ ## $ regen_size_class_diam &lt;chr&gt; NA, &quot;1-2&quot;, NA, &quot;0-1&quot;, &quot;1-2~ ## $ geometry &lt;POINT [m]&gt; POINT (610342.6 4888~ # count by regen class field_regen %&gt;% sf::st_drop_geometry() %&gt;% dplyr::count(regen_size_class, regen_size_class_diam) %&gt;% kableExtra::kbl() %&gt;% kableExtra::kable_styling() regen_size_class regen_size_class_diam n 0-1 inch 0-1 62 1-2 inch 1-2 54 2-3 inch 2-3 32 3-4 inch 3-4 14 4-5 inch 4-5 10 &lt; 4.5 ft tall NA 94 no trees NA 32 7.1.1 Regeneration Field Data Plot Map field_regen %&gt;% sf::st_drop_geometry() %&gt;% dplyr::distinct(plot_dir_id, utm_x, utm_y) %&gt;% sf::st_as_sf(coords = c(&quot;utm_x&quot;, &quot;utm_y&quot;), crs = sf::st_crs(treetops_sf_with_dbh)) %&gt;% dplyr::mutate(x=1) %&gt;% mapview::mapview(col.regions = &quot;tan&quot;, layer.name = &quot;regen plot&quot;, alpha.regions = 0.6) + mapview::mapview( harvests , color = &quot;black&quot; , lwd = 3 , alpha.regions = 0 , label = FALSE , legend = FALSE , popup = FALSE ) 7.2 Create Data to Compare to UAS The process used below identifies all plots sampled to create a full dataset containing all possible diameter size classes sampled in the field including for plots on which there were 0 trees in a particular size class. # row unique by plot_dir_id, regen_size_class_diam field_regen_plt_diam = dplyr::cross_join( # plot ids field_regen %&gt;% dplyr::distinct(plot_dir_id, geometry) # possible diameter size classes ... # ...excludes regen_size_class %in% c(&quot;no trees&quot;, &quot;&lt;4.5 ft tall&quot;) # ...includes stringr::str_detect(regen_size_class, &quot;inch&quot;) , field_regen %&gt;% dplyr::filter(!is.na(regen_size_class_diam)) %&gt;% dplyr::distinct(regen_size_class_diam, diam_inch_class_upper, diam_inch_class_lower) ) %&gt;% # join with original data dplyr::left_join( field_regen %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select( plot_dir_id, regen_size_class_diam , number_of_trees_in_size_class, average_tree_height_feet ) , by = dplyr::join_by(plot_dir_id, regen_size_class_diam) ) %&gt;% # fill with valid zero data dplyr::mutate( number_of_trees_in_size_class = dplyr::coalesce(number_of_trees_in_size_class, 0) , plot_area_ac = 1/400 , plot_area_ha = plot_area_ac/2.471 ) ################################################################################# ################################################################################# # Join tree tops with forest stands # row unique by suid, plot_dir_id, regen_size_class_diam ################################################################################# ################################################################################# harvests_regen_plt_diam = harvests %&gt;% dplyr::mutate( stand_area_m2 = sf::st_area(.) %&gt;% as.numeric() , stand_area_ha = stand_area_m2/10000 ) %&gt;% sf::st_intersection(las_ctg_dta) %&gt;% dplyr::mutate( intrsct_stand_area_m2 = sf::st_area(.) %&gt;% as.numeric() ) %&gt;% dplyr::filter(round(intrsct_stand_area_m2, 0) == round(stand_area_m2, 0)) %&gt;% dplyr::select( suid, forest_commonname, admin_region_code, activity_name , treatment_type, treatment_type_grp, date_compl, year_id , stand_area_m2, stand_area_ha ) %&gt;% sf::st_intersection(field_regen_plt_diam) This data contains a row for every plot surveyed and every diameter size class in the regeneration sampling protocol, including plots with 0 observations for a size class. field_regen_plt_diam %&gt;% sf::st_drop_geometry() %&gt;% dplyr::arrange(plot_dir_id,diam_inch_class_lower) %&gt;% dplyr::select(plot_dir_id, regen_size_class_diam, number_of_trees_in_size_class) %&gt;% dplyr::slice_head(n=10) %&gt;% kableExtra::kbl(digits = 1) %&gt;% kableExtra::kable_styling() plot_dir_id regen_size_class_diam number_of_trees_in_size_class 0001-center 0-1 1 0001-center 1-2 0 0001-center 2-3 0 0001-center 3-4 0 0001-center 4-5 0 0001-north 0-1 15 0001-north 1-2 5 0001-north 2-3 0 0001-north 3-4 0 0001-north 4-5 0 Summary statistics by regeneration size class field_regen_plt_diam %&gt;% sf::st_drop_geometry() %&gt;% dplyr::group_by(regen_size_class_diam) %&gt;% dplyr::summarise( number_of_plots = dplyr::n() , min_num_trees = min(number_of_trees_in_size_class, na.rm = T) , max_num_trees = max(number_of_trees_in_size_class, na.rm = T) , mean_num_trees = mean(number_of_trees_in_size_class, na.rm = T) , median_num_trees = median(number_of_trees_in_size_class, na.rm = T) ) %&gt;% kableExtra::kbl(digits = 1) %&gt;% kableExtra::kable_styling() regen_size_class_diam number_of_plots min_num_trees max_num_trees mean_num_trees median_num_trees 0-1 138 0 35 3.4 0 1-2 138 0 14 1.6 0 2-3 138 0 4 0.4 0 3-4 138 0 5 0.2 0 4-5 138 0 2 0.1 0 7.2.1 Field Regeneration TPA by Size Class The 2023-06 BHEF field surveys used \\(\\frac{1}{400}\\) acre (10.117 m2) plots with a 5.89 ft (1.795 m) radius for regeneration sampling. Aggregated across all plots sampled what was the estimated regeneration trees per acre by size class? # total tpa_temp = field_regen_plt_diam %&gt;% sf::st_drop_geometry() %&gt;% dplyr::group_by(plot_dir_id) %&gt;% dplyr::mutate(plot_area_ac = ifelse(dplyr::row_number()==1,plot_area_ac,0)) %&gt;% dplyr::ungroup() %&gt;% dplyr::summarise( tpa = sum(number_of_trees_in_size_class)/sum(plot_area_ac) ) %&gt;% dplyr::pull(tpa) # plot plt_fld_tpa_diam = field_regen_plt_diam %&gt;% sf::st_drop_geometry() %&gt;% dplyr::group_by(regen_size_class_diam) %&gt;% dplyr::summarise( number_of_plots = dplyr::n() , sum_num_trees = sum(number_of_trees_in_size_class) , sampled_area_ac = sum(plot_area_ac) , sampled_area_ha = sum(plot_area_ha) ) %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate( trees_per_ac = sum_num_trees/sampled_area_ac , trees_per_ha = sum_num_trees/sampled_area_ha , regen_size_class_diam = regen_size_class_diam %&gt;% factor() %&gt;% forcats::fct_rev() , pct = trees_per_ac/sum(trees_per_ac) ) %&gt;% ggplot( mapping = aes( x = trees_per_ac, y = regen_size_class_diam , fill=trees_per_ac , label = paste0( scales::comma(trees_per_ac, accuracy = 0.1) , &quot;\\n&quot; , scales::percent(pct, accuracy = 0.1) ) ) ) + geom_col( width = 0.7, alpha=0.8 ) + geom_text( color = &quot;black&quot;, size = 3.5 , hjust = -0.1 ) + scale_fill_viridis_c(option = &quot;mako&quot;, direction = -1) + scale_x_continuous(expand = expansion(mult = c(0, .15))) + labs( fill = &quot;&quot; , y = &quot;Regeneration Diameter Size Class (in)&quot; , x = &quot;Trees per Acre&quot; , title = &quot;Field-Based TPA by Regeneration Diameter Size Class&quot; , subtitle = paste0( &quot;Total TPA: &quot; , scales::comma(tpa_temp, accuracy = 1) ) ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.title.x = element_text(size=10, face = &quot;bold&quot;) , axis.title.y = element_text(size=9) , axis.text.x = element_blank() , axis.text.y = element_text(color = &quot;black&quot;,size=12, face = &quot;bold&quot;) , axis.ticks.x = element_blank() , plot.title = element_text(size=10) , plot.subtitle = element_text(size=9, face = &quot;bold&quot;) ) plt_fld_tpa_diam 7.2.2 Stand Regeneration TPA Map harvests_regen_plt_diam %&gt;% sf::st_drop_geometry() %&gt;% dplyr::group_by(suid, plot_dir_id) %&gt;% dplyr::mutate(plot_area_ac = ifelse(dplyr::row_number()==1,plot_area_ac,0)) %&gt;% dplyr::group_by(suid) %&gt;% dplyr::summarise( tpa = sum(number_of_trees_in_size_class)/sum(plot_area_ac) ) %&gt;% dplyr::ungroup() %&gt;% dplyr::inner_join( harvests , by = dplyr::join_by(suid) ) %&gt;% sf::st_set_geometry(&quot;geom&quot;) %&gt;% ggplot(mapping = aes(fill = tpa)) + geom_sf(alpha = 0.8) + geom_sf_label(mapping = aes(label = scales::comma(tpa, accuracy = 1)), fill = &quot;white&quot;) + scale_fill_viridis_c(option = &quot;cividis&quot;) + labs( title = &quot;Regeneration Trees per Acre&quot; , subtitle = paste0( &quot;reneration size diameter size measured: &quot; , min(field_regen_plt_diam$diam_inch_class_lower) , &quot;-&quot; , max(field_regen_plt_diam$diam_inch_class_upper) , &quot; inches&quot; ) ) + theme_void() + theme( legend.position = &quot;none&quot; ) 7.3 UAS Estimated Regeneration The UAS data only includes trees 1.4 m (4.6 ft) and above. The average tree this tall has a diameter of 0.08 inches based on the UAS SfM-derived height to diameter allometry. # filter and plot pred_mod_best %&gt;% dplyr::filter(lower_b_in &lt; 5) %&gt;% ggplot( mapping = aes( x=tree_height_ft, y = estimate_in ) ) + geom_ribbon( mapping = aes(ymin = lower_b_in, ymax = upper_b_in) , fill = &quot;gray88&quot; , alpha = 0.5 ) + geom_line( color = &quot;gray33&quot; , lwd = 1 ) + scale_x_continuous(limits = c(0,NA), breaks=scales::breaks_extended(n=16)) + scale_y_continuous(limits = c(0,NA), breaks=scales::breaks_extended(n=8)) + labs( y = &quot;DBH (in)&quot; , x = &quot;Tree Ht. (ft)&quot; , title = &quot;Local height to DBH allometry from SfM-extracted DBH samples&quot; , subtitle = &quot;for trees predicted at DBH &lt; 5 in&quot; ) + theme_light() + theme(legend.position = &quot;none&quot;) Based on the UAS SfM-derived height to diameter allometry for the area sampled, trees below 5 inches in diameter (i.e. the cutoff for field-based regeneration sampling) have a maximum height of 30.8 feet with 90% probability. The average tree with a diameter of 5 inches is 22.6 feet. 7.3.1 UAS vs Field Regneration TPA by Size Class tpa_temp = harvests_trees %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(suid, treeID, dbh_cm, stand_area_ha, tree_height_m) %&gt;% calc_imperial_units_fn() %&gt;% dplyr::inner_join( field_regen_plt_diam %&gt;% dplyr::distinct(regen_size_class_diam, diam_inch_class_lower, diam_inch_class_upper) %&gt;% dplyr::mutate( dplyr::across(tidyselect::starts_with(&quot;diam_inch_class&quot;), as.numeric) ) , by = dplyr::join_by( dbh_in &lt; diam_inch_class_upper , dbh_in &gt;= diam_inch_class_lower ) ) %&gt;% dplyr::group_by(suid, regen_size_class_diam) %&gt;% dplyr::mutate(stand_area_ac = ifelse(dplyr::row_number()==1,stand_area_ac,0)) %&gt;% dplyr::group_by(regen_size_class_diam) %&gt;% dplyr::summarise(trees_per_ac = dplyr::n()/sum(stand_area_ac)) %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate( tot = sum(trees_per_ac), pct = trees_per_ac/tot , regen_size_class_diam = regen_size_class_diam %&gt;% factor() %&gt;% forcats::fct_rev() ) # plot plt_uas_tpa_diam = ggplot( data = tpa_temp , mapping = aes( x = trees_per_ac, y = regen_size_class_diam, fill=trees_per_ac , label = paste0( scales::comma(trees_per_ac, accuracy = 0.1) , &quot;\\n&quot; , scales::percent(pct, accuracy = 0.1) ) ) ) + geom_col( width = 0.7, alpha=0.8 ) + geom_text( color = &quot;black&quot;, size = 3.5 , hjust = -0.1 ) + scale_fill_viridis_c(option = &quot;mako&quot;, direction = -1) + scale_x_continuous(expand = expansion(mult = c(0, .15))) + labs( fill = &quot;&quot; , y = &quot;Regeneration Diameter Size Class (in)&quot; , x = &quot;Trees per Acre&quot; , title = &quot;UAS-Based TPA by Regeneration Diameter Size Class&quot; , subtitle = paste0( &quot;Total TPA: &quot; , scales::comma(tpa_temp$tot[1], accuracy = 1) ) ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.title.x = element_text(size=10, face = &quot;bold&quot;) , axis.title.y = element_text(size=9) , axis.text.x = element_blank() , axis.text.y = element_text(color = &quot;black&quot;,size=12, face = &quot;bold&quot;) , axis.ticks.x = element_blank() , plot.title = element_text(size=10) , plot.subtitle = element_text(size=9, face = &quot;bold&quot;) ) plt_uas_tpa_diam + plt_fld_tpa_diam + labs( caption = paste0( &quot;*note field-based estimates include trees &lt; &quot; , round(min_uas_dbh_in,2) , &quot; in. which are excluded from UAS data&quot; ) ) 7.3.2 UAS vs Field Regeneration TPA by Stand field_uas_regen_comp_temp = harvests_regen_plt_diam %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter( diam_inch_class_upper &gt; min_uas_dbh_in ) %&gt;% dplyr::mutate( dplyr::across( tidyselect::starts_with(&quot;diam_inch_class&quot;) , .fn = as.numeric ) , num_trees_wt = dplyr::case_when( min_uas_dbh_in &lt; diam_inch_class_upper &amp; min_uas_dbh_in &gt;= diam_inch_class_lower ~ (min_uas_dbh_in - diam_inch_class_lower) / (diam_inch_class_upper - diam_inch_class_lower) , T ~ 1 ) ) %&gt;% dplyr::group_by(suid, regen_size_class_diam) %&gt;% dplyr::summarise( number_of_plots = dplyr::n_distinct(plot_dir_id) , max_diam_inch_class_upper = max(diam_inch_class_upper) , sum_num_trees = sum(number_of_trees_in_size_class*num_trees_wt) , sampled_area_ac = sum(plot_area_ac) ) %&gt;% dplyr::group_by(suid) %&gt;% dplyr::summarise( field_trees_per_ac = sum(sum_num_trees/sampled_area_ac) , number_of_plots = max(number_of_plots) , max_diam_inch_class_upper = max(max_diam_inch_class_upper) ) %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate( min_diam_inch_class_lower = min_uas_dbh_in ) %&gt;% dplyr::inner_join( harvests_trees %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(suid, dbh_cm, stand_area_ha, tree_height_m) %&gt;% calc_imperial_units_fn() %&gt;% dplyr::filter(dbh_in &lt; 5) %&gt;% dplyr::group_by(suid) %&gt;% dplyr::summarise(uas_trees_per_ac = dplyr::n()/max(stand_area_ac)) , by = dplyr::join_by(suid) ) field_uas_regen_comp_temp %&gt;% dplyr::select(suid, field_trees_per_ac, uas_trees_per_ac) %&gt;% dplyr::mutate( abs_error = abs(uas_trees_per_ac-field_trees_per_ac) , pct_error = abs_error/field_trees_per_ac ) %&gt;% kableExtra::kbl( caption = paste0( &quot;Regeneration TPA prediction performance for trees &quot; , field_uas_regen_comp_temp$min_diam_inch_class_lower %&gt;% min() %&gt;% scales::comma(accuracy = .01) , &quot; to &quot; , field_uas_regen_comp_temp$max_diam_inch_class_upper %&gt;% max() %&gt;% scales::comma(accuracy = .01) , &quot; inches in diameter&quot; ) , col.names = c( &quot;Harvest Stand&quot; , &quot;Field TPA&quot; , &quot;UAS TPA&quot; , &quot;Abs. Error&quot; , &quot;Abs. Percent Error&quot; ) , digits = 2 ) %&gt;% kableExtra::kable_styling() Table 7.1: Regeneration TPA prediction performance for trees 0.08 to 5.00 inches in diameter Harvest Stand Field TPA UAS TPA Abs. Error Abs. Percent Error 0203088082660001000 869.27 86.96 782.31 0.90 0203088082660002000 1123.79 89.28 1034.51 0.92 0203088082660003000 928.78 117.19 811.60 0.87 0203088082660004000 919.68 120.59 799.09 0.87 0203088082660009000 1074.97 101.28 973.70 0.91 0203088082660010000 1626.91 112.72 1514.19 0.93 7.3.3 UAS vs Field Regeneration TPA in Sample Plots Limit the UAS vs Field comparison to the area within the field-based sampling plots. # aggregate field data to plot level field_regen_plt_temp = field_regen_plt_diam %&gt;% dplyr::filter( diam_inch_class_upper &gt; min_uas_dbh_in ) %&gt;% dplyr::mutate( dplyr::across( tidyselect::starts_with(&quot;diam_inch_class&quot;) , .fn = as.numeric ) , num_trees_wt = dplyr::case_when( min_uas_dbh_in &lt; diam_inch_class_upper &amp; min_uas_dbh_in &gt;= diam_inch_class_lower ~ (min_uas_dbh_in - diam_inch_class_lower) / (diam_inch_class_upper - diam_inch_class_lower) , T ~ 1 ) ) %&gt;% sf::st_set_geometry(&quot;geometry&quot;) %&gt;% dplyr::group_by(plot_dir_id, plot_area_ac, plot_area_ha, geometry) %&gt;% dplyr::summarise( max_diam_inch_class_upper = max(diam_inch_class_upper) , sum_num_trees = sum(number_of_trees_in_size_class*num_trees_wt) ) %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate( field_trees_per_ac = sum_num_trees/plot_area_ac , min_diam_inch_class_lower = min_uas_dbh_in ) %&gt;% tidyr::separate_wider_delim( cols = plot_dir_id , delim = &quot;-&quot; , names = c( &quot;plot_id&quot; , &quot;plot_direction_id&quot; ) , cols_remove = F ) %&gt;% sf::st_set_geometry(&quot;geometry&quot;) Aggregate to plot level by combining the plot_direction_id column (e.g. center, north, south). Buffer the plot points and combine the plot geometry together via sf::st_bbox to create and estimated bounding box of the area sampled in the regeneration field sampling. This area will be used to find the UAS detected trees within the bounding box to compare TPA estimates. field_regen_plt_bbox_temp = field_regen_plt_temp %&gt;% sf::st_buffer(field_regen_plt_temp$plot_area_ha[1]*10000) %&gt;% dplyr::group_by(plot_id) %&gt;% tidyr::nest() %&gt;% dplyr::mutate( bbox = purrr::map(data, function(x){ x %&gt;% sf::st_bbox() %&gt;% sf::st_as_sfc() }) ) %&gt;% tidyr::unnest(cols = c(data, bbox)) %&gt;% dplyr::group_by(plot_id) %&gt;% dplyr::summarise( geometry = sf::st_union(bbox) , sum_num_trees = sum(sum_num_trees) , sum_plot_area_ac = sum(plot_area_ac) , sum_plot_area_ha = sum(plot_area_ha) ) %&gt;% dplyr::ungroup() %&gt;% sf::st_set_geometry(&quot;geometry&quot;) %&gt;% dplyr::mutate( field_trees_per_ac = sum_num_trees/sum_plot_area_ac , bbox_area_m2 = sf::st_area(geometry) %&gt;% as.numeric() , bbox_area_ha = bbox_area_m2/10000 , bbox_area_ac = bbox_area_ha*2.471 ) mapview::mapview( field_regen_plt_bbox_temp , zcol = &quot;field_trees_per_ac&quot; , layer.name = &quot;regen bbox TPA&quot; , col.regions = viridis::cividis(n=nrow(harvests)*1.1) , alpha.regions = 0.7 , na.color = &quot;transparent&quot; , popup = F ) + mapview::mapview( harvests , color = &quot;black&quot; , lwd = 3 , alpha.regions = 0 , label = FALSE , legend = FALSE , popup = FALSE ) These boundary box sample areas are 0.19 acres (779.6 m2). Join UAS trees within the boundary box of the field regeneration sample plots field_uas_regen_comp_temp = field_regen_plt_bbox_temp %&gt;% dplyr::left_join( field_regen_plt_bbox_temp %&gt;% sf::st_intersection( harvests_trees %&gt;% dplyr::select(treeID, dbh_cm) %&gt;% calc_imperial_units_fn() %&gt;% dplyr::filter(dbh_in &lt; 5) ) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::group_by(plot_id, bbox_area_ac) %&gt;% dplyr::summarise(uas_num_trees = dplyr::n()) %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate(uas_trees_per_ac = uas_num_trees/bbox_area_ac) %&gt;% dplyr::select(plot_id, uas_trees_per_ac) , by = dplyr::join_by(plot_id) ) %&gt;% dplyr::mutate( uas_trees_per_ac = dplyr::coalesce(uas_trees_per_ac, 0) ) 7.3.4 UAS vs Field Regeneration TPA Correlation What is the relationship between the UAS-based and the Field-based regeneration TPA estimates at the level of the field sampling plot? ggplot( data = field_uas_regen_comp_temp , mapping = aes( x = uas_trees_per_ac , y = field_trees_per_ac ) ) + geom_smooth(method = &quot;lm&quot;, color = &quot;gray66&quot;, se = F) + geom_point(color = &quot;gray22&quot;) + ggpubr::stat_regline_equation( aes(label = paste(after_stat(eq.label), after_stat(rr.label), sep = &quot;~~~~~&quot;)) ) + scale_x_continuous(limits = c(0,NA), labels = scales::comma_format(accuracy = 1)) + scale_y_continuous(limits = c(0,NA), labels = scales::comma_format(accuracy = 1)) + labs( x = &quot;UAS-based regeneration TPA&quot; , y = &quot;Field-based regeneration TPA&quot; , title = &quot;UAS vs Field regeneration TPA estimates at the sample plot level&quot; ) + theme_bw() + theme(legend.position = &quot;none&quot;) 7.3.5 UAS Regeneration TPA Reliability data.frame( mae_tpa = Metrics::mae( field_uas_regen_comp_temp$field_trees_per_ac , field_uas_regen_comp_temp$uas_trees_per_ac ) %&gt;% scales::comma(accuracy = 0.1) , smape_tpa = Metrics::smape( field_uas_regen_comp_temp$field_trees_per_ac , field_uas_regen_comp_temp$uas_trees_per_ac ) %&gt;% scales::percent(accuracy = 0.1) , rmse_tpa = Metrics::rmse( field_uas_regen_comp_temp$field_trees_per_ac , field_uas_regen_comp_temp$uas_trees_per_ac ) %&gt;% scales::comma(accuracy = 0.1) , n = nrow(field_uas_regen_comp_temp) %&gt;% scales::comma(accuracy = 1) ) %&gt;% kableExtra::kbl( caption = &quot;UAS regeneration TPA prediction performance&quot; , col.names = c( &quot;Mean Abs. Error&quot; , &quot;Sym. Mean Abs. Percent Error&quot; , &quot;Root Mean Squared Error&quot; , &quot;N&quot; ) ) %&gt;% kableExtra::kable_styling() Table 7.2: UAS regeneration TPA prediction performance Mean Abs. Error Sym. Mean Abs. Percent Error Root Mean Squared Error N 930.1 162.1% 1,342.7 46 "],["silv.html", "Section 8 Silvicultural Metrics 8.1 Overstory Summary 8.2 Height Distribution 8.3 Understory Summary 8.4 Define Functions for Stand Summary 8.5 Harvest Unit Summary Reports", " Section 8 Silvicultural Metrics Overstory metrics are calculated using the UAS SfM-derived DBH and height measurements, where DBH is estimated using a local DBH-Height allometric relationship. Validation of the UAS SfM-derived DBH and height measurements was completed using field-based sampling data. In the following analysis and reporting, overstory includes any tree where the DBH is 5.0 in. (12.70 cm) or greater. Understory (i.e. regeneration) metrics are calculated using the field-based sampling data reviewed in this section. The following analysis and reporting, understory includes any tree where the DBH is less than 5.0 in. (12.70 cm) or greater. # Common silvicultural metrics are calculated for the entire extent. # Note, that stand-level summaries can be computed if stand vector data is provided. # metrics include: # &quot;n_trees&quot; # &quot;stand_area_ha&quot; # &quot;trees_per_ha&quot; # &quot;mean_dbh_cm&quot; # &quot;qmd_cm&quot; # &quot;mean_tree_height_m&quot; # &quot;loreys_height_m&quot; # &quot;basal_area_m2&quot; # &quot;basal_area_m2_per_ha&quot; ### stand-level summaries silv_metrics = harvests_trees %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(dbh_cm &gt;= ostory_min_tree_dbh_cm) %&gt;% dplyr::ungroup() %&gt;% dplyr::group_by(suid,stand_area_ha) %&gt;% dplyr::summarise( n_trees = dplyr::n_distinct(treeID) , mean_dbh_cm = mean(dbh_cm, na.rm = T) , mean_tree_height_m = mean(tree_height_m, na.rm = T) , loreys_height_m = sum(basal_area_m2*tree_height_m, na.rm = T) / sum(basal_area_m2, na.rm = T) , basal_area_m2 = sum(basal_area_m2, na.rm = T) , sum_dbh_cm_sq = sum(dbh_cm^2, na.rm = T) ) %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate( trees_per_ha = (n_trees/stand_area_ha) , basal_area_m2_per_ha = (basal_area_m2/stand_area_ha) , qmd_cm = sqrt(sum_dbh_cm_sq/n_trees) ) %&gt;% dplyr::select(-c(sum_dbh_cm_sq)) %&gt;% # convert to imperial units calc_imperial_units_fn() %&gt;% dplyr::select( &quot;suid&quot; , &quot;n_trees&quot; , &quot;stand_area_ha&quot; , &quot;trees_per_ha&quot; , &quot;mean_dbh_cm&quot; , &quot;qmd_cm&quot; , &quot;mean_tree_height_m&quot; , &quot;loreys_height_m&quot; , &quot;basal_area_m2&quot; , &quot;basal_area_m2_per_ha&quot; # imperial , &quot;stand_area_ac&quot; , &quot;trees_per_ac&quot; , &quot;mean_dbh_in&quot; , &quot;qmd_in&quot; , &quot;mean_tree_height_ft&quot; , &quot;loreys_height_ft&quot; , &quot;basal_area_ft2&quot; , &quot;basal_area_ft2_per_ac&quot; ) ### export tabular write.csv( silv_metrics , paste0(delivery_dir, &quot;/stand_overstory_silv_metrics.csv&quot;) , row.names = F ) # join with spatial data silv_metrics = harvests %&gt;% # join with plot data data dplyr::inner_join( silv_metrics , by = dplyr::join_by(&quot;suid&quot;) ) ###################################################### # UNDERSTORY SUMMARY ###################################################### ustory_silv_metrics = harvests_regen_plt_diam %&gt;% sf::st_drop_geometry() %&gt;% dplyr::mutate( dplyr::across( tidyselect::starts_with(&quot;diam_inch_class&quot;) , .fn = as.numeric ) ) %&gt;% dplyr::filter( diam_inch_class_lower &lt; ustory_max_tree_dbh_cm ) %&gt;% dplyr::group_by(suid, regen_size_class_diam) %&gt;% dplyr::summarise( number_of_plots = dplyr::n_distinct(plot_dir_id) , max_diam_inch_class_upper = max(diam_inch_class_upper) , sum_num_trees = sum(number_of_trees_in_size_class) , sampled_area_ac = sum(plot_area_ac) , sampled_area_ha = sum(plot_area_ha) ) %&gt;% dplyr::mutate( size_class_trees_per_ac = sum_num_trees/sampled_area_ac , size_class_trees_per_ha = sum_num_trees/sampled_area_ha ) %&gt;% dplyr::group_by(suid) %&gt;% dplyr::mutate( unit_trees_per_ac = sum(size_class_trees_per_ac) , unit_trees_per_ha = sum(size_class_trees_per_ha) ) %&gt;% dplyr::ungroup() ### export tabular write.csv( ustory_silv_metrics , paste0(delivery_dir, &quot;/stand_understory_silv_metrics.csv&quot;) , row.names = F ) 8.1 Overstory Summary 8.1.1 Distribution of silvicultural metrics Distribution of silvicultural metrics across the 6 stands in this analysis. silv_metrics %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select( &quot;suid&quot; , &quot;stand_area_ac&quot; , &quot;n_trees&quot; , &quot;trees_per_ac&quot; , &quot;mean_dbh_in&quot; , &quot;qmd_in&quot; , &quot;mean_tree_height_ft&quot; , &quot;loreys_height_ft&quot; , &quot;basal_area_ft2_per_ac&quot; ) %&gt;% tidyr::pivot_longer( cols = -c(suid), names_to = &quot;metric&quot;, values_to = &quot;val&quot; ) %&gt;% # order metrics dplyr::mutate( metric = factor( metric , ordered = T , levels = c( &quot;stand_area_ac&quot; , &quot;n_trees&quot; , &quot;trees_per_ac&quot; , &quot;mean_tree_height_ft&quot; , &quot;loreys_height_ft&quot; , &quot;mean_dbh_in&quot; , &quot;qmd_in&quot; , &quot;basal_area_ft2_per_ac&quot; ) , labels = c( latex2exp::TeX(&quot;Stand Area (ac)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Number of Trees&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Trees $ac^{-1}$&quot;) , latex2exp::TeX(&quot;Mean Tree Height (ft)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Lorey&#39;s Mean Height (ft)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Mean DBH (in)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;QMD (in)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Basal Area $ft^{2} \\\\cdot ac^{-1}$&quot;) ) ) ) %&gt;% ggplot( mapping = aes( x = val , y = 1 ) ) + geom_boxplot(fill = &quot;gray&quot;, width = 0.7, outlier.shape = NA) + geom_point(mapping = aes(group = suid)) + facet_wrap(facets = vars(metric), ncol = 2, scales = &quot;free_x&quot;, labeller = label_parsed) + scale_x_continuous(breaks = scales::extended_breaks(6)) + scale_y_continuous(limits = c(0.5,1.5)) + labs( y = &quot;&quot; , x = &quot;&quot; , title = paste0( &quot;Overstory (&gt;= &quot; , scales::comma(ostory_min_tree_dbh_cm/2.54,accuracy = 0.1) , &quot; in. DBH) Distribution of Silvicultural Metrics&quot; ) , subtitle = paste(nrow(silv_metrics), &quot;stands included in analysis&quot;) ) + theme_light() + theme( legend.position = &quot;none&quot; , strip.text = element_text(color = &quot;black&quot;) , strip.background = element_rect(fill = &quot;gray88&quot;) , axis.text.y = element_blank() , axis.ticks.y = element_blank() , panel.grid.major.y = element_blank() , panel.grid.minor.y = element_blank() ) 8.1.2 Overstory Stand Basal Area Map mapview::mapview( bhef_boundary , color = &quot;black&quot; , lwd = 3 , alpha.regions = 0 , layer.name = &quot;BHEF&quot; , label = FALSE , legend = FALSE , popup = FALSE ) + mapview::mapview( silv_metrics , zcol = &quot;basal_area_ft2_per_ac&quot; , layer.name = &quot;BA (ft2 per ac)&quot; #latex2exp::TeX(&quot;Basal Area $ft^{2} \\\\cdot ac^{-1}$&quot;) , col.regions = viridis::cividis(n=nrow(silv_metrics)*1.1) , alpha.regions = 0.7 , na.color = &quot;transparent&quot; , popup = F ) 8.1.3 Stand QMD Map Quadratic mean diameter (QMD) is a measure of the diameter of the tree of mean basal area: \\[ \\textrm{quadratic mean diameter (QMD)} = \\sqrt{\\frac{\\sum{d_{i}^{2}}}{n}} \\] , where \\(d_{i}\\) is the diameter at breast height of an individual tree, and \\(n\\) is the total number of trees. mapview::mapview( bhef_boundary , color = &quot;black&quot; , lwd = 3 , alpha.regions = 0 , layer.name = &quot;BHEF&quot; , label = FALSE , legend = FALSE , popup = FALSE ) + mapview::mapview( silv_metrics , zcol = &quot;qmd_in&quot; , layer.name = &quot;QMD (in)&quot; #latex2exp::TeX(&quot;Basal Area $ft^{2} \\\\cdot ac^{-1}$&quot;) , col.regions = viridis::mako(n=nrow(silv_metrics)*1.1, direction = -1) , alpha.regions = 0.7 , na.color = &quot;transparent&quot; , popup = F ) 8.1.4 Overstory DBH Distrubtion harvests_trees %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(dbh_cm &gt;= ostory_min_tree_dbh_cm) %&gt;% dplyr::select(treeID, dbh_in) %&gt;% dplyr::ungroup() %&gt;% dplyr::distinct() %&gt;% ggplot( mapping = aes(x = dbh_in) ) + geom_density(alpha = 0.8, fill = &quot;navy&quot;, color = NA) + labs( x = &quot;DBH (in)&quot; , y = &quot;density&quot; , title = paste0( &quot;Overstory (&gt;= &quot; , scales::comma(ostory_min_tree_dbh_cm/2.54,accuracy = 0.1) , &quot; in. DBH) SfM-derived tree DBH distribution&quot; ) ) + scale_x_continuous(breaks = scales::extended_breaks(n=20)) + theme_light() + theme( legend.position = &quot;none&quot; ) tpa_temp = harvests_trees %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(dbh_cm &gt;= ostory_min_tree_dbh_cm) %&gt;% dplyr::select(treeID, dbh_in) %&gt;% dplyr::ungroup() %&gt;% dplyr::distinct() %&gt;% dplyr::mutate( dbh_cl = ggplot2::cut_width(dbh_in, width = 1, center = 0.5, closed = &quot;left&quot;) ) %&gt;% dplyr::group_by(dbh_cl) %&gt;% dplyr::summarise( n_trees = dplyr::n() , trees_per_ac = dplyr::n()/ (harvests %&gt;% sf::st_union() %&gt;% sf::st_area() %&gt;% as.numeric() %&gt;% `/`(10000) %&gt;% `*`(2.471)) , trees_per_ha = dplyr::n()/ (harvests %&gt;% sf::st_union() %&gt;% sf::st_area() %&gt;% as.numeric() %&gt;% `/`(10000)) ) %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate( tot_trees_per_ac = sum(trees_per_ac) , tot_trees_per_ha = sum(trees_per_ha) , pct = trees_per_ac/tot_trees_per_ac , dbh_cl_lab = paste0( stringr::word(dbh_cl, 1, sep = fixed(&quot;,&quot;)) %&gt;% readr::parse_number() , &quot; to &quot; , stringr::word(dbh_cl, -1, sep = fixed(&quot;,&quot;)) %&gt;% readr::parse_number() %&gt;% `-`(0.1) ) %&gt;% factor() %&gt;% forcats::fct_reorder(stringr::word(dbh_cl, 1, sep = fixed(&quot;,&quot;)) %&gt;% readr::parse_number()) ) # plot tpa_temp %&gt;% ggplot( mapping = aes( x = dbh_cl_lab, y = trees_per_ac , fill=trees_per_ac , label = paste0( scales::comma(trees_per_ac, accuracy = 0.1) , &quot;\\n&quot; , scales::percent(pct, accuracy = 0.1) ) ) ) + geom_col(width = 0.7) + geom_text(color = &quot;black&quot;, size = 3, vjust = -0.2) + scale_fill_viridis_c(option = &quot;mako&quot;, direction = -1) + scale_y_continuous(labels = scales::comma_format(accuracy = 1),expand = expansion(mult = c(0, .13))) + labs( x = &quot;DBH (in) Class&quot; , y = &quot;TPA&quot; , title = paste0( &quot;Overstory (&gt;= &quot; , scales::comma(ostory_min_tree_dbh_cm/2.54,accuracy = 0.1) , &quot; in. DBH) Trees Per Acre by Diameter Class&quot; ) , subtitle = paste0( &quot;Total TPA: &quot; , scales::comma(tpa_temp$tot_trees_per_ac[1], accuracy = 1) ) ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.text.x = element_text(angle = 90, size = 10, face = &quot;bold&quot;, vjust = 0.5, hjust = 1) ) 8.2 Height Distribution harvests_trees %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(dbh_cm &gt;= ostory_min_tree_dbh_cm) %&gt;% dplyr::select(treeID, tree_height_ft) %&gt;% dplyr::ungroup() %&gt;% dplyr::distinct() %&gt;% ggplot( mapping = aes(x = tree_height_ft) ) + geom_density(alpha = 0.8, fill = &quot;steelblue&quot;, color = NA) + labs( x = &quot;Height (ft)&quot; , y = &quot;density&quot; , title = paste0( &quot;Overstory (&gt;= &quot; , scales::comma(ostory_min_tree_dbh_cm/2.54,accuracy = 0.1) , &quot; in. DBH) SfM-derived tree height distribution&quot; ) ) + scale_x_continuous(breaks = scales::extended_breaks(n=10)) + theme_light() + theme( legend.position = &quot;none&quot; ) 8.3 Understory Summary # total tpa_temp = harvests_regen_plt_diam %&gt;% sf::st_drop_geometry() %&gt;% dplyr::mutate( dplyr::across( tidyselect::starts_with(&quot;diam_inch_class&quot;) , .fn = as.numeric ) ) %&gt;% dplyr::filter( diam_inch_class_lower &lt; ustory_max_tree_dbh_cm ) %&gt;% dplyr::ungroup() %&gt;% dplyr::distinct(plot_dir_id, regen_size_class_diam, number_of_trees_in_size_class, plot_area_ac, plot_area_ha) %&gt;% dplyr::group_by(regen_size_class_diam) %&gt;% dplyr::summarise( number_of_plots = dplyr::n_distinct(plot_dir_id) , sum_num_trees = sum(number_of_trees_in_size_class) , sampled_area_ac = sum(plot_area_ac) , sampled_area_ha = sum(plot_area_ha) ) %&gt;% dplyr::mutate( size_class_trees_per_ac = sum_num_trees/sampled_area_ac , size_class_trees_per_ha = sum_num_trees/sampled_area_ha ) %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate( tot_trees_per_ac = sum(size_class_trees_per_ac) , tot_trees_per_ha = sum(size_class_trees_per_ha) , pct = size_class_trees_per_ac/tot_trees_per_ac , dbh_cl_lab = paste0( stringr::word(regen_size_class_diam, 1, sep = fixed(&quot;-&quot;)) %&gt;% readr::parse_number() , &quot; to &quot; , stringr::word(regen_size_class_diam, -1, sep = fixed(&quot;-&quot;)) %&gt;% readr::parse_number() %&gt;% `-`(0.1) ) %&gt;% factor() %&gt;% forcats::fct_reorder(stringr::word(regen_size_class_diam, 1, sep = fixed(&quot;-&quot;)) %&gt;% readr::parse_number()) ) # plot tpa_temp %&gt;% ggplot( mapping = aes( x = dbh_cl_lab, y = size_class_trees_per_ac , fill=size_class_trees_per_ac , label = paste0( scales::comma(size_class_trees_per_ac, accuracy = 0.1) , &quot;\\n&quot; , scales::percent(pct, accuracy = 0.1) ) ) ) + geom_col(width = 0.7) + geom_text(color = &quot;black&quot;, size = 3, vjust = -0.2) + scale_fill_viridis_c(option = &quot;mako&quot;, direction = -1) + scale_y_continuous(labels = scales::comma_format(accuracy = 1),expand = expansion(mult = c(0, .13))) + labs( x = &quot;DBH (in) Class&quot; , y = &quot;TPA&quot; , title = paste0( &quot;Understory (&lt; &quot; , scales::comma(ustory_max_tree_dbh_cm/2.54,accuracy = 0.1) , &quot; in. DBH) Trees Per Acre by Diameter Class&quot; ) , subtitle = paste0( &quot;Total TPA: &quot; , scales::comma(tpa_temp$tot_trees_per_ac[1], accuracy = 1) ) ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.text.x = element_text(angle = 90, size = 10, face = &quot;bold&quot;, vjust = 0.5, hjust = 1) ) 8.4 Define Functions for Stand Summary Create plots to combine for report orthomosaic + chm + tree tops + stand plot ###################################################################################### # function to plot ortho + chm + points + stand ###################################################################################### ortho_plt_fn = function(my_suid){ # convert to stars ortho_st = ortho_rast %&gt;% terra::subset(subset = c(1,2,3)) %&gt;% terra::crop( # stand %&gt;% harvests %&gt;% dplyr::filter(suid==my_suid) %&gt;% sf::st_buffer(20) %&gt;% sf::st_bbox() %&gt;% sf::st_as_sfc() %&gt;% terra::vect() ) %&gt;% terra::aggregate(fact = 4, fun = &quot;mean&quot;, na.rm = T) %&gt;% stars::st_as_stars() # convert to rgb ortho_rgb &lt;- stars::st_rgb( ortho_st[,,,1:3] , dimension = 3 , use_alpha = FALSE # , stretch = &quot;histogram&quot; , probs = c(0.005, 0.995) , stretch = &quot;percent&quot; ) # ggplot plt_rgb &lt;- ggplot() + stars::geom_stars(data = ortho_rgb[]) + scale_fill_identity(na.value = &quot;transparent&quot;) + # !!! don&#39;t take this out or RGB plot will kill your computer scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + labs( x = &quot;&quot; , y = &quot;&quot; ) + theme_void() # chm chm = chm_rast %&gt;% terra::crop( harvests %&gt;% dplyr::filter(suid==my_suid) %&gt;% terra::vect() ) %&gt;% terra::mask( harvests %&gt;% dplyr::filter(suid==my_suid) %&gt;% terra::vect() ) %&gt;% terra::aggregate(fact = 2, fun = &quot;mean&quot;, na.rm = T) %&gt;% `*`(3.28) %&gt;% # transform to feet as.data.frame(xy=T) %&gt;% rename(f=3) # return(plt_rgb) # combine all plot elements plt_combine = plt_rgb + # # understory # geom_tile( # data = chm %&gt;% # dplyr::filter( # f &lt; # pred_mod_best %&gt;% # dplyr::filter(estimate_in &lt; ustory_max_tree_dbh_cm/2.54) %&gt;% # dplyr::pull(tree_height_ft) %&gt;% max() # ) # , mapping = aes(x = x, y = y) # , fill = &quot;gray&quot; # , alpha = 0.4 # , na.rm = T # ) + # overstory ggnewscale::new_scale_fill() + geom_tile( data = chm %&gt;% dplyr::filter( f &gt;= pred_mod_best %&gt;% dplyr::filter(estimate_in &gt;= ostory_min_tree_dbh_cm/2.54) %&gt;% dplyr::pull(tree_height_ft) %&gt;% min() ) , mapping = aes(x = x, y = y, fill = f) , na.rm = T ) + scale_fill_viridis_c(option=&quot;plasma&quot;, alpha = 0.6, breaks = scales::extended_breaks(n=6), na.value = &quot;transparent&quot;) + geom_sf( data = harvests %&gt;% dplyr::filter(suid==my_suid) , alpha = 0 , lwd = 1.5 , color = &quot;#b22222&quot; ) + # geom_sf( # data = treetops_sf_with_dbh %&gt;% # sf::st_intersection(harvests %&gt;% dplyr::filter(suid==my_suid)) # , color = &quot;#330099&quot; # , shape = &quot;.&quot; # ) + labs( fill = &quot;overstory\\ncanopy ht. (ft)&quot; # , title = &quot;Trees identified within stand boundary&quot; # , title = &quot;&lt;span&gt;&lt;span style=&#39;color:#330099;&#39;&gt;&lt;b&gt;&lt;i&gt;Trees&lt;/i&gt;&lt;/b&gt;&lt;/span&gt; identified within &lt;span style=&#39;color:#b22222;&#39;&gt;&lt;b&gt;&lt;i&gt;stand&lt;/i&gt;&lt;/b&gt;&lt;/span&gt; boundary&lt;/span&gt;&quot; , title = paste0( &quot;Overstory (&gt;= &quot; , scales::comma(ostory_min_tree_dbh_cm/2.54,accuracy = 0.1) , &quot; in. DBH) within stand boundary&quot; ) # , subtitle = paste0( # &quot;trees under &quot; # , scales::comma((ustory_max_tree_dbh_cm/2.54),accuracy = 0.1) # , &quot; in. DBH shown in gray&quot; # ) ) + theme( legend.position = &quot;top&quot; # c(0.5,1) , legend.direction = &quot;horizontal&quot; , legend.margin = margin(0,0,-1,0) , legend.text = element_text(size = 8) , legend.title = element_text(size = 8) # , plot.title = ggtext::element_markdown(size = 10, hjust = 0.5) , plot.title = element_text(size = 10, hjust = 0.5, face = &quot;bold&quot;) , plot.subtitle = element_text(size = 8, hjust = 0.5, face = &quot;italic&quot;) ) return(plt_combine) } # ortho_plt_fn(harvests$suid[3]) dbh distribution plot dbh_dist_fn = function(my_suid){ harvests_trees %&gt;% dplyr::filter( suid == my_suid &amp; dbh_cm &gt;= ostory_min_tree_dbh_cm ) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(treeID, dbh_in) %&gt;% dplyr::distinct() %&gt;% ggplot( mapping = aes(x = dbh_in) ) + geom_density(alpha = 0.8, fill = &quot;navy&quot;, color = NA) + labs( x = &quot;DBH (in)&quot; , y = &quot;density&quot; , title = paste0( &quot;Overstory (&gt;= &quot; , scales::comma(ostory_min_tree_dbh_cm/2.54,accuracy = 0.1) , &quot; in. DBH) DBH distribution&quot; ) ) + scale_x_continuous(breaks = scales::extended_breaks(n=20)) + theme_light() + theme( legend.position = &quot;none&quot; ) } # dbh_dist_fn(harvests$suid[1]) height distribution plot ht_dist_fn = function(my_suid){ harvests_trees %&gt;% dplyr::filter( suid == my_suid &amp; dbh_cm &gt;= ostory_min_tree_dbh_cm ) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(treeID, tree_height_ft) %&gt;% dplyr::distinct() %&gt;% ggplot( mapping = aes(x = tree_height_ft) ) + geom_density(alpha = 0.8, fill = &quot;steelblue&quot;, color = NA) + labs( x = &quot;Height (ft)&quot; , y = &quot;density&quot; , title = paste0( &quot;Overstory (&gt;= &quot; , scales::comma(ostory_min_tree_dbh_cm/2.54,accuracy = 0.1) , &quot; in. DBH) height distribution&quot; ) ) + scale_x_continuous(breaks = scales::extended_breaks(n=10)) + theme_light() + theme( legend.position = &quot;none&quot; ) } # ht_dist_fn(harvests$suid[1]) silvicultural metrics imperial table tab_imp_fn = function(my_suid){ silv_metrics %&gt;% dplyr::filter(suid == my_suid) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select( &quot;suid&quot; , &quot;stand_area_ac&quot; , &quot;n_trees&quot; , &quot;trees_per_ac&quot; , &quot;mean_dbh_in&quot; , &quot;qmd_in&quot; , &quot;mean_tree_height_ft&quot; , &quot;loreys_height_ft&quot; , &quot;basal_area_ft2_per_ac&quot; ) %&gt;% tidyr::pivot_longer( cols = -c(suid), names_to = &quot;metric&quot;, values_to = &quot;val&quot; ) %&gt;% # order metrics dplyr::mutate( metric = factor( metric , ordered = T , levels = c( &quot;stand_area_ac&quot; , &quot;n_trees&quot; , &quot;trees_per_ac&quot; , &quot;mean_tree_height_ft&quot; , &quot;loreys_height_ft&quot; , &quot;mean_dbh_in&quot; , &quot;qmd_in&quot; , &quot;basal_area_ft2_per_ac&quot; ) , labels = c( latex2exp::TeX(&quot;Stand Area (ac)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Number of Trees&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Trees $ac^{-1}$&quot;) , latex2exp::TeX(&quot;Mean Tree Height (ft)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Lorey&#39;s Mean Height (ft)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Mean DBH (in)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;QMD (in)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Basal Area $ft^{2} \\\\cdot ac^{-1}$&quot;) ) ) ) %&gt;% dplyr::mutate(val = scales::comma(val,accuracy=0.1)) %&gt;% dplyr::select(metric, val) %&gt;% ggpubr::ggtexttable( rows = NULL , cols = rep(&quot;&quot;, 2) , theme = ggpubr::ttheme( base_style = &quot;blank&quot; , tbody.style = ggpubr::tbody_style( parse = T, fill = &quot;white&quot;, linecolor = &quot;gray&quot; , size = 10 ) ) ) %&gt;% ggpubr::tab_add_title( text = paste0( &quot;Silvicultural Metrics (imperial)&quot; , &quot;\\nOverstory (&gt;= &quot; , scales::comma(ostory_min_tree_dbh_cm/2.54,accuracy = 0.1) , &quot; in. DBH)&quot; ) , face = &quot;bold&quot; , size = 10, padding = unit(0.5, &quot;line&quot;) ) } # tab_imp_fn(harvests$suid[2]) silvicultural metrics metric table tab_met_fn = function(my_suid){ silv_metrics %&gt;% dplyr::filter(suid == my_suid) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select( &quot;suid&quot; , &quot;stand_area_ha&quot; , &quot;n_trees&quot; , &quot;trees_per_ha&quot; , &quot;mean_dbh_cm&quot; , &quot;qmd_cm&quot; , &quot;mean_tree_height_m&quot; , &quot;loreys_height_m&quot; , &quot;basal_area_m2_per_ha&quot; ) %&gt;% tidyr::pivot_longer( cols = -c(suid), names_to = &quot;metric&quot;, values_to = &quot;val&quot; ) %&gt;% # order metrics dplyr::mutate( metric = factor( metric , ordered = T , levels = c( &quot;stand_area_ha&quot; , &quot;n_trees&quot; , &quot;trees_per_ha&quot; , &quot;mean_tree_height_m&quot; , &quot;loreys_height_m&quot; , &quot;mean_dbh_cm&quot; , &quot;qmd_cm&quot; , &quot;basal_area_m2_per_ha&quot; ) , labels = c( latex2exp::TeX(&quot;Stand Area (ha)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Number of Trees&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Trees $ha^{-1}$&quot;) , latex2exp::TeX(&quot;Mean Tree Height (m)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Lorey&#39;s Mean Height (m)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Mean DBH (cm)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;QMD (cm)&quot;, output = &quot;character&quot;) , latex2exp::TeX(&quot;Basal Area $m^{2} \\\\cdot ha^{-1}$&quot;) ) ) ) %&gt;% dplyr::mutate(val = scales::comma(val,accuracy=0.1)) %&gt;% dplyr::select(metric, val) %&gt;% ggpubr::ggtexttable( rows = NULL , cols = rep(&quot;&quot;, 2) , theme = ggpubr::ttheme( base_style = &quot;blank&quot; , tbody.style = ggpubr::tbody_style( parse = T, fill = &quot;white&quot;, linecolor = &quot;gray&quot; , size = 10 ) ) ) %&gt;% ggpubr::tab_add_title( text = paste0( &quot;Silvicultural Metrics (metric)&quot; , &quot;\\nOverstory (&gt;= &quot; , scales::comma(ostory_min_tree_dbh_cm,accuracy = 0.1) , &quot; cm DBH)&quot; ) , face = &quot;bold&quot; , size = 10, padding = unit(0.5, &quot;line&quot;) ) } # tab_met_fn(harvests$suid[2]) inset map plot plt_inset_map_fn &lt;- function(my_suid){ ( ggplot() + geom_sf(data = bhef_boundary, alpha = 0, lwd = 1, color = &quot;black&quot;) + geom_sf(data = harvests, alpha = 0, lwd = 0.4, color = &quot;gray&quot;) + geom_sf( data = harvests %&gt;% dplyr::filter(suid == my_suid) , fill = &quot;firebrick&quot; , alpha = 0.3 , lwd = 1 , color = &quot;firebrick&quot; ) + # geom_sf_label( # data = rx_fire # , aes(label = unit) # , label.size = NA # , alpha = 0 # , size = 2.5 # ) + xlab(&quot;&quot;) + ylab(&quot;&quot;) + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + theme_bw() + theme( axis.text = element_text(size = 3.5) , axis.text.x = element_text(angle = 35) , panel.border = element_blank() ) ) } # plt_inset_map_fn(harvests$suid[4]) contour + elevation map plot # sequence by 5&#39;s to get 5m breaks list for contour contour_int_m &lt;- 5 seq_brk &lt;- seq(0, 40000, contour_int_m) # create contour data elev_contour &lt;- dtm_rast %&gt;% stars::st_as_stars() %&gt;% stars::st_contour( na.rm = TRUE , contour_lines = FALSE , breaks = # classInt::classIntervals(na.omit(as.vector(x[[1]])))$brks seq_brk[ seq_brk &gt; min(na.omit(as.vector(dtm_rast[[1]]))) - contour_int_m &amp; seq_brk &lt; max(na.omit(as.vector(dtm_rast[[1]]))) + contour_int_m ] ) plt_contour_map_fn &lt;- function(my_suid){ ( ######################################### ######################################### # map of unit w/ contour ######################################### ######################################### # plot ggplot() + geom_tile( data = dtm_rast %&gt;% terra::crop( harvests %&gt;% dplyr::filter(suid == my_suid) %&gt;% sf::st_buffer(dist = 20) %&gt;% sf::st_bbox() %&gt;% sf::st_as_sfc() %&gt;% terra::vect() ) %&gt;% terra::aggregate(fact=2) %&gt;% `*`(3.28) %&gt;% # transform to feet as.data.frame(xy=T) %&gt;% dplyr::rename(elev = 3) , mapping = aes(x=x,y=y,fill=elev) ) + geom_sf(data = elev_contour %&gt;% sf::st_crop( harvests %&gt;% dplyr::filter(suid == my_suid) %&gt;% sf::st_buffer(dist = 20) %&gt;% sf::st_bbox() ) , alpha = 0 , lwd = 0.5 , color = &quot;gray30&quot; , show.legend = FALSE ) + geom_sf(data = harvests %&gt;% dplyr::filter(suid == my_suid) , alpha = 0 , lwd = 1.5 , color = &quot;firebrick&quot; , show.legend = FALSE ) + scale_fill_viridis_c( option = &quot;viridis&quot; , alpha = 0.9 , na.value = &quot;transparent&quot; , breaks = scales::extended_breaks(n = 6) , labels = scales::comma ) + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + labs( subtitle = paste0( as.character(round(contour_int_m * 3.28, 1)) , &quot; ft (&quot; , as.character(contour_int_m) , &quot; m) contours&quot; ) , fill = &quot;elev. (ft)&quot; , x = &quot;&quot; , y = &quot;&quot; ) + theme_void() + theme( legend.position = &quot;top&quot; , legend.direction = &quot;horizontal&quot; , legend.margin = margin(0,0,-1,0) # , legend.box.margin = margin(-1,0,2,0) , legend.text = element_text(size = 4, angle = 25, hjust = 0.7) , legend.title = element_text(size = 4) , plot.subtitle = element_text( size=5, face=&quot;italic&quot;, color=&quot;gray20&quot;, margin = margin(0,0,0,0) , hjust = 0.5 ) ) ) } # plt_contour_map_fn(harvests$suid[1]) regen by size class plt_regen_dist_fn &lt;- function(my_suid){ dta = harvests_regen_plt_diam %&gt;% sf::st_drop_geometry() %&gt;% dplyr::mutate( dplyr::across( tidyselect::starts_with(&quot;diam_inch_class&quot;) , .fn = as.numeric ) ) %&gt;% dplyr::filter( suid == my_suid &amp; diam_inch_class_lower &lt; ustory_max_tree_dbh_cm ) %&gt;% dplyr::group_by(suid,regen_size_class_diam) %&gt;% dplyr::summarise( number_of_plots = dplyr::n() , sum_num_trees = sum(number_of_trees_in_size_class) , sampled_area_ac = sum(plot_area_ac) ) %&gt;% dplyr::group_by(suid) %&gt;% dplyr::mutate( trees_per_ac = sum_num_trees/sampled_area_ac , stand_trees_per_ac = sum(sum_num_trees)/max(sampled_area_ac) , regen_size_class_diam = regen_size_class_diam %&gt;% factor() %&gt;% forcats::fct_rev() ) %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate( stand_lab = paste0( # suid &quot;\\nTotal TPA: &quot; , scales::comma(stand_trees_per_ac, accuracy = 1) ) # factor() %&gt;% forcats::fct_reorder(desc(stand_trees_per_ac)) ) ## plt ggplot( data = dta , mapping = aes( x = trees_per_ac, y = regen_size_class_diam , fill=trees_per_ac , label = scales::comma(trees_per_ac, accuracy = 0.1) ) ) + geom_col( width = 0.7 ) + geom_text( color = &quot;black&quot;, size = 2 , hjust = -0.1 ) + scale_fill_viridis_c(option = &quot;mako&quot;, direction = -1) + scale_x_continuous(expand = expansion(mult = c(0, .13))) + # facet_wrap(facets = vars(stand_lab), ncol = 3) + labs( fill = &quot;&quot; , y = &quot;DBH (in) Class&quot; , x = &quot;Trees per Acre&quot; , title = paste0( &quot;Understory (&lt; &quot; , scales::comma(ustory_max_tree_dbh_cm/2.54,accuracy = 0.1) , &quot; in. DBH) Trees Per Acre&quot; ) # , subtitle = &quot;by harvest unit (with FACTS ID)&quot; , subtitle = dta$stand_lab[1] ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.text.x = element_blank() , axis.text.y = element_text(color = &quot;black&quot;,size=12, face = &quot;bold&quot;) , axis.ticks.x = element_blank() # , strip.text = element_text(color = &quot;black&quot;, size = 12) # , strip.background = element_rect(fill = &quot;gray88&quot;) ) } # plt_regen_dist_fn(harvests$suid[2]) build report report_fn = function(my_suid){ # generate plots ortho_plt_temp = ortho_plt_fn(my_suid) # ortho_plt_fn(harvests$suid[4]) dbh_dist_temp = dbh_dist_fn(my_suid) + # dbh_dist_fn(harvests$suid[4]) theme( plot.background = element_rect(colour = &quot;gray&quot;, fill=NA, size=1) # , plot.title = element_text(size = 9) # , plot.subtitle = element_text(size = 7) ) ht_dist_temp = ht_dist_fn(my_suid) + # ht_dist_fn(harvests$suid[4]) theme( plot.background = element_rect(colour = &quot;gray&quot;, fill=NA, size=1) # , plot.title = element_text(size = 9) # , plot.subtitle = element_text(size = 7) ) plt_inset_map_temp = plt_inset_map_fn(my_suid) # plt_inset_map_fn(harvests$suid[4]) plt_contour_map_temp = plt_contour_map_fn(my_suid) # plt_contour_map_fn(harvests$suid[4]) tab_imp_temp = tab_imp_fn(my_suid) # tab_imp_fn(harvests$suid[4]) tab_met_temp = tab_met_fn(my_suid) # tab_met_fn(harvests$suid[4]) plt_regen_dist_temp = plt_regen_dist_fn(my_suid) + theme(plot.background = element_rect(colour = &quot;gray&quot;, fill=NA, size=1)) # plot layout # area(t,l,b,r) layout_temp = c( # map area(1, 2, 2, 2) # map inset , area(1, 1, 1, 1) # contour , area(2, 1, 2, 1) # # tables , area(4, 1, 5, 1) , area(6, 1, 7, 1) # space , area(3, 1, 3, 2) # # # distributions , area(5, 2, 5, 2) , area(6, 2, 6, 2) , area(7, 2, 7, 2) ) # check the layout # plot(layout_temp) # patchwork rpt = ortho_plt_temp + plt_inset_map_temp + plt_contour_map_temp + tab_imp_temp + tab_met_temp + patchwork::plot_spacer() + dbh_dist_temp + ht_dist_temp + plt_regen_dist_temp + patchwork::plot_layout( design = layout_temp , heights = c(0.7, 0.8, 0.3, 1,1,1,1) , widths = c(0.5,1) ) # export ggplot2::ggsave( filename = paste0(delivery_dir, &quot;/suid_&quot;, my_suid, &quot;.pdf&quot;) , plot = rpt , device = &quot;pdf&quot; , width = 8.5, height = 11, units = &quot;in&quot; ) return(rpt) } 8.5 Harvest Unit Summary Reports # generate and print reports harvests$suid %&gt;% # .[1] %&gt;% purrr::map(report_fn) %&gt;% print() # combine all pdfs together # combine with pdftools pdftools::pdf_combine( sort(list.files(delivery_dir, pattern = &quot;\\\\.pdf$&quot;, full.names = TRUE)) , output = paste0( delivery_dir , &quot;/BHEF_UAS_202306_report_&quot; , gsub(&quot;-&quot;, &quot;&quot;, Sys.Date()) , &quot;.pdf&quot; ) ) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
