# UAS Tree Spatial Arrangement{#tree_spatial}

## Example Tree Group Workflow

For now we'll just make a visual overview of the UAS-SfM forest inventory process to present at the 2024 National Silvicultural Workshop.

```{r}
# focus on one harvest unit
  my_suid = harvests$suid[6]
#########################
#########################
# what is overstory?
#########################
#########################
  #!!!!! fill in one...if both filled in will use DBH
  # determine overstory by height
  ostory_ht_m = as.numeric(NA) # m = ft / 3.281
  # determine overstory by diameter
  ostory_dbh_cm = 5*2.54 # cm = in * 2.54
#########################
#########################
# clump spacing
#########################
#########################
  # maximum distance between trees for determining tree clumps
    # stems within 6 m of one another were considered to have the potential for developing interlocking crowns
  tree_clump_dist_m = 6
```

Check the stand location

```{r}
# where is this
mapview::mapview(harvests %>% dplyr::filter(suid==my_suid), layer.name = "BHEF", label = FALSE, legend = FALSE, popup = FALSE)
```

### Orthomosaic from UAS

```{r, results='hide', fig.show='asis'}
######################################################################################
# function to plot ortho + stand
######################################################################################
ortho_plt_fn = function(my_suid){
# convert to stars
  ortho_st = ortho_rast %>%  
    terra::subset(subset = c(1,2,3)) %>%
    terra::crop(
      # stand %>% 
      harvests %>% dplyr::filter(suid==my_suid) %>% 
        sf::st_buffer(20) %>% 
        sf::st_bbox() %>% 
        sf::st_as_sfc() %>% 
        terra::vect()
    ) %>% 
    terra::aggregate(fact = 2, fun = "mean", na.rm = T) %>% 
    stars::st_as_stars()
  
  # convert to rgb
  ortho_rgb <- stars::st_rgb(
    ortho_st[,,,1:3]
    , dimension = 3
    , use_alpha = FALSE
    # , stretch = "histogram"
    , probs = c(0.005, 0.995)
    , stretch = "percent"
  )
  # ggplot
  plt_rgb <- ggplot() +
    stars::geom_stars(data = ortho_rgb[]) +
    scale_fill_identity(na.value = "transparent") + # !!! don't take this out or RGB plot will kill your computer
    scale_x_continuous(expand = c(0, 0)) +
    scale_y_continuous(expand = c(0, 0)) +
    labs(
      x = ""
      , y = ""
    ) +
    theme_void()
  
  # return(plt_rgb)
  # combine all plot elements
  plt_combine = plt_rgb +
    geom_sf(
      data = harvests %>% dplyr::filter(suid==my_suid)
      , alpha = 0
      , lwd = 1.5
      , color = "#b22222"
    ) +
    theme(
      legend.position = "top" # c(0.5,1)
      , legend.direction = "horizontal"
      , legend.margin = margin(0,0,0,0)
      , legend.text = element_text(size = 8)
      , legend.title = element_text(size = 8)
      , legend.key = element_rect(fill = "white")
      # , plot.title = ggtext::element_markdown(size = 10, hjust = 0.5)
      , plot.title = element_text(size = 10, hjust = 0.5, face = "bold")
      , plot.subtitle = element_text(size = 8, hjust = 0.5, face = "italic")
    )
  return(plt_combine)
}
# PLOT IT
ortho_plt_fn(my_suid) +
  labs(
    subtitle = "\nstand boundary\n"
    # subtitle = "<span style='color:#b22222;'><b><i>stand boundary</i></b></span>"
  ) +
  theme(
    plot.subtitle = element_text(size = 9.5, color = "#b22222", hjust = 0.5, face = "bold")
  )
# save it
ggplot2::ggsave("../data/NSW_01.jpeg", dpi = "print", height = 11, width = 5.8, device = "jpeg")
```

plot with CHM

```{r, results='hide', fig.show='asis'}
# chm
  chm_temp = chm_rast %>% 
    terra::crop(
      harvests %>% dplyr::filter(suid==my_suid) %>% 
      terra::vect()
    ) %>% 
    terra::mask(
      harvests %>% dplyr::filter(suid==my_suid) %>% 
      terra::vect()
    ) %>% 
    terra::aggregate(fact = 2, fun = "mean", na.rm = T) %>% 
    `*`(3.28) %>% # transform to feet
    as.data.frame(xy=T) %>% 
    rename(f=3)
  
  # plot it
  plt_chm_temp = ortho_plt_fn(my_suid) +
    # chm
    ggnewscale::new_scale_fill() +
    geom_tile(
      data = chm_temp
      , mapping = aes(x = x, y = y, fill = f)
      , na.rm = T
    ) +
    scale_fill_viridis_c(option="plasma", alpha = 0.8, breaks = scales::extended_breaks(n=6), na.value = "transparent") +
    labs(fill = "CHM (ft)")

# PLOT IT
plt_chm_temp
  
# save it
ggplot2::ggsave("../data/NSW_02.jpeg", dpi = "print", height = 11, width = 5.8, device = "jpeg")

```

### ITD

individual trees detected from `lidR::locate_trees()`

```{r, include=FALSE,eval=FALSE}
ortho_plt_fn(my_suid) + plt_chm_temp + 
  patchwork::plot_annotation(tag_levels = list(c("hey","guy"))) & 
  theme(
    plot.tag.position = c(0, 1)
    , plot.tag = element_text(size = 8, hjust = 0, vjust = 0)
  )
```

Height

```{r, results='hide', fig.show='asis'}
plt_ttops_temp = ortho_plt_fn(my_suid) +
    # treetops
    geom_sf(
      data = harvests_trees %>% dplyr::filter(suid==my_suid)
      , mapping = aes(color = tree_height_ft)
      , size = 1
    ) +
    scale_color_viridis_c(option="plasma", alpha = 0.8, breaks = scales::extended_breaks(n=6)) +
    labs(color = "Individual Tree\nHt. (ft)")

# PLOT IT
plt_ttops_temp
  
# save it
ggplot2::ggsave("../data/NSW_03.jpeg", dpi = "print", height = 11, width = 5.8, device = "jpeg")

```

overstory/understory

```{r, results='hide', fig.show='asis'}
plt_ttops_temp = ortho_plt_fn(my_suid) +
    # treetops
    geom_sf(
      data = harvests_trees %>% dplyr::filter(suid==my_suid) %>%
        dplyr::mutate(
          ostory = dplyr::case_when(
            !is.na(as.numeric(ostory_dbh_cm)) &
              dbh_cm>=as.numeric(ostory_dbh_cm) ~ "overstory"
            , !is.na(as.numeric(ostory_ht_m)) &
              tree_height_m>=as.numeric(ostory_ht_m) ~ "overstory"
            , is.na(as.numeric(ostory_dbh_cm)) &
              is.na(as.numeric(ostory_ht_m)) &
              dbh_cm>=5*2.54 ~ "overstory"
            , T ~ "understory"
          )
          , ostory_sz = ifelse(ostory=="overstory",0.51,0.5)
        )
      , mapping = aes(color = ostory)
      , size = 1
    ) +
    scale_color_manual(values = c("navy","gray")) +
    labs(color = "") +
    theme(legend.key = element_rect(color = NA, fill = NA), legend.margin = margin(6.5,0,6.5,0)) +
    guides(size = "none", color = guide_legend(override.aes = list(size = 5)))

# PLOT IT
plt_ttops_temp
  
# save it
ggplot2::ggsave("../data/NSW_04.jpeg", dpi = "print", height = 11, width = 5.8, device = "jpeg")

```

### Tree Groups

Identify tree groups using `dbscan::dbscan()` as outlined by [Hanna et al. (2024)](https://scholar.google.com/scholar?oi=bibs&hl=en&cluster=8254459212692276263): 

>To evaluate the ability of UAS-extracted trees to characterize horizontal and vertical heterogeneity tree arrangement, clusters of trees were identifed within the stem-mapped and UAS trees. A cluster of trees was defned as two or more trees with the potential for interlocking crowns. Overstory trees on the stem maps generally had a crown radius of ~3.0 m, so stems within 6 m of one another were considered to have the potential for developing interlocking crowns. Density-based spatial clustering of applications with noise (DBSCAN) from the fpr package (Hahsler et al., 2019) in R was used to assign trees to unique clusters, including individual trees that were assigned by themselves if they did not have the potential to develop interlocking crowns (>6 m from another tree). (p. 529)

>To analyze the efect of tree aggregation on tree attributes, the identifed trees and clusters were designated as an "individual" or as a cluster consisting of 2-4, 5-9, 10-15, and >15 trees. We then calculated the number of clusters, the percent of stand basal area, the height coefcient of variation, and the canopy area within the cluster size classes for each site. (p. 529-530)

With repect to clump size groupings, [Churchill et al. (2016)](https://scholarworks.umt.edu/ico/3) note that:

>Proportions for clump sizes should be lumped into four or five bins for operational simplicity. We use 4 or 5 bins (Fig 5): individual trees, small clumps (2-4 trees), medium clumps (5-9 trees), and large clumps (10-20+ trees). Note that when instructed to leave a large clump (e.g. 10-20 trees), marking crews often have difficulty leaving the upper end of the size range (e.g. an 18, 19, or 20 tree clump). Thus adding a fifth bin for “super clumps” may be necessary (e.g. 15-20 trees or 20-25+ trees), especially if the upper size range of clumps is desired. (p. 12-13)

```{r}
# filter trees spatially based on unit id
ttops_temp = harvests_trees %>% dplyr::filter(suid==my_suid) %>% 
  dplyr::mutate(
    ostory = dplyr::case_when(
      !is.na(as.numeric(ostory_dbh_cm)) &
        dbh_cm>=as.numeric(ostory_dbh_cm) ~ "overstory"
      , !is.na(as.numeric(ostory_ht_m)) &
        tree_height_m>=as.numeric(ostory_ht_m) ~ "overstory"
      , is.na(as.numeric(ostory_dbh_cm)) &
        is.na(as.numeric(ostory_ht_m)) &
        dbh_cm>=5*2.54 ~ "overstory"
      , T ~ "understory"
    )
  ) %>% 
  dplyr::filter(ostory=="overstory") %>% 
  dplyr::mutate(
    X = sf::st_coordinates(.)[,1] %>% as.numeric()
    , Y = sf::st_coordinates(.)[,2] %>% as.numeric()
  )
#############################################################################
##### Identify clusters in each stem map plot                           #####
#############################################################################
### Place trees into clusters using an inter-tree distance of 6 m
my_dbscan_temp =  ttops_temp %>% 
  sf::st_drop_geometry() %>% 
  dplyr::select(X,Y) %>% 
  dbscan::dbscan(eps = tree_clump_dist_m, minPts = 2)

# my_dbscan_temp %>% str()

### append cluster ID to trees
ttops_temp$dbscan_cluster = my_dbscan_temp$cluster
# ttops_temp$cluster %>% summary()
# ttops_temp %>% sf::st_drop_geometry() %>% dplyr::count(cluster) %>% dplyr::arrange(desc(n)) %>% dplyr::slice_head(n=11)

### cluster metrics
ttops_temp = ttops_temp %>% 
  dplyr::group_by(dbscan_cluster) %>% 
  dplyr::mutate(
    # unique dbscan_cluster for individuals
    clump_id = dplyr::case_when(
      dbscan_cluster == 0 ~ max(my_dbscan_temp$cluster)+dplyr::row_number()
      , T ~ dbscan_cluster
    ) %>% 
    factor()
  ) %>% 
  dplyr::group_by(clump_id) %>% 
  dplyr::mutate(
    dbscan_cluster = factor(dbscan_cluster)
    , clump_n_trees = dplyr::n()
    , clump_n_trees_grp = cut(
        clump_n_trees
        ,breaks = c(0,1,4,9,15,Inf)
        , labels = c("Individual","2-4 trees","5-9 trees","10-15 trees",">15 trees")
      ) %>% 
      factor(
        ordered = T
        , levels = c("Individual","2-4 trees","5-9 trees","10-15 trees",">15 trees")
      )
  ) %>% 
  dplyr::ungroup()
# what?
ttops_temp %>% dplyr::glimpse()
```

plot overstory tree clumps

```{r, include=FALSE, eval=FALSE}
c(
  viridis::turbo(length(unique(ttops_temp$dbscan_cluster))/2 %>% round())
  , viridis::plasma(length(unique(ttops_temp$dbscan_cluster))/2 %>% round(), end = 0.95)
  , viridis::viridis(length(unique(ttops_temp$dbscan_cluster))/2 %>% round(), end = 0.9)
  , viridis::cividis(length(unique(ttops_temp$dbscan_cluster))/2 %>% round(), end = 0.9)
) %>%
  sample() %>%
  .[1:length(unique(ttops_temp$dbscan_cluster))-1] %>% 
  scales::show_col(labels = F)
```

```{r, results='hide', fig.show='asis'}
plt_grps_temp = ortho_plt_fn(my_suid) +
    # treetops
    geom_sf(
      data = ttops_temp
      , mapping = aes(color = dbscan_cluster)
      , size = 1
    ) +
    scale_color_manual(values = c(
      "white"
      , # get random list of colors from viridis and avoid whites
        c(
          viridis::turbo(length(unique(ttops_temp$dbscan_cluster))/2 %>% round())
          , viridis::plasma(length(unique(ttops_temp$dbscan_cluster))/2 %>% round(), end = 0.95)
          , viridis::viridis(length(unique(ttops_temp$dbscan_cluster))/2 %>% round(), end = 0.9)
          , viridis::cividis(length(unique(ttops_temp$dbscan_cluster))/2 %>% round(), end = 0.9)
        ) %>% 
          sample() %>% 
          .[1:length(unique(ttops_temp$dbscan_cluster))-1]
      )
    ) +
    # scale_color_viridis_d("turbo") +
    labs(subtitle = "\n overstory tree groups\n(individual trees in white)") +
    theme(
      legend.position = "none"
      , plot.subtitle = element_text(size = 9.5, hjust = 0.5, face = "bold")
    )

# PLOT IT
plt_grps_temp
  
# save it
ggplot2::ggsave("../data/NSW_05.jpeg", dpi = "print", height = 11, width = 5.8, device = "jpeg")

```

and plot overstory tree clumps by number of trees

```{r, results='hide', fig.show='asis'}
plt_grps_temp = ortho_plt_fn(my_suid) +
    # treetops
    geom_sf(
      data = ttops_temp
      , mapping = aes(color = clump_n_trees_grp)
      , size = 1
    ) +
    scale_color_viridis_d(option="mako", direction = -1) + 
    labs(color = "") +
    theme(legend.key = element_rect(color = NA, fill = NA), legend.margin = margin(6.5,0,6.5,0)) +
    guides(size = "none", color = guide_legend(override.aes = list(size = 5)))

# PLOT IT
plt_grps_temp
  
# save it
ggplot2::ggsave("../data/NSW_06.jpeg", dpi = "print", height = 11, width = 5.8, device = "jpeg")

```

### Within Clump Distance

Determine nearest neighbor distance for the stand and within clusters. Some combination of these metrics has been used to describe relative aggregation. (*source?*)

Calculate the distance to the nearest tree within each clump

```{r}
ttops_temp =
  ttops_temp %>% 
  dplyr::group_by(clump_id) %>%
  tidyr::nest() %>% 
  dplyr::mutate(
    distance_clump_nn_m = purrr::map(data, function(x){
      # get index of nearest neighbor
      i = sf::st_nearest_feature(x)
      # get dist
      d = sf::st_distance(x, x[i,], by_element=TRUE) %>% as.numeric()
      return(d)
    })
  ) %>% 
  tidyr::unnest(cols = c(data, distance_clump_nn_m)) %>% 
  sf::st_set_geometry("geom") %>% # set it cuz it got lost 
  dplyr::ungroup()
  # ggplot() + geom_point(aes(x=X,y=Y,color = distance_clump_nn_m)) + theme_light()
```

plot it

```{r, results='hide', fig.show='asis'}
ortho_plt_fn(my_suid) +
    # treetops
    geom_sf(
      data = ttops_temp
      , mapping = aes(color = distance_clump_nn_m)
      , size = 1
    ) +
    scale_color_viridis_c(option="viridis", na.value = "white") + 
    labs(color = "within clump\nN.N. dist. (m)")
```

#### Create function to get tree list with clumps

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

```{r, warning=T}
# create function to pass a unit id and return list of trees with clump groupings
get_tree_clumps = function(
    my_suid
    , tree_clump_dist_m=6
    , ostory_ht_m = as.numeric(NA)
    , ostory_dbh_cm = as.numeric(NA)
){
  # check ostory definition
  if(is.na(as.numeric(ostory_dbh_cm)) & is.na(as.numeric(ostory_ht_m))){
    warning("`ostory_dbh_cm` and `ostory_ht_m` are not set...using `ostory_dbh_cm` = 12.7")
    ostory_dbh_cm = 5*2.54
    # filter data
    ttops_temp = harvests_trees %>% 
      dplyr::filter(
        suid==my_suid
        & dbh_cm>=as.numeric(ostory_dbh_cm)
      )
  }else if(!is.na(as.numeric(ostory_dbh_cm))){
    # filter data
    ttops_temp = harvests_trees %>% 
      dplyr::filter(
        suid==my_suid
        & dbh_cm>=as.numeric(ostory_dbh_cm)
      )
  }else{
    # filter data
    ttops_temp = harvests_trees %>% 
      dplyr::filter(
        suid==my_suid
        & tree_height_m>=as.numeric(ostory_ht_m)
      )
  }
  # calcs
  ttops_temp = ttops_temp %>% 
    dplyr::mutate(
      X = sf::st_coordinates(.)[,1] %>% as.numeric()
      , Y = sf::st_coordinates(.)[,2] %>% as.numeric()
    )
  #############################################################################
  ##### Identify clusters in each stem map plot                           #####
  #############################################################################
  ### Place trees into clusters using an inter-tree distance of 6 m
  my_dbscan_temp =  ttops_temp %>% 
    sf::st_drop_geometry() %>% 
    dplyr::select(X,Y) %>% 
    dbscan::dbscan(eps = tree_clump_dist_m, minPts = 2)
  
  # my_dbscan_temp %>% str()
  
  ### append cluster ID to trees
  ttops_temp$dbscan_cluster = my_dbscan_temp$cluster
  # ttops_temp$cluster %>% summary()
  # ttops_temp %>% sf::st_drop_geometry() %>% dplyr::count(cluster) %>% dplyr::arrange(desc(n)) %>% dplyr::slice_head(n=11)
  
  ### cluster metrics
  ttops_temp = ttops_temp %>% 
    dplyr::group_by(dbscan_cluster) %>% 
    dplyr::mutate(
      # unique dbscan_cluster for individuals
      clump_id = dplyr::case_when(
        dbscan_cluster == 0 ~ max(my_dbscan_temp$cluster)+dplyr::row_number()
        , T ~ dbscan_cluster
      ) %>% 
      factor()
    ) %>% 
    dplyr::group_by(clump_id) %>% 
    dplyr::mutate(
      dbscan_cluster = factor(dbscan_cluster)
      , clump_n_trees = dplyr::n()
      , clump_n_trees_grp = cut(
          clump_n_trees
          ,breaks = c(0,1,4,9,15,Inf)
          , labels = c("Individual","2-4 trees","5-9 trees","10-15 trees",">15 trees")
        ) %>% 
        factor(
          ordered = T
          , levels = c("Individual","2-4 trees","5-9 trees","10-15 trees",">15 trees")
        )
    ) %>% 
    dplyr::ungroup()
  # add distance to nearest within clump
  ttops_temp =
    ttops_temp %>% 
    dplyr::group_by(clump_id) %>%
    tidyr::nest() %>% 
    dplyr::mutate(
      distance_clump_nn_m = purrr::map(data, function(x){
        # get index of nearest neighbor
        i = sf::st_nearest_feature(x)
        # get dist
        d = sf::st_distance(x, x[i,], by_element=TRUE) %>% as.numeric()
        return(d)
      })
    ) %>% 
    tidyr::unnest(cols = c(data, distance_clump_nn_m)) %>% 
    sf::st_set_geometry("geom") %>% # set it cuz it got lost 
    dplyr::ungroup() %>% 
    dplyr::mutate(
      tree_clump_dist_m = tree_clump_dist_m
      # , ostory_ht_m = ifelse(is.na(ostory_ht_m), as.numeric(NA), as.numeric(ostory_ht_m))
      # , ostory_dbh_cm = ifelse(is.na(ostory_dbh_cm), as.numeric(NA), as.numeric(ostory_dbh_cm))
    )
  # return
  return(ttops_temp)
}
# call it
ttops_temp = get_tree_clumps(
  my_suid = my_suid
  , tree_clump_dist_m = tree_clump_dist_m
  , ostory_dbh_cm = ostory_dbh_cm
)
```

### Clump Polygons and Metrics

[Churchill et al. (2016)](https://scholarworks.umt.edu/ico/3) provide instructions for implementing the clump identification (Plotkin et al. 2002) in ArcGIS:

>Use the Buffer tool (in the Proximity toolset within the Analysis toolbox) to create a buffer of distance d/2, one half the inter-tree distance, around each point. This quantity d/2 is meant to approximate the crown radius of a "typical" overstory tree. Set the Dissolve Type option to ALL, which dissolves overlapping buffers, creating a reduced set of spatially non-overlapping polygons stored as a multipart polygon feature...[Sanchez Meador et al. (2011)](https://scholar.google.com/scholar?cluster=15721451396848616769&oi=gsb&hl=en&as_sdt=0,6) provide some useful examples of how clump attributes can be summarized...The method described here can be modified to use measured or modeled crown radii for each tree in place of d/2 (p.36)

```{r}
# create function to pass a return from get_tree_clumps() and create clump polygons with summary stats
get_clump_summary = function(dta){
  # get tree_clump_dist_m
  tree_clump_dist_m = min(dta$tree_clump_dist_m, na.rm = T)
  # create clump polys and summary
  clump_polys_temp = 
    dta %>% 
      dplyr::ungroup() %>% 
      sf::st_set_geometry("geometry") %>% 
      sf::st_buffer(tree_clump_dist_m/2) %>% 
      dplyr::group_by(suid, clump_id, dbscan_cluster, clump_n_trees_grp) %>%
      dplyr::summarise(
        # union buffered tree points
        geometry = sf::st_union(geometry)
        # summary metrics
        , n_trees = dplyr::n_distinct(treeID)
        , mean_dbh_cm = mean(dbh_cm, na.rm = T)
        , mean_tree_height_m = mean(tree_height_m, na.rm = T)
        , loreys_height_m = sum(basal_area_m2*tree_height_m, na.rm = T) / sum(basal_area_m2, na.rm = T)
        , basal_area_m2 = sum(basal_area_m2, na.rm = T)
        , sum_dbh_cm_sq = sum(dbh_cm^2, na.rm = T)
      ) %>%
      dplyr::ungroup() %>% 
      sf::st_make_valid() %>% 
      dplyr::mutate(
        clump_area_ha = sf::st_area(geometry) %>% as.numeric() %>% `/`(10000)
        , trees_per_ha = (n_trees/clump_area_ha)
        , basal_area_m2_per_ha = (basal_area_m2/clump_area_ha)
        , pct_stand_basal_area = basal_area_m2/sum(basal_area_m2)
        , pct_stand_n_trees = n_trees/sum(n_trees)
        , qmd_cm = sqrt(sum_dbh_cm_sq/n_trees)
      ) %>%
      dplyr::select(-c(sum_dbh_cm_sq)) %>%
      # convert to imperial units
      calc_imperial_units_fn() %>% 
      dplyr::mutate(tree_clump_dist_m = tree_clump_dist_m)
  # calculate distance between clumps
  clump_polys_temp = clump_polys_temp %>% 
    dplyr::mutate(
      nearest = sf::st_nearest_feature(clump_polys_temp)
      , distance_nearest_clump_m = sf::st_distance(
          clump_polys_temp
          , clump_polys_temp[nearest,]
          , by_element=TRUE
        ) %>% 
        as.numeric()
    ) %>% 
    dplyr::select(-c(nearest))
  # return
  return(clump_polys_temp)
}
# get it
# get_clump_summary(
#   dta = get_tree_clumps(my_suid = my_suid, tree_clump_dist_m = tree_clump_dist_m)
# )
clump_polys_temp = get_clump_summary(ttops_temp)
# what?
clump_polys_temp %>% dplyr::glimpse()
# do these numbers match
identical(
  # clump polys
  nrow(clump_polys_temp)
  # clumps in tree list data
  , ttops_temp %>% dplyr::distinct(clump_id) %>% nrow()
)
```

plot it

```{r, results='hide', fig.show='asis'}
ortho_plt_fn(my_suid) +
  # clumps
  ggnewscale::new_scale_fill() +
  geom_sf(
    data = clump_polys_temp
    , mapping = aes(fill = dbscan_cluster)
    , color = NA, alpha = 0.9
  ) +
  scale_fill_manual(values = c(
    "white"
    , # get random list of colors from viridis and avoid whites
      c(
        viridis::turbo(length(unique(ttops_temp$dbscan_cluster))/2 %>% round())
        , viridis::plasma(length(unique(ttops_temp$dbscan_cluster))/2 %>% round(), end = 0.95)
        , viridis::viridis(length(unique(ttops_temp$dbscan_cluster))/2 %>% round(), end = 0.9)
        , viridis::cividis(length(unique(ttops_temp$dbscan_cluster))/2 %>% round(), end = 0.9)
      ) %>% 
        sample() %>% 
        .[1:length(unique(ttops_temp$dbscan_cluster))-1]
    )
  ) +
  labs(subtitle = "\n overstory tree group polygons\n(individual trees in white)") +
  theme(
    legend.position = "none"
    , plot.subtitle = element_text(size = 9.5, hjust = 0.5, face = "bold")
  )
```

check the distance between clumps

```{r, results='hide', fig.show='asis'}
ortho_plt_fn(my_suid) +
    ggnewscale::new_scale_fill() +
    geom_sf(
      data = clump_polys_temp
      , mapping = aes(fill = distance_nearest_clump_m)
      , size = 1, color = NA
    ) +
    scale_fill_viridis_c(option="viridis", na.value = "white") + 
    labs(fill = "nearest clump\ndist. (m)")
```

### Clump Spacing

See [Churchill et al. (2016)](https://scholarworks.umt.edu/ico/3) Figure 4 (p.10) and [Matonis and Binkley (2018)](https://scholar.google.com/scholar?cluster=14613232085713826018&hl=en&as_sdt=0,6) who "calculated coverage of mosaic-meadows (percentage of stand > 6 m from overstory trees)" (p. 124)

Since we already buffered the tree points to approximate the crown radius, we'll continue to use our $d/2$ where $d$ is maximum distance between trees for determining tree clumps and is meant to approximate the crown radius of a "typical" overstory tree

```{r}
# create function to pass a return from get_clump_summary() and get a distance raster
get_clump_dist_rast = function(dta){
  # get tree_clump_dist_m
  tree_clump_dist_m = min(dta$tree_clump_dist_m, na.rm = T)
  # suid
  my_suid = dta$suid[1]
  # rasterize the clump polygons and then calculate distance between clumps as raster
  dist_rast = 
    terra::rasterize(
        x = clump_polys_temp %>% terra::vect()
        , y = clump_polys_temp %>% 
          terra::vect() %>% 
          terra::rast(res = 0.2)
      ) %>% 
      terra::distance() %>% 
      # crop it to stand extent
      terra::crop(
        harvests %>% dplyr::filter(suid==my_suid) %>% 
        terra::vect()
      ) %>% 
      terra::mask(
        harvests %>% dplyr::filter(suid==my_suid) %>% 
        terra::vect()
      )
  ######### part 2
  # now create openings vector data
  openings_vect = 
    dist_rast %>% 
      terra::classify(rcl = c(tree_clump_dist_m/2,Inf), others = NA, include.lowest = T) %>% 
      terra::as.polygons(na.rm = T) %>% 
      sf::st_as_sf() %>% 
      sf::st_cast("POLYGON") %>% 
      dplyr::mutate(layer = dplyr::row_number()) %>% 
      dplyr::mutate(
        openining_area_m2 = sf::st_area(geometry) %>% as.numeric()
        , suid = my_suid
        , tree_clump_dist_m = tree_clump_dist_m
      )
  
  # return
  return(list(dist_rast = dist_rast, openings_vect = openings_vect))
}
# get it
dist_rast_temp = get_clump_dist_rast(clump_polys_temp)
dist_rast_temp
```

plot the distance raster and openings vector data we just got with overlaid tree clumps and tree points

```{r}
plt_fnl_temp = 
  ggplot() + 
    # distance
    geom_tile(
      data = dist_rast_temp$dist_rast %>% terra::aggregate(2, cores = 4) %>% as.data.frame(xy = T) %>% rename(f=3)
      , mapping = aes(x=x, y=y, fill = f)
    ) +
    scale_fill_distiller(
      palette = "YlOrRd"
      , na.value = "transparent"
      , direction = 1
      , name = "distance to\nnearest tree (m)"
    ) +
    # openings
    geom_sf(data = dist_rast_temp$openings_vect, mapping = aes(color = openining_area_m2), fill = NA) +
    scale_color_gradient(
      low = "gray77", high = "gray11"
      , labels = scales::comma_format(accuracy = 1)
      , name = latex2exp::TeX("opening\narea ($\\m^2$)")
    ) +
    # clumps
    ggnewscale::new_scale_fill() +
    geom_sf(
      data = clump_polys_temp
      , mapping = aes(fill = clump_n_trees_grp)
      , color = NA
    ) +
    scale_fill_viridis_d(option="mako", direction = -1, name = "clump size") + 
    # tree points
    geom_sf(data = ttops_temp, color = "gray88", shape = ".") +
    theme_void()
# plot
plt_fnl_temp
# save it
ggplot2::ggsave("../data/NSW_07.jpeg", dpi = "print", height = 11, width = 5.8, device = "jpeg")
```

highlight the openings

```{r}
plt_open_temp = 
  ggplot() + 
      # clumps
      geom_sf(
        data = clump_polys_temp
        , mapping = aes(fill = clump_n_trees_grp)
        , color = NA
      ) +
      scale_fill_viridis_d(option="mako", direction = -1, name = "clump size") + 
      # openings
      ggnewscale::new_scale_fill() +
      geom_sf(data = dist_rast_temp$openings_vect, mapping = aes(fill = openining_area_m2), color = NA) +
      scale_fill_gradient(
        low = "gray77", high = "gray11"
        , labels = scales::comma_format(accuracy = 1)
        , name = latex2exp::TeX("opening\narea ($\\m^2$)")
      ) +
      # tree points
      geom_sf(data = ttops_temp, color = "gray88", shape = ".") +
      theme_void()
plt_open_temp
# save it
ggplot2::ggsave("../data/NSW_08.jpeg", dpi = "print", height = 11, width = 5.8, device = "jpeg")
```

combine them?

```{r}
plt_fnl_temp + (plt_open_temp + theme(legend.position = "none"))
# save it
ggplot2::ggsave("../data/NSW_09.jpeg", dpi = "print", height = 11, width = 8, device = "jpeg")
```

### Clump Metrics

create a function to summarize by number of tree clump grouping variable

```{r}
# create a function to summarize by number of tree clump grouping
get_clump_n_trees_grp_summary = function(trees, clumps){
  # get area of harvest unit
  #...will use this area in the area calculations such that...
  #...TPA = trees in a certain group size across the whole stand area
  harvest_area_m2 = harvests %>% 
    dplyr::filter(suid == trees$suid[1]) %>% 
    dplyr::pull(harvest_area_m2) %>% 
    .[1]
  # collapse and calculate silv metrics
  dta = trees %>% 
    sf::st_drop_geometry() %>% 
    dplyr::group_by(suid,stand_area_ha,clump_n_trees_grp) %>%
    dplyr::summarise(
      # summary metrics
      n_trees = dplyr::n_distinct(treeID)
      , mean_dbh_cm = mean(dbh_cm, na.rm = T)
      , mean_tree_height_m = mean(tree_height_m, na.rm = T)
      , loreys_height_m = sum(basal_area_m2*tree_height_m, na.rm = T) / sum(basal_area_m2, na.rm = T)
      , basal_area_m2 = sum(basal_area_m2, na.rm = T)
      , sum_dbh_cm_sq = sum(dbh_cm^2, na.rm = T)
    ) %>%
    dplyr::ungroup() %>% 
    # attach clump area
    dplyr::left_join(
      clumps %>% 
        sf::st_drop_geometry() %>% 
        dplyr::group_by(suid,clump_n_trees_grp) %>%
        dplyr::summarise(clump_area_ha = sum(clump_area_ha), stand_n_clumps = dplyr::n())
    ) %>% 
    dplyr::mutate(
      trees_per_ha = (n_trees/clump_area_ha) # (n_trees/stand_area_ha) ... this was not right
      , basal_area_m2_per_ha = (basal_area_m2/clump_area_ha) # (basal_area_m2/stand_area_ha) ... this was not right
      , qmd_cm = sqrt(sum_dbh_cm_sq/n_trees)
      # stand calcs
      , stand_trees_per_ha = sum(n_trees)/stand_area_ha
      , stand_basal_area_m2 = sum(basal_area_m2)
      , stand_basal_area_m2_per_ha = sum(basal_area_m2)/stand_area_ha
      , pct_stand_basal_area = basal_area_m2/stand_basal_area_m2
      , pct_stand_n_trees = n_trees/sum(n_trees)
      , stand_qmd_cm = sqrt(sum(trees$dbh_cm^2, na.rm = T)/sum(n_trees))
    ) %>%
    dplyr::select(-c(sum_dbh_cm_sq)) %>%
    # convert to imperial units
    calc_imperial_units_fn()
  # return
  return(dta)
}
# call it
clump_n_trees_grp_summary_temp = get_clump_n_trees_grp_summary(
  trees = get_tree_clumps(my_suid = my_suid, tree_clump_dist_m = tree_clump_dist_m, ostory_dbh_cm = ostory_dbh_cm)
  , clumps = get_clump_summary(
    get_tree_clumps(my_suid = my_suid, tree_clump_dist_m = tree_clump_dist_m, ostory_dbh_cm = ostory_dbh_cm)
  )
) 
# what?
clump_n_trees_grp_summary_temp %>% dplyr::glimpse()
```

summary table

```{r}
# table it
clump_n_trees_grp_summary_temp %>% 
  dplyr::select(
    clump_n_trees_grp, n_trees
    , mean_dbh_in
    , qmd_in
    , mean_tree_height_ft
    , loreys_height_ft
    , trees_per_ac
    , basal_area_ft2_per_ac, pct_stand_basal_area, pct_stand_n_trees
  ) %>% 
  dplyr::mutate(
    dplyr::across(
      .cols = c(pct_stand_basal_area, pct_stand_n_trees) 
      , .fns = ~ scales::percent(.x, accuracy = 1)
    )
  ) %>% 
  kableExtra::kbl(
    digits = 1
    , escape = F
    , caption = paste0("Overstory tree clump summary<br>", "stand suid: ", clump_n_trees_grp_summary_temp$suid[1])
    , col.names = c(
      "", "trees"
      , "mean<br>DBH (in)"
      , "QMD (in)"
      , "mean<br>Ht. (ft)"
      , "Loreys<br>Ht. (ft)"
      , "TPA"
      , "BA<br>ft<sup>2</sup> ac<sup>-1</sup>"
      , "%<br>stand BA"
      , "%<br>stand trees"
      )
  ) %>% 
  kableExtra::kable_styling()
```

plot it

```{r}
clump_n_trees_grp_summary_temp %>% 
  dplyr::select(
    clump_n_trees_grp, n_trees
    , mean_dbh_in
    , qmd_in
    , mean_tree_height_ft
    , loreys_height_ft
    , trees_per_ac
    , basal_area_ft2_per_ac, pct_stand_basal_area
  ) %>% 
  dplyr::mutate(pct_stand_basal_area = pct_stand_basal_area*100) %>% 
  tidyr::pivot_longer(
    cols = -c(clump_n_trees_grp)
  ) %>% 
  dplyr::mutate(
    metric = factor(
        name
        , ordered = T
        , levels = c(
            "n_trees"
            , "mean_dbh_in"
            , "qmd_in"
            , "mean_tree_height_ft"
            , "loreys_height_ft"
            , "trees_per_ac"
            , "basal_area_ft2_per_ac"
            , "pct_stand_basal_area"
          )
        , labels = c(
            latex2exp::TeX("Number of Trees", output = "character")
            , latex2exp::TeX("Mean DBH (in)", output = "character")
            , latex2exp::TeX("QMD (in)", output = "character")
            , latex2exp::TeX("Mean Tree Height (ft)", output = "character")
            , latex2exp::TeX("Lorey's Mean Height (ft)", output = "character")
            , latex2exp::TeX("Trees $ac^{-1}$")
            , latex2exp::TeX("Basal Area $ft^{2} \\cdot ac^{-1}$")
            , latex2exp::TeX("% stand BA", output = "character")
          )
      )
    , clump_n_trees_grp = forcats::fct_rev(clump_n_trees_grp)
  ) %>% 
  ggplot(mapping = aes(
      x = value, y = clump_n_trees_grp
      , fill = name, label = scales::number(value, accuracy = 0.1)
    )
  ) +
  geom_col(width = 0.7) +
  geom_text(color = "black", size = 3.5, hjust = -0.1) +
  facet_wrap(facets = vars(metric), ncol = 2, scales = "free_x", labeller = label_parsed) +
  scale_fill_viridis_d(option = "cividis", alpha = 0.9) +
  scale_x_continuous(expand = expansion(mult = c(0,0.1))) +
  labs(
    x = "", y = ""
    , subtitle = paste0(
      "Overstory tree clump summary\n"
      , "stand suid: "
      , clump_n_trees_grp_summary_temp$suid[1])
  ) +
  theme_light() +
  theme(
    legend.position = "none"
    , strip.text = element_text(color = "black", size = 10)
    , strip.background = element_rect(fill = "gray88")
    , axis.text.y = element_text(face = "bold")
    , axis.ticks.y = element_blank()
    , panel.grid.major.y = element_blank()
    , panel.grid.minor.y = element_blank()
  )
```

## ICO Implementation

[Churchill et al. (2016)](https://scholarworks.umt.edu/ico/3) describe the full process for implementing the ICO approach in *[The ICO Approach to Quantifying and Restoring Forest Spatial Pattern: Implementation Guide](https://scholarworks.umt.edu/ico/3)* in which the authors lay out the prescription development process:

1. Identify skips and other special treatment areas
2. Consider the need for openings
3. Determine the stand average density target
4. Determine the appropriate distance to define clumps
5. Obtain targets for clump proportions
6. Select target clump proportions for your stand
7. Generate clump targets for the whole unit
8. Combine clump and opening targets with leave tree criteria into marking guidelines

The objective here is to: 1) provide the manager with the current conditions (completed above); 2) take the "targets" as set by the manager (steps 3, 5, 6, 7); 3) create the prescription with the leave tree marking.

Let's implement this prescription development process with our UAS tree list

### 3. Determine the stand average density target

Step 3 in [Churchill et al. (2016)](https://scholarworks.umt.edu/ico/3): 

>An average BA, TPA, or SDI target for the stand should be selected that is appropriate for the species, structure, site conditions, and management objectives. Expected mortality from prescribed fire should be factored in. Stand average targets can come from historical reference stands, plant association based stocking guides, density management tools, or a combination of both (see Franklin et al. (2013) for a full discussion of setting density targets). In dry forests, the number and size of old trees must be accounted in setting the density target. To use the ICO method, the target must be converted to TPA (see Table 1). A lower diameter cutoff also needs to be specified for the TPA target. This should be the lower limit in the contract or cutting guidelines given to the marking crew or contractor. (p.11)

this is what Table 1 looks like with TPA values are derived from the formula: 

$$
TPA = \frac{BA}{QMD^{2} \times 0.005454}
$$

```{r}
# function to get tpa from ba and qmd
get_tpa = function(ba_ft2_ac, qmd_in){
  tpa = round(ba_ft2_ac/((qmd_in^2)*0.005454))
  return(tpa)
} 
# table it
tidyr::crossing(
    ba = seq(40,200,20)
    , qmd = seq(8,20,2)
  ) %>% 
  dplyr::mutate(
    tpa = get_tpa(ba,qmd)
  ) %>% 
  tidyr::pivot_wider(names_from = ba, values_from = tpa) %>% 
  dplyr::mutate(l = "QMD (in)") %>% 
  dplyr::relocate(l) %>% 
  kableExtra::kbl(
    col.names = c(".","", seq(40,200,20))
    , escape = F
    , caption = "Basal Area and QMD to TPA conversion chart"
  ) %>% 
  kableExtra::add_header_above(
    c("","", "Basal Area (ft2/ac)"=length(seq(40,200,20)))
  ) %>%
  kableExtra::kable_styling() %>% 
  kableExtra::column_spec(1:2, bold = T) %>%
  kableExtra::collapse_rows(columns = 1, valign = "middle")
```

#### Current Stand Conditions

For determining targets, the silviculturist needs to know the current conditions. Provide the current stand conditions based on the UAS tree list for the selected stand that are required to set the targets:

* Current BA
* Current QMD
* Current proportion of trees by clump size

```{r}
clump_n_trees_grp_summary_temp %>% 
  dplyr::select(clump_n_trees_grp, pct_stand_n_trees) %>% 
  dplyr::mutate(
    pct_stand_n_trees = scales::percent(pct_stand_n_trees,accuracy = 1)
  ) %>% 
  tidyr::pivot_wider(names_from = clump_n_trees_grp, values_from = pct_stand_n_trees) %>% 
  kableExtra::kable(
    caption = paste0(
      "Current stand BA (ft2/ac): "
      , clump_n_trees_grp_summary_temp$stand_basal_area_ft2_per_ac[1] %>% scales::number(accuracy = 0.1)
      , "<br>Current stand QMD (in): "
      , clump_n_trees_grp_summary_temp$stand_qmd_in[1] %>% scales::number(accuracy = 0.1)
      , "<br>Current stand TPA: "
      , clump_n_trees_grp_summary_temp$stand_trees_per_ac[1] %>% scales::number(accuracy = 1)
    )
    , escape = F
    , digits = 1
  ) %>% 
  kableExtra::kable_styling() %>% 
  kableExtra::footnote(general = "values are the percent of trees in each clump size")
```

```{r, include=FALSE, eval=FALSE}
clump_n_trees_grp_summary_temp = get_clump_n_trees_grp_summary(
  trees = get_tree_clumps(my_suid = harvests$suid[2], tree_clump_dist_m = tree_clump_dist_m, ostory_dbh_cm = 5*2.54)
  , clumps = get_clump_summary(
    get_tree_clumps(my_suid = harvests$suid[2], tree_clump_dist_m = tree_clump_dist_m, ostory_dbh_cm = 5*2.54)
  )
)
clump_n_trees_grp_summary_temp %>% 
  dplyr::select(clump_n_trees_grp, pct_stand_n_trees) %>% 
  dplyr::mutate(
    pct_stand_n_trees = scales::percent(pct_stand_n_trees,accuracy = 1)
  ) %>% 
  tidyr::pivot_wider(names_from = clump_n_trees_grp, values_from = pct_stand_n_trees) %>% 
  kableExtra::kable(
    caption = paste0(
      "Current stand BA (ft2/ac): "
      , clump_n_trees_grp_summary_temp$stand_basal_area_ft2_per_ac[1] %>% scales::number(accuracy = 0.1)
      , "<br>Current stand QMD (in): "
      , clump_n_trees_grp_summary_temp$stand_qmd_in[1] %>% scales::number(accuracy = 0.1)
      , "<br>Current stand TPA: "
      , clump_n_trees_grp_summary_temp$stand_trees_per_ac[1] %>% scales::number(accuracy = 1)
    )
    , escape = F
    , digits = 1
  ) %>% 
  kableExtra::kable_styling()
```

### 5. Obtain targets for clump proportions

Step 5 in [Churchill et al. (2016)](https://scholarworks.umt.edu/ico/3): 

>ICO prescriptions are based on a target proportion of trees in different sized clumps within a stand. Proportions are just the percentage of trees, or TPA, that are in different sized clumps. Basal area proportions can be used, but we have found TPA targets to be more straightforward to use. Ideally, a table summarizing clump proportions for a range of reference conditions in your area is available (Table 2). If not, instructions for developing one are provided in section VI. (p.12)

Section VI of [Churchill et al. (2016)](https://scholarworks.umt.edu/ico/3) notes that

>reference spatial information may already be available and summarized in a way that it can be directly incorporated into ICO prescriptions. Such data exist and have been published for areas in Arizona (Abella and Denton 2009, Sánchez Meador et al. 2011), the eastern Washington Cascades (Churchill et al. 2013), the northern Rockies (Larson et al. 2012), and the Sierra Nevada (Lydersen et al. 2013). Reference datasets for using ICO in other forest types, such as coastal Douglas-fir or Pacific silver fir, also exist (Larson and Churchill 2008). (p.28)

Table 2 is:

```{r, echo=FALSE, out.width="70%", out.height="70%", fig.align='center', fig.show='hold',results='asis'}
knitr::include_graphics("https://i.ibb.co/N1hpzLj/churchilletal2016-table2.jpg")
```

### 6. Select target clump proportions for your stand

*Now set the desired BA, QMD, and proportion of trees in each clump size:*

```{r}
########################################################################################
########################################################################################
# desired BA, QMD, and proportion of trees in each clump size
########################################################################################
########################################################################################
# desired BA
  target_ba = 37 # cannot be > current BA
# desired QMD
  target_qmd = 11
# desired proportion (%) of trees in each clump size
  # !cannot be create larger proportion of ">15 trees" clump as this would require adding trees...
  # c("Individual", "2-4 trees", 	"5-9 trees", 	"10-15 trees", ">15 trees")
  # c(.18, .33, .24, .10, .15)
  target_pcts = c(.18, .33, .24, .10, .15)
########################################################################################
########################################################################################
# desired BA, QMD, and proportion of trees in each clump size
########################################################################################
########################################################################################
```

Check set up and define data with targets

```{r, warning=TRUE}
get_target_check_prescription = function(
  clump_n_trees_grp_summary_dta
  , target_ba = as.numeric(NA)
  , target_qmd = as.numeric(NA)
  , target_pcts = as.numeric(NA)
){
  if(
    is.na(target_ba) | is.na(target_qmd) | max(is.na(target_pcts))==1
  ){
    stop("must set all of the function parameters:\n`target_ba`, `target_qmd`, and `target_pcts`")
  }
  #############################################
  # check target BA and TPA
  #############################################
  if(as.numeric(target_ba)>clump_n_trees_grp_summary_dta$stand_basal_area_ft2_per_ac[1]){
    stop(
      "target BA in `target_ba` of "
      , round(as.numeric(target_ba),1), " is greater than current BA of "
      , clump_n_trees_grp_summary_dta$stand_basal_area_ft2_per_ac[1] %>% round(1)
    )
  }
  if(
    get_tpa(target_ba, target_qmd)>clump_n_trees_grp_summary_dta$stand_trees_per_ac[1]
  ){
    stop(
      "target TPA in of "
      , round(as.numeric(get_tpa(target_ba, target_qmd)),1), " is greater than current TPA of "
      , clump_n_trees_grp_summary_dta$stand_trees_per_ac[1] %>% round(1)
      , "\n adjust `target_ba` and/or `target_qmd` to get valid TPA"
    )
  }
  #############################################
  # define data with current and target
  # ... this is "smart" in that percentages are adj based on:
  # ... 0) are there missing targets?
  # ... ... if < 5 numbers provided in `target_pcts` then the largest tree groups get targets of 0
  # ... 1) do targets sum to 1? 
  # ... ... if not trees are distributed proportionally based on targets provided and trees available
  # ... 2) is target in largest clump size > current conditions?
  # ... ... if yes, target is set to current condition
  # ... 3) is target listed in clump size > current largest clump with trees?
  # ... ... if yes, target for largest clump size is shifted to current largest clump with trees
  #############################################
    target_data = 
      # create data for joining if missing clump groups
      dplyr::tibble(
        suid = rep(clump_n_trees_grp_summary_dta$suid[1],5)
        , stand_area_ac = rep(clump_n_trees_grp_summary_dta$stand_area_ac[1],5)
        , clump_n_trees_grp = factor(
          c(1:5)
          , labels = c("Individual", "2-4 trees", 	"5-9 trees", 	"10-15 trees", ">15 trees")
          , ordered = T
        )
        , mean_clump_n_trees = c(1,3,7,12,20)
      ) %>% 
      dplyr::left_join(
        clump_n_trees_grp_summary_dta %>% 
          dplyr::ungroup() %>% 
          dplyr::select(clump_n_trees_grp, pct_stand_n_trees, stand_n_clumps)
      ) %>% 
      dplyr::mutate(
        pct_stand_n_trees = dplyr::coalesce(pct_stand_n_trees,0)
        , stand_n_clumps = dplyr::coalesce(stand_n_clumps,0)
      ) %>% 
      # add targets
      dplyr::bind_cols(
        pct_stand_n_trees_target = c(as.numeric(target_pcts), rep(0,5))[1:5] # pad target with 0's
      ) %>% 
      # adjust target based on difference from 1
      dplyr::mutate(
        pct_stand_n_trees_target = pct_stand_n_trees_target*(1/sum(pct_stand_n_trees_target))
        # largest clump size with trees
        , largest_w_trees = max(ifelse(dplyr::coalesce(pct_stand_n_trees)>0,clump_n_trees_grp,NA),na.rm = T)
        , largest_w_trees_target = max(ifelse(dplyr::coalesce(pct_stand_n_trees_target)>0,clump_n_trees_grp,NA),na.rm = T)
      ) %>% 
      # move target for largest clump size to the largest current clump size 
      dplyr::mutate(
        pct_stand_n_trees_target = dplyr::case_when(
          as.numeric(clump_n_trees_grp)==largest_w_trees &
            largest_w_trees_target>largest_w_trees ~ max(
              ifelse(as.numeric(clump_n_trees_grp)==largest_w_trees_target,pct_stand_n_trees_target,0)
            )
          , T ~ pct_stand_n_trees_target
        )
      ) %>% 
      # adjust target based on current conditions
      dplyr::mutate(
        pct_stand_n_trees_target = dplyr::case_when(
          as.numeric(clump_n_trees_grp)>largest_w_trees &
            pct_stand_n_trees_target > 0 ~ 0
          , as.numeric(clump_n_trees_grp)==largest_w_trees &
            pct_stand_n_trees_target > pct_stand_n_trees ~ pct_stand_n_trees
          , T ~ pct_stand_n_trees_target
        )
      ) %>% 
      # finally, re-scale again based on adjustments
      dplyr::mutate(
        pct_stand_n_trees_target = dplyr::case_when(
          as.numeric(clump_n_trees_grp)==largest_w_trees ~ pct_stand_n_trees_target
          , T ~ pct_stand_n_trees_target * (
            # pct remaining to scale to
            (1-max(ifelse(as.numeric(clump_n_trees_grp)==largest_w_trees,pct_stand_n_trees_target,0))) /
            # current pct remaining total allocated
            sum(
              ifelse(as.numeric(clump_n_trees_grp)!=largest_w_trees,pct_stand_n_trees_target,0))
            )
        )
      ) %>% 
      # add other targets
      dplyr::rename(pct_stand_n_trees_current = pct_stand_n_trees) %>% 
      dplyr::mutate(
        stand_trees_per_ac_current = clump_n_trees_grp_summary_dta$stand_trees_per_ac[1]
        , stand_trees_per_ac_target = get_tpa(target_ba, target_qmd)
        , trees_per_acre_current = stand_trees_per_ac_current*pct_stand_n_trees_current
        , trees_per_acre_target = stand_trees_per_ac_target*pct_stand_n_trees_target
        , clumps_per_acre_current = trees_per_acre_current/mean_clump_n_trees
        , clumps_per_acre_target = trees_per_acre_target/mean_clump_n_trees
        , stand_n_clumps_current = stand_n_clumps
        , stand_n_clumps_target = (clumps_per_acre_target*stand_area_ac) %>% round(0)
      ) %>% 
      dplyr::select(-c(tidyselect::starts_with("largest_w_trees"), stand_n_clumps))
  # ????  
  # target_data %>% glimpse()
  
    # issue warning about targets
    if(min(target_data$pct_stand_n_trees_target == c(as.numeric(target_pcts), rep(0,5))[1:5])==0){
      warning(
        "proportion of trees in each clump size target `target_pcts` adjusted!!!"
        , "\nfrom : ", paste(round(target_pcts,2),collapse = ",")
        , "\nto : ", paste(round(target_data$pct_stand_n_trees_target,2),collapse = ",")
      )
    }
  # return
  return(target_data)
}
# call it
target_data_temp = get_target_check_prescription(
  clump_n_trees_grp_summary_temp
  , target_ba = target_ba
  , target_qmd = target_qmd
  , target_pcts = target_pcts
)
# what?
target_data_temp %>% dplyr::glimpse()
```

current vs target

```{r}
target_data_temp %>% 
  dplyr::select(
    clump_n_trees_grp
    , tidyselect::starts_with("pct_stand_n_trees")
    , tidyselect::starts_with("trees_per_acre_")
  ) %>% 
  dplyr::mutate(
    dplyr::across(
      tidyselect::starts_with("pct_stand_n_trees")
      , ~ scales::percent(.x,accuracy = 1)
    )
  ) %>% 
  kableExtra::kable(
    caption = paste0(
      "Current stand BA (ft2/ac): "
      , clump_n_trees_grp_summary_temp$stand_basal_area_ft2_per_ac[1] %>% scales::number(accuracy = 0.1)
      , "<br>Current stand QMD (in): "
      , clump_n_trees_grp_summary_temp$stand_qmd_in[1] %>% scales::number(accuracy = 0.1)
      , "<br>Current stand TPA: "
      , clump_n_trees_grp_summary_temp$stand_trees_per_ac[1] %>% scales::number(accuracy = 1)
    )
    , escape = F
    , digits = 1
    , col.names = c(
      "", rep(c("current","target"),2)
    )
  ) %>% 
  kableExtra::kable_styling() %>% 
  kableExtra::add_header_above(
    c(" "=1,"% Trees"=2, "TPA"=2)
  )
```

### 8. Combine clump and opening targets with leave tree criteria into marking guidelines

Use our UAS tree list to generate the prescription:

* start with the largest clump size currently with trees
* cut trees to the next largest clup size until desired # clumps is reached
* repeat with each successive clump size through to individual tree selection
* if possible, cut in same clump until desired proportions are reached to minimize machine time

```{r}
# use target data to get cut trees by clump size group
# !!!! need this first:
  # target_data_temp = get_target_check_prescription(
  #   clump_n_trees_grp_summary_temp
  #   , target_ba = target_ba
  #   , target_qmd = target_qmd
  #   , target_pcts = target_pcts
  # )
cut_grp_ex_temp = ttops_temp %>%
  dplyr::filter(clump_n_trees_grp == ">15 trees") %>%
  dplyr::group_by(clump_id) %>%
  tidyr::nest() %>%
  dplyr::mutate(
    is_keep_tree = purrr::map(data, function(x, tgt = target_data_temp){
      # get next size group n tree target
      ntree_target_temp = tgt %>%
        dplyr::mutate(l = dplyr::lag(mean_clump_n_trees)) %>%
        dplyr::filter(clump_n_trees_grp == x$clump_n_trees_grp[1]) %>%
        dplyr::pull(l) %>%
        dplyr::coalesce(0)
      # join to gridded area based on the tree clump distance
      grid = x %>%
        sf::st_bbox() %>%
        sf::st_make_grid(
          cellsize = round(tree_clump_dist_m/2,0)
        ) %>%
        sf::st_as_sf() %>%
        dplyr::mutate(
          grid_n = dplyr::row_number()
        )
      x_grid = x %>% 
        sf::st_join(grid) %>% 
        dplyr::group_by(treeID) %>% 
        dplyr::filter(dplyr::row_number()==1) %>% 
        dplyr::ungroup()
      # get the biggest tree grid_n
      big_grid = x_grid %>% dplyr::arrange(desc(dbh_cm), desc(tree_height_m)) %>% dplyr::pull(grid_n) %>% .[1]
      # start with biggest tree keep adding cells until desired n trees reached
      x_grid = x_grid %>%
        dplyr::mutate(
          sorter = abs(grid_n-big_grid)
        ) %>%
        dplyr::arrange(sorter, desc(dbh_cm), desc(tree_height_m)) %>%
        dplyr::mutate(
          is_keep_tree = (dplyr::row_number() <= ntree_target_temp) %>% as.numeric()
        )
      # join to original data and pull
      d = x %>%
        sf::st_drop_geometry() %>%
        dplyr::left_join(
          x_grid %>% sf::st_drop_geometry() %>% dplyr::select(treeID, is_keep_tree) #is_keep_tree
          , by = dplyr::join_by("treeID")
        ) %>%
        dplyr::pull(is_keep_tree)
      # return
      return(d)
    })
  ) %>%
  tidyr::unnest(cols = c(data, is_keep_tree)) %>%
  sf::st_set_geometry("geom") %>% # set it cuz it got lost
  dplyr::ungroup()
# what?
cut_grp_ex_temp %>% dplyr::glimpse()
```

# plot it

```{r}
ggplot() + 
    geom_sf(data = harvests %>% dplyr::filter(suid == my_suid), fill = NA, color = "black") +
    geom_sf(
      data = clump_polys_temp %>% dplyr::filter(clump_n_trees_grp == ">15 trees")
      , mapping = aes(fill = clump_id)
      , color = NA
      , show.legend = F
    ) +
    scale_fill_manual(
      values = 
        viridis::mako(
          clump_polys_temp %>% dplyr::filter(clump_n_trees_grp == ">15 trees") %>% 
          dplyr::pull(clump_id) %>% 
          unique() %>% length()
        ) %>% sample()
    ) + 
    # tree points
    geom_sf(data = cut_grp_ex_temp, mapping = aes(color = as.factor(is_keep_tree)), size = 0.5) +
    scale_color_manual(values = c("firebrick", "gold")) +
    labs(color = "is keep tree?") +
    theme_void() + 
    guides(color = guide_legend(override.aes = list(size = 5)))
```


```{r, include=FALSE, eval=FALSE}
# data for passing to function with nest()
x = ttops_temp %>% 
  dplyr::filter(clump_n_trees_grp == ">15 trees") %>%
  dplyr::filter(clump_id == 3) 

# get next size group n tree target
ntree_target_temp = target_data_temp %>% 
  dplyr::mutate(l = dplyr::lag(mean_clump_n_trees)) %>% 
  dplyr::filter(clump_n_trees_grp == ">15 trees") %>%
  dplyr::pull(l) %>% 
  dplyr::coalesce(0)
# join to gridded area based on the tree clump distance
grid = x %>% 
  sf::st_bbox() %>% 
  sf::st_make_grid(
    cellsize = round(tree_clump_dist_m/2,0)
  ) %>% 
  sf::st_as_sf() %>% 
  dplyr::mutate(
    grid_n = dplyr::row_number()
  )
x = x %>% sf::st_join(grid) 
# start with biggest tree keep adding cells until desired n trees reached
  x %>% 
    dplyr::mutate(
      sorter = grid_n %>% 
        # get the biggest tree grid_id
        `-`(x %>% dplyr::arrange(desc(dbh_cm), desc(tree_height_m)) %>% dplyr::pull(grid_n) %>% .[1]) %>% 
        abs()
    ) %>% 
    dplyr::arrange(sorter, desc(dbh_cm), desc(tree_height_m)) %>% 
    dplyr::mutate(
      is_keep_tree = (dplyr::row_number() <= ntree_target_temp) %>% as.numeric()
    ) %>% 
  
ggplot() + 
  geom_sf(aes(color = as.factor(is_keep_tree))) +
  geom_sf(data = grid, fill = NA, color = "red") +
  theme_void()
  
ggplot(xxx %>% dplyr::filter(clump_id==3)) + 
  geom_sf(aes(color = as.factor(is_keep_tree))) +
  geom_sf(data = grid, fill = NA, color = "red") +
  theme_void()
```

