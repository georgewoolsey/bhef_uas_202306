# UAS Tree Spatial Arrangement{#tree_spatial}

## Example Tree Group Workflow

For now we'll just make a visual overview of the UAS-SfM forest inventory process to present at the 2024 National Silvicultural Workshop.

```{r}
# focus on one harvest unit
  my_suid = harvests$suid[6]
#########################
#########################
# what is overstory?
#########################
#########################
  #!!!!! fill in one...if both filled in will use DBH
  # determine overstory by height
  ostory_ht_m = as.numeric(NA) # m = ft / 3.281
  # determine overstory by diameter
  ostory_dbh_cm = 5*2.54 # cm = in * 2.54
#########################
#########################
# clump spacing
#########################
#########################
  # maximum distance between trees for determining tree clumps
    # stems within 6 m of one another were considered to have the potential for developing interlocking crowns
  tree_clump_dist_m = 6
```

Check the stand location

```{r}
# where is this
mapview::mapview(harvests %>% dplyr::filter(suid==my_suid), layer.name = "BHEF", label = FALSE, legend = FALSE, popup = FALSE)
```

### Orthomosaic from UAS

```{r, results='hide', fig.show='asis'}
######################################################################################
# function to plot ortho + stand
######################################################################################
ortho_plt_fn = function(my_suid){
# convert to stars
  ortho_st = ortho_rast %>%  
    terra::subset(subset = c(1,2,3)) %>%
    terra::crop(
      # stand %>% 
      harvests %>% dplyr::filter(suid==my_suid) %>% 
        sf::st_buffer(20) %>% 
        sf::st_bbox() %>% 
        sf::st_as_sfc() %>% 
        terra::vect()
    ) %>% 
    terra::aggregate(fact = 2, fun = "mean", na.rm = T) %>% 
    stars::st_as_stars()
  
  # convert to rgb
  ortho_rgb <- stars::st_rgb(
    ortho_st[,,,1:3]
    , dimension = 3
    , use_alpha = FALSE
    # , stretch = "histogram"
    , probs = c(0.005, 0.995)
    , stretch = "percent"
  )
  # ggplot
  plt_rgb <- ggplot() +
    stars::geom_stars(data = ortho_rgb[]) +
    scale_fill_identity(na.value = "transparent") + # !!! don't take this out or RGB plot will kill your computer
    scale_x_continuous(expand = c(0, 0)) +
    scale_y_continuous(expand = c(0, 0)) +
    labs(
      x = ""
      , y = ""
    ) +
    theme_void()
  
  # return(plt_rgb)
  # combine all plot elements
  plt_combine = plt_rgb +
    geom_sf(
      data = harvests %>% dplyr::filter(suid==my_suid)
      , alpha = 0
      , lwd = 1.5
      , color = "#b22222"
    ) +
    theme(
      legend.position = "top" # c(0.5,1)
      , legend.direction = "horizontal"
      , legend.margin = margin(0,0,0,0)
      , legend.text = element_text(size = 8)
      , legend.title = element_text(size = 8)
      , legend.key = element_rect(fill = "white")
      # , plot.title = ggtext::element_markdown(size = 10, hjust = 0.5)
      , plot.title = element_text(size = 10, hjust = 0.5, face = "bold")
      , plot.subtitle = element_text(size = 8, hjust = 0.5, face = "italic")
    )
  return(plt_combine)
}
# PLOT IT
ortho_plt_fn(my_suid) +
  labs(
    subtitle = "\nstand boundary\n"
    # subtitle = "<span style='color:#b22222;'><b><i>stand boundary</i></b></span>"
  ) +
  theme(
    plot.subtitle = element_text(size = 9.5, color = "#b22222", hjust = 0.5, face = "bold")
  )
# save it
ggplot2::ggsave("../data/NSW_01.jpeg", dpi = "print", height = 11, width = 5.8, device = "jpeg")
```

plot with CHM

```{r, results='hide', fig.show='asis'}
# chm
  chm_temp = chm_rast %>% 
    terra::crop(
      harvests %>% dplyr::filter(suid==my_suid) %>% 
      terra::vect()
    ) %>% 
    terra::mask(
      harvests %>% dplyr::filter(suid==my_suid) %>% 
      terra::vect()
    ) %>% 
    terra::aggregate(fact = 2, fun = "mean", na.rm = T) %>% 
    `*`(3.28) %>% # transform to feet
    as.data.frame(xy=T) %>% 
    rename(f=3)
  
  # plot it
  plt_chm_temp = ortho_plt_fn(my_suid) +
    # chm
    ggnewscale::new_scale_fill() +
    geom_tile(
      data = chm_temp
      , mapping = aes(x = x, y = y, fill = f)
      , na.rm = T
    ) +
    scale_fill_viridis_c(option="plasma", alpha = 0.8, breaks = scales::extended_breaks(n=6), na.value = "transparent") +
    labs(fill = "CHM (ft)")

# PLOT IT
plt_chm_temp
  
# save it
ggplot2::ggsave("../data/NSW_02.jpeg", dpi = "print", height = 11, width = 5.8, device = "jpeg")

```

### ITD

individual trees detected from `lidR::locate_trees()`

```{r, include=FALSE,eval=FALSE}
ortho_plt_fn(my_suid) + plt_chm_temp + 
  patchwork::plot_annotation(tag_levels = list(c("hey","guy"))) & 
  theme(
    plot.tag.position = c(0, 1)
    , plot.tag = element_text(size = 8, hjust = 0, vjust = 0)
  )
```

Height

```{r, results='hide', fig.show='asis'}
plt_ttops_temp = ortho_plt_fn(my_suid) +
    # treetops
    geom_sf(
      data = harvests_trees %>% dplyr::filter(suid==my_suid)
      , mapping = aes(color = tree_height_ft)
      , size = 1
    ) +
    scale_color_viridis_c(option="plasma", alpha = 0.8, breaks = scales::extended_breaks(n=6)) +
    labs(color = "Individual Tree\nHt. (ft)")

# PLOT IT
plt_ttops_temp
  
# save it
ggplot2::ggsave("../data/NSW_03.jpeg", dpi = "print", height = 11, width = 5.8, device = "jpeg")

```

overstory/understory

```{r, results='hide', fig.show='asis'}
plt_ttops_temp = ortho_plt_fn(my_suid) +
    # treetops
    geom_sf(
      data = harvests_trees %>% dplyr::filter(suid==my_suid) %>%
        dplyr::mutate(
          ostory = dplyr::case_when(
            !is.na(as.numeric(ostory_dbh_cm)) &
              dbh_cm>=as.numeric(ostory_dbh_cm) ~ "overstory"
            , !is.na(as.numeric(ostory_ht_m)) &
              tree_height_m>=as.numeric(ostory_ht_m) ~ "overstory"
            , is.na(as.numeric(ostory_dbh_cm)) &
              is.na(as.numeric(ostory_ht_m)) &
              dbh_cm>=5*2.54 ~ "overstory"
            , T ~ "understory"
          )
          , ostory_sz = ifelse(ostory=="overstory",0.51,0.5)
        )
      , mapping = aes(color = ostory)
      , size = 1
    ) +
    scale_color_manual(values = c("navy","gray")) +
    labs(color = "") +
    theme(legend.key = element_rect(color = NA, fill = NA), legend.margin = margin(6.5,0,6.5,0)) +
    guides(size = "none", color = guide_legend(override.aes = list(size = 5)))

# PLOT IT
plt_ttops_temp
  
# save it
ggplot2::ggsave("../data/NSW_04.jpeg", dpi = "print", height = 11, width = 5.8, device = "jpeg")

```

### Tree Groups

Identify tree groups using `dbscan::dbscan()` as outlined by [Hanna et al. (2024)](https://scholar.google.com/scholar?oi=bibs&hl=en&cluster=8254459212692276263): 

>To evaluate the ability of UAS-extracted trees to characterize horizontal and vertical heterogeneity tree arrangement, clusters of trees were identifed within the stem-mapped and UAS trees. A cluster of trees was defned as two or more trees with the potential for interlocking crowns. Overstory trees on the stem maps generally had a crown radius of ~3.0 m, so stems within 6 m of one another were considered to have the potential for developing interlocking crowns. Density-based spatial clustering of applications with noise (DBSCAN) from the fpr package (Hahsler et al., 2019) in R was used to assign trees to unique clusters, including individual trees that were assigned by themselves if they did not have the potential to develop interlocking crowns (>6 m from another tree). (p. 529)

>To analyze the efect of tree aggregation on tree attributes, the identifed trees and clusters were designated as an "individual" or as a cluster consisting of 2-4, 5-9, 10-15, and >15 trees. We then calculated the number of clusters, the percent of stand basal area, the height coefcient of variation, and the canopy area within the cluster size classes for each site. (p. 529-530)

With repect to clump size groupings, [Churchill et al. (2016)](https://scholarworks.umt.edu/ico/3) note that:

>Proportions for clump sizes should be lumped into four or five bins for operational simplicity. We use 4 or 5 bins (Fig 5): individual trees, small clumps (2-4 trees), medium clumps (5-9 trees), and large clumps (10-20+ trees). Note that when instructed to leave a large clump (e.g. 10-20 trees), marking crews often have difficulty leaving the upper end of the size range (e.g. an 18, 19, or 20 tree clump). Thus adding a fifth bin for “super clumps” may be necessary (e.g. 15-20 trees or 20-25+ trees), especially if the upper size range of clumps is desired. (p. 12-13)

```{r}
# filter trees spatially based on unit id
ttops_temp = harvests_trees %>% dplyr::filter(suid==my_suid) %>% 
  dplyr::mutate(
    ostory = dplyr::case_when(
      !is.na(as.numeric(ostory_dbh_cm)) &
        dbh_cm>=as.numeric(ostory_dbh_cm) ~ "overstory"
      , !is.na(as.numeric(ostory_ht_m)) &
        tree_height_m>=as.numeric(ostory_ht_m) ~ "overstory"
      , is.na(as.numeric(ostory_dbh_cm)) &
        is.na(as.numeric(ostory_ht_m)) &
        dbh_cm>=5*2.54 ~ "overstory"
      , T ~ "understory"
    )
  ) %>% 
  dplyr::filter(ostory=="overstory") %>% 
  dplyr::mutate(
    X = sf::st_coordinates(.)[,1] %>% as.numeric()
    , Y = sf::st_coordinates(.)[,2] %>% as.numeric()
  )
#############################################################################
##### Identify clusters in each stem map plot                           #####
#############################################################################
### Place trees into clusters using an inter-tree distance of 6 m
my_dbscan_temp =  ttops_temp %>% 
  sf::st_drop_geometry() %>% 
  dplyr::select(X,Y) %>% 
  dbscan::dbscan(eps = tree_clump_dist_m, minPts = 2)

# my_dbscan_temp %>% str()

### append cluster ID to trees
ttops_temp$dbscan_cluster = my_dbscan_temp$cluster
# ttops_temp$cluster %>% summary()
# ttops_temp %>% sf::st_drop_geometry() %>% dplyr::count(cluster) %>% dplyr::arrange(desc(n)) %>% dplyr::slice_head(n=11)

### cluster metrics
ttops_temp = ttops_temp %>% 
  dplyr::group_by(dbscan_cluster) %>% 
  dplyr::mutate(
    # unique dbscan_cluster for individuals
    clump_id = dplyr::case_when(
      dbscan_cluster == 0 ~ max(my_dbscan_temp$cluster)+dplyr::row_number()
      , T ~ dbscan_cluster
    ) %>% 
    factor()
  ) %>% 
  dplyr::group_by(clump_id) %>% 
  dplyr::mutate(
    dbscan_cluster = factor(dbscan_cluster)
    , clump_n_trees = dplyr::n()
    , clump_n_trees_grp = cut(
        clump_n_trees
        ,breaks = c(0,1,4,9,15,Inf)
        , labels = c("Individual","2-4 trees","5-9 trees","10-15 trees",">15 trees")
      ) %>% 
      factor(
        ordered = T
        , levels = c("Individual","2-4 trees","5-9 trees","10-15 trees",">15 trees")
      )
  ) %>% 
  dplyr::ungroup()
# what?
ttops_temp %>% dplyr::glimpse()
```

plot overstory tree clumps

```{r, include=FALSE, eval=FALSE}
c(
  viridis::turbo(length(unique(ttops_temp$dbscan_cluster))/2 %>% round())
  , viridis::plasma(length(unique(ttops_temp$dbscan_cluster))/2 %>% round(), end = 0.95)
  , viridis::viridis(length(unique(ttops_temp$dbscan_cluster))/2 %>% round(), end = 0.9)
  , viridis::cividis(length(unique(ttops_temp$dbscan_cluster))/2 %>% round(), end = 0.9)
) %>%
  sample() %>%
  .[1:length(unique(ttops_temp$dbscan_cluster))-1] %>% 
  scales::show_col(labels = F)
```

```{r, results='hide', fig.show='asis'}
plt_grps_temp = ortho_plt_fn(my_suid) +
    # treetops
    geom_sf(
      data = ttops_temp
      , mapping = aes(color = dbscan_cluster)
      , size = 1
    ) +
    scale_color_manual(values = c(
      "white"
      , # get random list of colors from viridis and avoid whites
        c(
          viridis::turbo(length(unique(ttops_temp$dbscan_cluster))/2 %>% round())
          , viridis::plasma(length(unique(ttops_temp$dbscan_cluster))/2 %>% round(), end = 0.95)
          , viridis::viridis(length(unique(ttops_temp$dbscan_cluster))/2 %>% round(), end = 0.9)
          , viridis::cividis(length(unique(ttops_temp$dbscan_cluster))/2 %>% round(), end = 0.9)
        ) %>% 
          sample() %>% 
          .[1:length(unique(ttops_temp$dbscan_cluster))-1]
      )
    ) +
    # scale_color_viridis_d("turbo") +
    labs(subtitle = "\n overstory tree groups\n(individual trees in white)") +
    theme(
      legend.position = "none"
      , plot.subtitle = element_text(size = 9.5, hjust = 0.5, face = "bold")
    )

# PLOT IT
plt_grps_temp
  
# save it
ggplot2::ggsave("../data/NSW_05.jpeg", dpi = "print", height = 11, width = 5.8, device = "jpeg")

```

and plot overstory tree clumps by number of trees

```{r, results='hide', fig.show='asis'}
plt_grps_temp = ortho_plt_fn(my_suid) +
    # treetops
    geom_sf(
      data = ttops_temp
      , mapping = aes(color = clump_n_trees_grp)
      , size = 1
    ) +
    scale_color_viridis_d(option="mako", direction = -1) + 
    labs(color = "") +
    theme(legend.key = element_rect(color = NA, fill = NA), legend.margin = margin(6.5,0,6.5,0)) +
    guides(size = "none", color = guide_legend(override.aes = list(size = 5)))

# PLOT IT
plt_grps_temp
  
# save it
ggplot2::ggsave("../data/NSW_06.jpeg", dpi = "print", height = 11, width = 5.8, device = "jpeg")

```

### Within Clump Distance

Determine nearest neighbor distance for the stand and within clusters. Some combination of these metrics has been used to describe relative aggregation. (*source?*)

Calculate the distance to the nearest tree within each clump

```{r}
ttops_temp =
  ttops_temp %>% 
  dplyr::group_by(clump_id) %>%
  tidyr::nest() %>% 
  dplyr::mutate(
    distance_clump_nn_m = purrr::map(data, function(x){
      # get index of nearest neighbor
      i = sf::st_nearest_feature(x)
      # get dist
      d = sf::st_distance(x, x[i,], by_element=TRUE) %>% as.numeric()
      return(d)
    })
  ) %>% 
  tidyr::unnest(cols = c(data, distance_clump_nn_m)) %>% 
  sf::st_set_geometry("geom") %>% # set it cuz it got lost 
  dplyr::ungroup()
  # ggplot() + geom_point(aes(x=X,y=Y,color = distance_clump_nn_m)) + theme_light()
```

plot it

```{r, results='hide', fig.show='asis'}
ortho_plt_fn(my_suid) +
    # treetops
    geom_sf(
      data = ttops_temp
      , mapping = aes(color = distance_clump_nn_m)
      , size = 1
    ) +
    scale_color_viridis_c(option="viridis", na.value = "white") + 
    labs(color = "within clump\nN.N. dist. (m)")
```

#### Create function to get tree list with clumps

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

```{r, warning=T}
# create function to pass a unit id and return list of trees with clump groupings
get_tree_clumps = function(
    my_suid
    , tree_clump_dist_m=6
    , ostory_ht_m = as.numeric(NA)
    , ostory_dbh_cm = as.numeric(NA)
){
  # check ostory definition
  if(is.na(as.numeric(ostory_dbh_cm)) & is.na(as.numeric(ostory_ht_m))){
    warning("`ostory_dbh_cm` and `ostory_ht_m` are not set...using `ostory_dbh_cm` = 12.7")
    ostory_dbh_cm = 5*2.54
    # filter data
    ttops_temp = harvests_trees %>% 
      dplyr::filter(
        suid==my_suid
        & dbh_cm>=as.numeric(ostory_dbh_cm)
      )
  }else if(!is.na(as.numeric(ostory_dbh_cm))){
    # filter data
    ttops_temp = harvests_trees %>% 
      dplyr::filter(
        suid==my_suid
        & dbh_cm>=as.numeric(ostory_dbh_cm)
      )
  }else{
    # filter data
    ttops_temp = harvests_trees %>% 
      dplyr::filter(
        suid==my_suid
        & tree_height_m>=as.numeric(ostory_ht_m)
      )
  }
  # calcs
  ttops_temp = ttops_temp %>% 
    dplyr::mutate(
      X = sf::st_coordinates(.)[,1] %>% as.numeric()
      , Y = sf::st_coordinates(.)[,2] %>% as.numeric()
    )
  #############################################################################
  ##### Identify clusters in each stem map plot                           #####
  #############################################################################
  ### Place trees into clusters using an inter-tree distance of 6 m
  my_dbscan_temp =  ttops_temp %>% 
    sf::st_drop_geometry() %>% 
    dplyr::select(X,Y) %>% 
    dbscan::dbscan(eps = tree_clump_dist_m, minPts = 2)
  
  # my_dbscan_temp %>% str()
  
  ### append cluster ID to trees
  ttops_temp$dbscan_cluster = my_dbscan_temp$cluster
  # ttops_temp$cluster %>% summary()
  # ttops_temp %>% sf::st_drop_geometry() %>% dplyr::count(cluster) %>% dplyr::arrange(desc(n)) %>% dplyr::slice_head(n=11)
  
  ### cluster metrics
  ttops_temp = ttops_temp %>% 
    dplyr::group_by(dbscan_cluster) %>% 
    dplyr::mutate(
      # unique dbscan_cluster for individuals
      clump_id = dplyr::case_when(
        dbscan_cluster == 0 ~ max(my_dbscan_temp$cluster)+dplyr::row_number()
        , T ~ dbscan_cluster
      ) %>% 
      factor()
    ) %>% 
    dplyr::group_by(clump_id) %>% 
    dplyr::mutate(
      dbscan_cluster = factor(dbscan_cluster)
      , clump_n_trees = dplyr::n()
      , clump_n_trees_grp = cut(
          clump_n_trees
          ,breaks = c(0,1,4,9,15,Inf)
          , labels = c("Individual","2-4 trees","5-9 trees","10-15 trees",">15 trees")
        ) %>% 
        factor(
          ordered = T
          , levels = c("Individual","2-4 trees","5-9 trees","10-15 trees",">15 trees")
        )
    ) %>% 
    dplyr::ungroup()
  # add distance to nearest within clump
  ttops_temp =
    ttops_temp %>% 
    dplyr::group_by(clump_id) %>%
    tidyr::nest() %>% 
    dplyr::mutate(
      distance_clump_nn_m = purrr::map(data, function(x){
        # get index of nearest neighbor
        i = sf::st_nearest_feature(x)
        # get dist
        d = sf::st_distance(x, x[i,], by_element=TRUE) %>% as.numeric()
        return(d)
      })
    ) %>% 
    tidyr::unnest(cols = c(data, distance_clump_nn_m)) %>% 
    sf::st_set_geometry("geom") %>% # set it cuz it got lost 
    dplyr::ungroup() %>% 
    dplyr::mutate(
      tree_clump_dist_m = tree_clump_dist_m
      , clump_id_duplicate = clump_id # can use this even after nesting data by clump_id
      # , ostory_ht_m = ifelse(is.na(ostory_ht_m), as.numeric(NA), as.numeric(ostory_ht_m))
      # , ostory_dbh_cm = ifelse(is.na(ostory_dbh_cm), as.numeric(NA), as.numeric(ostory_dbh_cm))
    )
  # return
  return(ttops_temp)
}
# call it
ttops_temp = get_tree_clumps(
  my_suid = my_suid
  , tree_clump_dist_m = tree_clump_dist_m
  , ostory_dbh_cm = ostory_dbh_cm
)
```

### Clump Polygons and Metrics

[Churchill et al. (2016)](https://scholarworks.umt.edu/ico/3) provide instructions for implementing the clump identification (Plotkin et al. 2002) in ArcGIS:

>Use the Buffer tool (in the Proximity toolset within the Analysis toolbox) to create a buffer of distance d/2, one half the inter-tree distance, around each point. This quantity d/2 is meant to approximate the crown radius of a "typical" overstory tree. Set the Dissolve Type option to ALL, which dissolves overlapping buffers, creating a reduced set of spatially non-overlapping polygons stored as a multipart polygon feature...[Sanchez Meador et al. (2011)](https://scholar.google.com/scholar?cluster=15721451396848616769&oi=gsb&hl=en&as_sdt=0,6) provide some useful examples of how clump attributes can be summarized...The method described here can be modified to use measured or modeled crown radii for each tree in place of d/2 (p.36)

```{r}
# create function to pass a return from get_tree_clumps() and create clump polygons with summary stats
get_clump_summary = function(dta){
  # get tree_clump_dist_m
  tree_clump_dist_m = min(dta$tree_clump_dist_m, na.rm = T)
  # create clump polys and summary
  clump_polys_temp = 
    dta %>% 
      dplyr::ungroup() %>% 
      sf::st_set_geometry("geometry") %>% 
      sf::st_buffer(tree_clump_dist_m/2) %>% 
      dplyr::group_by(suid, clump_id, dbscan_cluster, clump_n_trees_grp) %>%
      dplyr::summarise(
        # union buffered tree points
        geometry = sf::st_union(geometry)
        # summary metrics
        , n_trees = dplyr::n_distinct(treeID)
        , mean_dbh_cm = mean(dbh_cm, na.rm = T)
        , mean_tree_height_m = mean(tree_height_m, na.rm = T)
        , loreys_height_m = sum(basal_area_m2*tree_height_m, na.rm = T) / sum(basal_area_m2, na.rm = T)
        , basal_area_m2 = sum(basal_area_m2, na.rm = T)
        , sum_dbh_cm_sq = sum(dbh_cm^2, na.rm = T)
      ) %>%
      dplyr::ungroup() %>% 
      sf::st_make_valid() %>% 
      dplyr::mutate(
        clump_area_ha = sf::st_area(geometry) %>% as.numeric() %>% `/`(10000)
        , trees_per_ha = (n_trees/clump_area_ha)
        , basal_area_m2_per_ha = (basal_area_m2/clump_area_ha)
        , pct_stand_basal_area = basal_area_m2/sum(basal_area_m2)
        , pct_stand_n_trees = n_trees/sum(n_trees)
        , qmd_cm = sqrt(sum_dbh_cm_sq/n_trees)
      ) %>%
      dplyr::select(-c(sum_dbh_cm_sq)) %>%
      # convert to imperial units
      calc_imperial_units_fn() %>% 
      dplyr::mutate(tree_clump_dist_m = tree_clump_dist_m)
  # calculate distance between clumps
  clump_polys_temp = clump_polys_temp %>% 
    dplyr::mutate(
      nearest = sf::st_nearest_feature(clump_polys_temp)
      , distance_nearest_clump_m = sf::st_distance(
          clump_polys_temp
          , clump_polys_temp[nearest,]
          , by_element=TRUE
        ) %>% 
        as.numeric()
    ) %>% 
    dplyr::select(-c(nearest))
  # return
  return(clump_polys_temp)
}
# get it
# get_clump_summary(
#   dta = get_tree_clumps(my_suid = my_suid, tree_clump_dist_m = tree_clump_dist_m)
# )
clump_polys_temp = get_clump_summary(ttops_temp)
# what?
clump_polys_temp %>% dplyr::glimpse()
# do these numbers match
identical(
  # clump polys
  nrow(clump_polys_temp)
  # clumps in tree list data
  , ttops_temp %>% dplyr::distinct(clump_id) %>% nrow()
)
```

plot it

```{r, results='hide', fig.show='asis'}
ortho_plt_fn(my_suid) +
  # clumps
  ggnewscale::new_scale_fill() +
  geom_sf(
    data = clump_polys_temp
    , mapping = aes(fill = dbscan_cluster)
    , color = NA, alpha = 0.9
  ) +
  scale_fill_manual(values = c(
    "white"
    , # get random list of colors from viridis and avoid whites
      c(
        viridis::turbo(length(unique(ttops_temp$dbscan_cluster))/2 %>% round())
        , viridis::plasma(length(unique(ttops_temp$dbscan_cluster))/2 %>% round(), end = 0.95)
        , viridis::viridis(length(unique(ttops_temp$dbscan_cluster))/2 %>% round(), end = 0.9)
        , viridis::cividis(length(unique(ttops_temp$dbscan_cluster))/2 %>% round(), end = 0.9)
      ) %>% 
        sample() %>% 
        .[1:length(unique(ttops_temp$dbscan_cluster))-1]
    )
  ) +
  labs(subtitle = "\n overstory tree group polygons\n(individual trees in white)") +
  theme(
    legend.position = "none"
    , plot.subtitle = element_text(size = 9.5, hjust = 0.5, face = "bold")
  )
```

check the distance between clumps

```{r, results='hide', fig.show='asis'}
ortho_plt_fn(my_suid) +
    ggnewscale::new_scale_fill() +
    geom_sf(
      data = clump_polys_temp
      , mapping = aes(fill = distance_nearest_clump_m)
      , size = 1, color = NA
    ) +
    scale_fill_viridis_c(option="viridis", na.value = "white") + 
    labs(fill = "nearest clump\ndist. (m)")
```

### Clump Spacing

See [Churchill et al. (2016)](https://scholarworks.umt.edu/ico/3) Figure 4 (p.10) and [Matonis and Binkley (2018)](https://scholar.google.com/scholar?cluster=14613232085713826018&hl=en&as_sdt=0,6) who "calculated coverage of mosaic-meadows (percentage of stand > 6 m from overstory trees)" (p. 124)

Since we already buffered the tree points to approximate the crown radius, we'll continue to use our $d/2$ where $d$ is maximum distance between trees for determining tree clumps and is meant to approximate the crown radius of a "typical" overstory tree

```{r}
# create function to pass a return from get_clump_summary() and get a distance raster
get_clump_dist_rast = function(dta){
  # get tree_clump_dist_m
  tree_clump_dist_m = min(dta$tree_clump_dist_m, na.rm = T)
  # suid
  my_suid = dta$suid[1]
  # rasterize the clump polygons and then calculate distance between clumps as raster
  dist_rast = 
    terra::rasterize(
        x = clump_polys_temp %>% terra::vect()
        , y = clump_polys_temp %>% 
          terra::vect() %>% 
          terra::rast(res = 0.2)
      ) %>% 
      terra::distance() %>% 
      # crop it to stand extent
      terra::crop(
        harvests %>% dplyr::filter(suid==my_suid) %>% 
        terra::vect()
      ) %>% 
      terra::mask(
        harvests %>% dplyr::filter(suid==my_suid) %>% 
        terra::vect()
      )
  ######### part 2
  # now create openings vector data
  openings_vect = 
    dist_rast %>% 
      terra::classify(rcl = c(tree_clump_dist_m/2,Inf), others = NA, include.lowest = T) %>% 
      terra::as.polygons(na.rm = T) %>% 
      sf::st_as_sf() %>% 
      sf::st_cast("POLYGON") %>% 
      dplyr::mutate(layer = dplyr::row_number()) %>% 
      dplyr::mutate(
        openining_area_m2 = sf::st_area(geometry) %>% as.numeric()
        , suid = my_suid
        , tree_clump_dist_m = tree_clump_dist_m
      )
  
  # return
  return(list(dist_rast = dist_rast, openings_vect = openings_vect))
}
# get it
dist_rast_temp = get_clump_dist_rast(clump_polys_temp)
dist_rast_temp
```

plot the distance raster and openings vector data we just got with overlaid tree clumps and tree points

```{r}
plt_fnl_temp = 
  ggplot() + 
    # distance
    geom_tile(
      data = dist_rast_temp$dist_rast %>% terra::aggregate(2, cores = 4) %>% as.data.frame(xy = T) %>% rename(f=3)
      , mapping = aes(x=x, y=y, fill = f)
    ) +
    scale_fill_distiller(
      palette = "YlOrRd"
      , na.value = "transparent"
      , direction = 1
      , name = "distance to\nnearest tree (m)"
    ) +
    # openings
    geom_sf(data = dist_rast_temp$openings_vect, mapping = aes(color = openining_area_m2), fill = NA) +
    scale_color_gradient(
      low = "gray77", high = "gray11"
      , labels = scales::comma_format(accuracy = 1)
      , name = latex2exp::TeX("opening\narea ($\\m^2$)")
    ) +
    # clumps
    ggnewscale::new_scale_fill() +
    geom_sf(
      data = clump_polys_temp
      , mapping = aes(fill = clump_n_trees_grp)
      , color = NA
    ) +
    scale_fill_viridis_d(option="mako", direction = -1, name = "clump size") + 
    # tree points
    geom_sf(data = ttops_temp, color = "gray88", shape = ".") +
    theme_void()
# plot
plt_fnl_temp
# save it
ggplot2::ggsave("../data/NSW_07.jpeg", dpi = "print", height = 11, width = 5.8, device = "jpeg")
```

highlight the openings

```{r}
plt_open_temp = 
  ggplot() + 
      # clumps
      geom_sf(
        data = clump_polys_temp
        , mapping = aes(fill = clump_n_trees_grp)
        , color = NA
      ) +
      scale_fill_viridis_d(option="mako", direction = -1, name = "clump size") + 
      # openings
      ggnewscale::new_scale_fill() +
      geom_sf(data = dist_rast_temp$openings_vect, mapping = aes(fill = openining_area_m2), color = NA) +
      scale_fill_gradient(
        low = "gray77", high = "gray11"
        , labels = scales::comma_format(accuracy = 1)
        , name = latex2exp::TeX("opening\narea ($\\m^2$)")
      ) +
      # tree points
      geom_sf(data = ttops_temp, color = "gray88", shape = ".") +
      theme_void()
plt_open_temp
# save it
ggplot2::ggsave("../data/NSW_08.jpeg", dpi = "print", height = 11, width = 5.8, device = "jpeg")
```

combine them?

```{r}
plt_fnl_temp + (plt_open_temp + theme(legend.position = "none"))
# save it
ggplot2::ggsave("../data/NSW_09.jpeg", dpi = "print", height = 11, width = 8, device = "jpeg")
```

### Clump Metrics

create a function to summarize by number of tree clump grouping variable

```{r}
# create a function to summarize by number of tree clump grouping
get_clump_n_trees_grp_summary = function(trees, clumps){
  # get area of harvest unit
  #...will use this area in the area calculations such that...
  #...TPA = trees in a certain group size across the whole stand area
  harvest_area_m2 = harvests %>% 
    dplyr::filter(suid == trees$suid[1]) %>% 
    dplyr::pull(harvest_area_m2) %>% 
    .[1]
  # collapse and calculate silv metrics
  dta = trees %>% 
    sf::st_drop_geometry() %>% 
    dplyr::group_by(suid,stand_area_ha,clump_n_trees_grp) %>%
    dplyr::summarise(
      # summary metrics
      n_trees = dplyr::n_distinct(treeID)
      , mean_dbh_cm = mean(dbh_cm, na.rm = T)
      , mean_tree_height_m = mean(tree_height_m, na.rm = T)
      , loreys_height_m = sum(basal_area_m2*tree_height_m, na.rm = T) / sum(basal_area_m2, na.rm = T)
      , basal_area_m2 = sum(basal_area_m2, na.rm = T)
      , sum_dbh_cm_sq = sum(dbh_cm^2, na.rm = T)
    ) %>%
    dplyr::ungroup() %>% 
    # attach clump area
    dplyr::left_join(
      clumps %>% 
        sf::st_drop_geometry() %>% 
        dplyr::group_by(suid,clump_n_trees_grp) %>%
        dplyr::summarise(clump_area_ha = sum(clump_area_ha), stand_n_clumps = dplyr::n())
    ) %>% 
    dplyr::mutate(
      trees_per_ha = (n_trees/clump_area_ha) # (n_trees/stand_area_ha) ... this was not right
      , basal_area_m2_per_ha = (basal_area_m2/clump_area_ha) # (basal_area_m2/stand_area_ha) ... this was not right
      , qmd_cm = sqrt(sum_dbh_cm_sq/n_trees)
      # stand calcs
      , stand_trees_per_ha = sum(n_trees)/stand_area_ha
      , stand_basal_area_m2 = sum(basal_area_m2)
      , stand_basal_area_m2_per_ha = sum(basal_area_m2)/stand_area_ha
      , pct_stand_basal_area = basal_area_m2/stand_basal_area_m2
      , pct_stand_n_trees = n_trees/sum(n_trees)
      , stand_qmd_cm = sqrt(sum(trees$dbh_cm^2, na.rm = T)/sum(n_trees))
    ) %>%
    dplyr::select(-c(sum_dbh_cm_sq)) %>%
    # convert to imperial units
    calc_imperial_units_fn()
  # return
  return(dta)
}
# call it
clump_n_trees_grp_summary_temp = get_clump_n_trees_grp_summary(
  trees = get_tree_clumps(my_suid = my_suid, tree_clump_dist_m = tree_clump_dist_m, ostory_dbh_cm = ostory_dbh_cm)
  , clumps = get_clump_summary(
    get_tree_clumps(my_suid = my_suid, tree_clump_dist_m = tree_clump_dist_m, ostory_dbh_cm = ostory_dbh_cm)
  )
) 
# what?
clump_n_trees_grp_summary_temp %>% dplyr::glimpse()
```

summary table

```{r}
# table it
clump_n_trees_grp_summary_temp %>% 
  dplyr::select(
    clump_n_trees_grp, n_trees
    , mean_dbh_in
    , qmd_in
    , mean_tree_height_ft
    , loreys_height_ft
    , trees_per_ac
    , basal_area_ft2_per_ac, pct_stand_basal_area, pct_stand_n_trees
  ) %>% 
  dplyr::mutate(
    dplyr::across(
      .cols = c(pct_stand_basal_area, pct_stand_n_trees) 
      , .fns = ~ scales::percent(.x, accuracy = 1)
    )
  ) %>% 
  kableExtra::kbl(
    digits = 1
    , escape = F
    , caption = paste0("Overstory tree clump summary<br>", "stand suid: ", clump_n_trees_grp_summary_temp$suid[1])
    , col.names = c(
      "", "trees"
      , "mean<br>DBH (in)"
      , "QMD (in)"
      , "mean<br>Ht. (ft)"
      , "Loreys<br>Ht. (ft)"
      , "TPA"
      , "BA<br>ft<sup>2</sup> ac<sup>-1</sup>"
      , "%<br>stand BA"
      , "%<br>stand trees"
      )
  ) %>% 
  kableExtra::kable_styling()
```

plot it

```{r}
clump_n_trees_grp_summary_temp %>% 
  dplyr::select(
    clump_n_trees_grp, n_trees
    , mean_dbh_in
    , qmd_in
    , mean_tree_height_ft
    , loreys_height_ft
    , trees_per_ac
    , basal_area_ft2_per_ac, pct_stand_basal_area
  ) %>% 
  dplyr::mutate(pct_stand_basal_area = pct_stand_basal_area*100) %>% 
  tidyr::pivot_longer(
    cols = -c(clump_n_trees_grp)
  ) %>% 
  dplyr::mutate(
    metric = factor(
        name
        , ordered = T
        , levels = c(
            "n_trees"
            , "mean_dbh_in"
            , "qmd_in"
            , "mean_tree_height_ft"
            , "loreys_height_ft"
            , "trees_per_ac"
            , "basal_area_ft2_per_ac"
            , "pct_stand_basal_area"
          )
        , labels = c(
            latex2exp::TeX("Number of Trees", output = "character")
            , latex2exp::TeX("Mean DBH (in)", output = "character")
            , latex2exp::TeX("QMD (in)", output = "character")
            , latex2exp::TeX("Mean Tree Height (ft)", output = "character")
            , latex2exp::TeX("Lorey's Mean Height (ft)", output = "character")
            , latex2exp::TeX("Trees $ac^{-1}$")
            , latex2exp::TeX("Basal Area $ft^{2} \\cdot ac^{-1}$")
            , latex2exp::TeX("% stand BA", output = "character")
          )
      )
    , clump_n_trees_grp = forcats::fct_rev(clump_n_trees_grp)
  ) %>% 
  ggplot(mapping = aes(
      x = value, y = clump_n_trees_grp
      , fill = name, label = scales::number(value, accuracy = 0.1)
    )
  ) +
  geom_col(width = 0.7) +
  geom_text(color = "black", size = 3.5, hjust = -0.1) +
  facet_wrap(facets = vars(metric), ncol = 2, scales = "free_x", labeller = label_parsed) +
  scale_fill_viridis_d(option = "cividis", alpha = 0.9) +
  scale_x_continuous(expand = expansion(mult = c(0,0.1))) +
  labs(
    x = "", y = ""
    , subtitle = paste0(
      "Overstory tree clump summary\n"
      , "stand suid: "
      , clump_n_trees_grp_summary_temp$suid[1])
  ) +
  theme_light() +
  theme(
    legend.position = "none"
    , strip.text = element_text(color = "black", size = 10)
    , strip.background = element_rect(fill = "gray88")
    , axis.text.y = element_text(face = "bold")
    , axis.ticks.y = element_blank()
    , panel.grid.major.y = element_blank()
    , panel.grid.minor.y = element_blank()
  )
```

## ICO Implementation

[Churchill et al. (2016)](https://scholarworks.umt.edu/ico/3) describe the full process for implementing the ICO approach in *[The ICO Approach to Quantifying and Restoring Forest Spatial Pattern: Implementation Guide](https://scholarworks.umt.edu/ico/3)* in which the authors lay out the prescription development process:

1. Identify skips and other special treatment areas
2. Consider the need for openings
3. Determine the stand average density target
4. Determine the appropriate distance to define clumps
5. Obtain targets for clump proportions
6. Select target clump proportions for your stand
7. Generate clump targets for the whole unit
8. Combine clump and opening targets with leave tree criteria into marking guidelines

The objective here is to: 1) provide the manager with the current conditions (completed above); 2) take the "targets" as set by the manager (steps 3, 5, 6, 7); 3) create the prescription with the leave tree marking.

Let's implement this prescription development process with our UAS tree list

### 3. Determine the stand average density target

Step 3 in [Churchill et al. (2016)](https://scholarworks.umt.edu/ico/3): 

>An average BA, TPA, or SDI target for the stand should be selected that is appropriate for the species, structure, site conditions, and management objectives. Expected mortality from prescribed fire should be factored in. Stand average targets can come from historical reference stands, plant association based stocking guides, density management tools, or a combination of both (see Franklin et al. (2013) for a full discussion of setting density targets). In dry forests, the number and size of old trees must be accounted in setting the density target. To use the ICO method, the target must be converted to TPA (see Table 1). A lower diameter cutoff also needs to be specified for the TPA target. This should be the lower limit in the contract or cutting guidelines given to the marking crew or contractor. (p.11)

this is what Table 1 looks like with TPA values are derived from the formula: 

$$
TPA = \frac{BA}{QMD^{2} \times 0.005454}
$$

```{r}
# function to get tpa from ba and qmd
get_tpa = function(ba_ft2_ac, qmd_in){
  tpa = round(ba_ft2_ac/((qmd_in^2)*0.005454))
  return(tpa)
} 
# table it
tidyr::crossing(
    ba = seq(40,200,20)
    , qmd = seq(8,20,2)
  ) %>% 
  dplyr::mutate(
    tpa = get_tpa(ba,qmd)
  ) %>% 
  tidyr::pivot_wider(names_from = ba, values_from = tpa) %>% 
  dplyr::mutate(l = "QMD (in)") %>% 
  dplyr::relocate(l) %>% 
  kableExtra::kbl(
    col.names = c(".","", seq(40,200,20))
    , escape = F
    , caption = "Basal Area and QMD to TPA conversion chart"
  ) %>% 
  kableExtra::add_header_above(
    c("","", "Basal Area (ft2/ac)"=length(seq(40,200,20)))
  ) %>%
  kableExtra::kable_styling() %>% 
  kableExtra::column_spec(1:2, bold = T) %>%
  kableExtra::collapse_rows(columns = 1, valign = "middle")
```

#### Current Stand Conditions

For determining targets, the silviculturist needs to know the current conditions. Provide the current stand conditions based on the UAS tree list for the selected stand that are required to set the targets:

* Current BA
* Current QMD
* Current proportion of trees by clump size

```{r}
clump_n_trees_grp_summary_temp %>% 
  dplyr::select(clump_n_trees_grp, pct_stand_n_trees) %>% 
  dplyr::mutate(
    pct_stand_n_trees = scales::percent(pct_stand_n_trees,accuracy = 1)
  ) %>% 
  tidyr::pivot_wider(names_from = clump_n_trees_grp, values_from = pct_stand_n_trees) %>% 
  kableExtra::kable(
    caption = paste0(
      "Current stand BA (ft2/ac): "
      , clump_n_trees_grp_summary_temp$stand_basal_area_ft2_per_ac[1] %>% scales::number(accuracy = 0.1)
      , "<br>Current stand QMD (in): "
      , clump_n_trees_grp_summary_temp$stand_qmd_in[1] %>% scales::number(accuracy = 0.1)
      , "<br>Current stand TPA: "
      , clump_n_trees_grp_summary_temp$stand_trees_per_ac[1] %>% scales::number(accuracy = 1)
    )
    , escape = F
    , digits = 1
  ) %>% 
  kableExtra::kable_styling() %>% 
  kableExtra::footnote(general = "values are the percent of trees in each clump size")
```

```{r, include=FALSE, eval=FALSE}
clump_n_trees_grp_summary_temp = get_clump_n_trees_grp_summary(
  trees = get_tree_clumps(my_suid = harvests$suid[2], tree_clump_dist_m = tree_clump_dist_m, ostory_dbh_cm = 5*2.54)
  , clumps = get_clump_summary(
    get_tree_clumps(my_suid = harvests$suid[2], tree_clump_dist_m = tree_clump_dist_m, ostory_dbh_cm = 5*2.54)
  )
)
clump_n_trees_grp_summary_temp %>% 
  dplyr::select(clump_n_trees_grp, pct_stand_n_trees) %>% 
  dplyr::mutate(
    pct_stand_n_trees = scales::percent(pct_stand_n_trees,accuracy = 1)
  ) %>% 
  tidyr::pivot_wider(names_from = clump_n_trees_grp, values_from = pct_stand_n_trees) %>% 
  kableExtra::kable(
    caption = paste0(
      "Current stand BA (ft2/ac): "
      , clump_n_trees_grp_summary_temp$stand_basal_area_ft2_per_ac[1] %>% scales::number(accuracy = 0.1)
      , "<br>Current stand QMD (in): "
      , clump_n_trees_grp_summary_temp$stand_qmd_in[1] %>% scales::number(accuracy = 0.1)
      , "<br>Current stand TPA: "
      , clump_n_trees_grp_summary_temp$stand_trees_per_ac[1] %>% scales::number(accuracy = 1)
    )
    , escape = F
    , digits = 1
  ) %>% 
  kableExtra::kable_styling()
```

### 5. Obtain targets for clump proportions

Step 5 in [Churchill et al. (2016)](https://scholarworks.umt.edu/ico/3): 

>ICO prescriptions are based on a target proportion of trees in different sized clumps within a stand. Proportions are just the percentage of trees, or TPA, that are in different sized clumps. Basal area proportions can be used, but we have found TPA targets to be more straightforward to use. Ideally, a table summarizing clump proportions for a range of reference conditions in your area is available (Table 2). If not, instructions for developing one are provided in section VI. (p.12)

Section VI of [Churchill et al. (2016)](https://scholarworks.umt.edu/ico/3) notes that

>reference spatial information may already be available and summarized in a way that it can be directly incorporated into ICO prescriptions. Such data exist and have been published for areas in Arizona (Abella and Denton 2009, Sánchez Meador et al. 2011), the eastern Washington Cascades (Churchill et al. 2013), the northern Rockies (Larson et al. 2012), and the Sierra Nevada (Lydersen et al. 2013). Reference datasets for using ICO in other forest types, such as coastal Douglas-fir or Pacific silver fir, also exist (Larson and Churchill 2008). (p.28)

Table 2 is:

```{r, echo=FALSE, out.width="70%", out.height="70%", fig.align='center', fig.show='hold',results='asis'}
knitr::include_graphics("https://i.ibb.co/N1hpzLj/churchilletal2016-table2.jpg")
```

### 6. Select target clump proportions for your stand

*Now set the desired BA, QMD, and proportion of trees in each clump size:*

```{r}
########################################################################################
########################################################################################
# desired BA, QMD, and proportion of trees in each clump size
########################################################################################
########################################################################################
# desired BA
  target_ba = 37 # cannot be > current BA
# desired QMD
  target_qmd = 11
# desired proportion (%) of trees in each clump size
  # !cannot be create larger proportion of ">15 trees" clump as this would require adding trees...
  # c("Individual", "2-4 trees", 	"5-9 trees", 	"10-15 trees", ">15 trees")
  # c(.18, .33, .24, .10, .15)
  target_pcts = c(.18, .33, .24, .10, .15)
########################################################################################
########################################################################################
# desired BA, QMD, and proportion of trees in each clump size
########################################################################################
########################################################################################
```

Check set up and define data with targets

```{r, warning=TRUE}
get_target_check_prescription = function(
  clump_n_trees_grp_summary_dta
  , target_ba = as.numeric(NA)
  , target_qmd = as.numeric(NA)
  , target_pcts = as.numeric(NA)
){
  if(
    is.na(target_ba) | is.na(target_qmd) | max(is.na(target_pcts))==1
  ){
    stop("must set all of the function parameters:\n`target_ba`, `target_qmd`, and `target_pcts`")
  }
  #############################################
  # check target BA and TPA
  #############################################
  if(as.numeric(target_ba)>clump_n_trees_grp_summary_dta$stand_basal_area_ft2_per_ac[1]){
    stop(
      "target BA in `target_ba` of "
      , round(as.numeric(target_ba),1), " is greater than current BA of "
      , clump_n_trees_grp_summary_dta$stand_basal_area_ft2_per_ac[1] %>% round(1)
    )
  }
  if(
    get_tpa(target_ba, target_qmd)>clump_n_trees_grp_summary_dta$stand_trees_per_ac[1]
  ){
    stop(
      "target TPA in of "
      , round(as.numeric(get_tpa(target_ba, target_qmd)),1), " is greater than current TPA of "
      , clump_n_trees_grp_summary_dta$stand_trees_per_ac[1] %>% round(1)
      , "\n adjust `target_ba` and/or `target_qmd` to get valid TPA"
    )
  }
  #############################################
  # define data with current and target
  # ... this is "smart" in that percentages are adj based on:
  # ... 0) are there missing targets?
  # ... ... if < 5 numbers provided in `target_pcts` then the largest tree groups get targets of 0
  # ... 1) do targets sum to 1? 
  # ... ... if not trees are distributed proportionally based on targets provided and trees available
  # ... 2) is target in largest clump size > current conditions?
  # ... ... if yes, target is set to current condition
  # ... 3) is target listed in clump size > current largest clump with trees?
  # ... ... if yes, target for largest clump size is shifted to current largest clump with trees
  #############################################
    target_data = 
      # create data for joining if missing clump groups
      dplyr::tibble(
        suid = rep(clump_n_trees_grp_summary_dta$suid[1],5)
        , stand_area_ac = rep(clump_n_trees_grp_summary_dta$stand_area_ac[1],5)
        , clump_n_trees_grp = factor(
          c(1:5)
          , labels = c("Individual", "2-4 trees", 	"5-9 trees", 	"10-15 trees", ">15 trees")
          , ordered = T
        )
        , mean_clump_n_trees = c(1,3,7,12,20)
      ) %>% 
      dplyr::left_join(
        clump_n_trees_grp_summary_dta %>% 
          dplyr::ungroup() %>% 
          dplyr::select(clump_n_trees_grp, pct_stand_n_trees, stand_n_clumps)
      ) %>% 
      dplyr::mutate(
        pct_stand_n_trees = dplyr::coalesce(pct_stand_n_trees,0)
        , stand_n_clumps = dplyr::coalesce(stand_n_clumps,0)
      ) %>% 
      # add targets
      dplyr::bind_cols(
        pct_stand_n_trees_target = c(as.numeric(target_pcts), rep(0,5))[1:5] # pad target with 0's
      ) %>% 
      # adjust target based on difference from 1
      dplyr::mutate(
        pct_stand_n_trees_target = pct_stand_n_trees_target*(1/sum(pct_stand_n_trees_target))
        # largest clump size with trees
        , largest_w_trees = max(ifelse(dplyr::coalesce(pct_stand_n_trees)>0,clump_n_trees_grp,NA),na.rm = T)
        , largest_w_trees_target = max(ifelse(dplyr::coalesce(pct_stand_n_trees_target)>0,clump_n_trees_grp,NA),na.rm = T)
      ) %>% 
      # move target for largest clump size to the largest current clump size 
      dplyr::mutate(
        pct_stand_n_trees_target = dplyr::case_when(
          as.numeric(clump_n_trees_grp)==largest_w_trees &
            largest_w_trees_target>largest_w_trees ~ max(
              ifelse(as.numeric(clump_n_trees_grp)==largest_w_trees_target,pct_stand_n_trees_target,0)
            )
          , T ~ pct_stand_n_trees_target
        )
      ) %>% 
      # adjust target based on current conditions
      dplyr::mutate(
        pct_stand_n_trees_target = dplyr::case_when(
          as.numeric(clump_n_trees_grp)>largest_w_trees &
            pct_stand_n_trees_target > 0 ~ 0
          , as.numeric(clump_n_trees_grp)==largest_w_trees &
            pct_stand_n_trees_target > pct_stand_n_trees ~ pct_stand_n_trees
          , T ~ pct_stand_n_trees_target
        )
      ) %>% 
      # finally, re-scale again based on adjustments
      dplyr::mutate(
        pct_stand_n_trees_target = dplyr::case_when(
          as.numeric(clump_n_trees_grp)==largest_w_trees ~ pct_stand_n_trees_target
          , T ~ pct_stand_n_trees_target * (
            # pct remaining to scale to
            (1-max(ifelse(as.numeric(clump_n_trees_grp)==largest_w_trees,pct_stand_n_trees_target,0))) /
            # current pct remaining total allocated
            sum(
              ifelse(as.numeric(clump_n_trees_grp)!=largest_w_trees,pct_stand_n_trees_target,0))
            )
        )
      ) %>% 
      # add other targets
      dplyr::rename(pct_stand_n_trees_current = pct_stand_n_trees) %>% 
      dplyr::mutate(
        stand_trees_per_ac_current = clump_n_trees_grp_summary_dta$stand_trees_per_ac[1]
        , stand_trees_per_ac_target = get_tpa(target_ba, target_qmd)
        , trees_per_acre_current = stand_trees_per_ac_current*pct_stand_n_trees_current
        , trees_per_acre_target = stand_trees_per_ac_target*pct_stand_n_trees_target
        , clumps_per_acre_current = trees_per_acre_current/mean_clump_n_trees
        , clumps_per_acre_target = trees_per_acre_target/mean_clump_n_trees
        , stand_n_clumps_current = stand_n_clumps
        , stand_n_clumps_target = (clumps_per_acre_target*stand_area_ac) %>% round(0)
      ) %>% 
      dplyr::select(-c(tidyselect::starts_with("largest_w_trees"), stand_n_clumps))
  # ????  
  # target_data %>% glimpse()
  
    # issue warning about targets
    if(min(target_data$pct_stand_n_trees_target == c(as.numeric(target_pcts), rep(0,5))[1:5])==0){
      warning(
        "proportion of trees in each clump size target `target_pcts` adjusted!!!"
        , "\nfrom : ", paste(round(target_pcts,2),collapse = ",")
        , "\nto : ", paste(round(target_data$pct_stand_n_trees_target,2),collapse = ",")
      )
    }
  # return
  return(target_data)
}
# call it
target_data_temp = get_target_check_prescription(
  clump_n_trees_grp_summary_temp
  , target_ba = target_ba
  , target_qmd = target_qmd
  , target_pcts = target_pcts
)
# what?
target_data_temp %>% dplyr::glimpse()
```

current vs target

```{r}
target_data_temp %>% 
  dplyr::select(
    clump_n_trees_grp
    , tidyselect::starts_with("pct_stand_n_trees")
    , tidyselect::starts_with("trees_per_acre_")
  ) %>% 
  dplyr::mutate(
    dplyr::across(
      tidyselect::starts_with("pct_stand_n_trees")
      , ~ scales::percent(.x,accuracy = 1)
    )
  ) %>% 
  kableExtra::kable(
    caption = paste0(
      "Current stand BA (ft2/ac): "
      , clump_n_trees_grp_summary_temp$stand_basal_area_ft2_per_ac[1] %>% scales::number(accuracy = 0.1)
      , "<br>Current stand QMD (in): "
      , clump_n_trees_grp_summary_temp$stand_qmd_in[1] %>% scales::number(accuracy = 0.1)
      , "<br>Current stand TPA: "
      , clump_n_trees_grp_summary_temp$stand_trees_per_ac[1] %>% scales::number(accuracy = 1)
    )
    , escape = F
    , digits = 1
    , col.names = c(
      "", rep(c("current","target"),2)
    )
  ) %>% 
  kableExtra::kable_styling() %>% 
  kableExtra::add_header_above(
    c(" "=1,"% Trees"=2, "TPA"=2)
  )
```

### 8. Combine clump and opening targets with leave tree criteria into marking guidelines

Use our UAS tree list to generate the prescription:

* start with the largest clump size currently with trees
* cut trees to the next largest clump size until desired # clumps is reached
* repeat with each successive clump size through to individual tree selection
* if possible, cut in same clump until desired proportions are reached to minimize machine time

#### Example for one clump

Example for one clump where we identify the "narrow" areas of the clump polygon and cut trees in those areas to achieve desired clump level with minimum cutting

example clump

```{r}
# clump_polys_temp %>% dplyr::filter(clump_n_trees_grp == ">15 trees") %>% mapview()
###### !!!!!!!!!!!!!!!!! CUT BY NARROW AREAS?
# just one clump example
id_temp = # 141
  clump_polys_temp %>% 
  dplyr::filter(clump_n_trees_grp == ">15 trees") %>% 
  dplyr::slice_sample(prop = .3) %>% 
  dplyr::arrange(desc(n_trees)) %>% 
  dplyr::pull(clump_id) %>% 
  .[1]
# data for passing to function with nest()
x = ttops_temp %>% 
  dplyr::filter(clump_n_trees_grp == ">15 trees") %>%
  dplyr::filter(clump_id == id_temp)
# plot it
ggplot() +
  geom_sf(data = clump_polys_temp %>% dplyr::filter(clump_id==x$clump_id[1]), fill = NA) +
  geom_sf(data = x, color = "gray") +
  labs(subtitle = paste0("example ", x$clump_n_trees_grp[1], " clump group")) +
  theme_void()
```

identify the tree points that are furthest apart and draw a line which we'll use to make cuts perpendicular to the clump

```{r}
# find the next group size for target
# !!! going to have to change the process for clump_n_trees_grp == "Individual"
ntree_target_temp = target_data_temp %>%
  dplyr::mutate(l = dplyr::lag(clump_n_trees_grp)) %>%
  dplyr::filter(clump_n_trees_grp == x$clump_n_trees_grp[1]) %>%
  dplyr::pull(l)

# find farthest distance between points
dist_temp = sf::st_distance(x)
# get the points
f_pts_temp = 
  x %>% 
    dplyr::ungroup() %>% 
    dplyr::slice(
      # get the farthest points from distance matrix
      which(dist_temp == max(dist_temp), arr.ind = TRUE)[1,]
    )

# draw a line between the farthest two points
f_line_temp = f_pts_temp %>% 
    # convert to linestring
    dplyr::group_by(clump_id) %>% 
    dplyr::summarise(n=dplyr::n()) %>%
    sf::st_cast("LINESTRING") %>%
    dplyr::ungroup()
# we need to extend the line...
# borrowing from https://github.com/metafor-ulaval/ALSroads/blob/main/R/line_tools.R
  # Get heading of both ends of a line
  st_ends_heading <- function(line){
    M <- sf::st_coordinates(line)
    i <- c(2, nrow(M) - 1)
    j <- c(1, -1)
    
    headings <- mapply(i, j, FUN = function(i, j) {
      Ax = M[i-j,1]
      Ay = M[i-j,2]
      Bx = M[i,1]
      By = M[i,2]
      atan2(Ay-By, Ax-Bx)*180/pi
    })
    names(headings) <- c("head", "tail")
    return(headings)
  }
  
  # extend the line on both ends
  st_extend_line <- function(line, distance, end = "BOTH"){
    if (!(end %in% c("BOTH", "HEAD", "TAIL")) | length(end) != 1) stop("'end' must be 'BOTH', 'HEAD' or 'TAIL'")
  
    M <- sf::st_coordinates(line)[,-3]
    keep <- !(end == c("TAIL", "HEAD"))
    
    ends <- c(1, nrow(M))[keep]
    headings <- st_ends_heading(line)[keep] / 180 * pi
    distances <- if (length(distance) == 1) rep(distance, 2) else distance[1:2]
    
    M[ends, 1:2] <- M[ends, 1:2] + distances[keep] * c(cos(headings), sin(headings))
    newline <- sf::st_linestring(M)
  
    # If input is sfc_LINESTRING and not sfg_LINESTRING
    if (is.list(line)) newline <- sf::st_sfc(newline, crs = sf::st_crs(line))
    
    return(newline)
  }

# and apply the line extension
  f_line_temp = st_extend_line(f_line_temp, distance = tree_clump_dist_m)
  
  ggplot() +
    geom_sf(data = f_line_temp, color = "blue", lwd = 1.5) +
    geom_sf(data = clump_polys_temp %>% dplyr::filter(clump_id==x$clump_id[1]), fill = NA) +
    geom_sf(data = x, color = "gray") +
    labs(subtitle = paste0("example ", x$clump_n_trees_grp[1], " clump group")) +
    theme_void()
```

now draw the lines perpendicular to this furthest line which represent potential cut lines

```{r}
#### draw lines perpendicular to current line
# 1) points along the f line
  line_pts_temp = f_line_temp %>% 
    sf::st_line_sample(
      density = 1 # density (points per distance unit) of the sampling: 2=0.5m
      , type = "regular"
    ) %>% 
    sf::st_cast("POINT")

### https://stackoverflow.com/questions/56771058/perpendicular-lines-at-regular-intervals-along-lines-with-multiple-nodes
# Function to calculate Euclidean distance between 2 points
euclidean_distance = function(p1,p2) {
    return(sqrt((p2[1] - p1[1])^2 + (p2[2] - p1[2])^2))
}
# euclidean_distance(
#   sf::st_coordinates(f_pts_temp)[1,], sf::st_coordinates(f_pts_temp)[2,] # end points on f line
# )

# Function to calculate 2 points on a line perpendicular to another defined by 2 points p1,p2
# For point at interval, which can be a proportion of the segment length, or a constant
get_perp_line = function(interval=0.5, my_line, proportion=TRUE) {
    # get end points of line
    p1 = my_line %>% sf::st_cast("POINT") %>% sf::st_coordinates() %>% .[1,]
    p2 = my_line %>% sf::st_cast("POINT") %>% sf::st_coordinates() %>% .[2,]
    # get length of line to return equal length line
    line_len = sf::st_length(my_line) %>% as.numeric() %>% `/`(2)      
    # get crs of line
    my_crs = sf::st_crs(my_line)
    
    # Calculate x and y distances
    x_len <- p2[1] - p1[1]
    y_len <- p2[2] - p1[2]

    # If proportion calculate reference point from tot_length
    if (proportion) {
        point <- c(p1[1]+x_len*interval,p1[2]+y_len*interval)
    }
    # Else use the constant value
    else {
        tot_len <- euclidean_distance(p1,p2)
        point <- c(p1[1]+x_len/tot_len*interval,p1[2]+y_len/tot_len*interval)
    }    

    # Calculate the x and y distances from reference point to point on line line_len distance away    
    ref_len <- euclidean_distance(point,p2)
    xn_len <- (line_len / ref_len) * (p2[1] - point[1])
    yn_len <- (line_len / ref_len) * (p2[2] - point[2])

    # Invert the x and y lengths and add/subtract from the refrence point
    # ref_points <- rbind(point,c(point[1] + yn_len,point[2] - xn_len),c(point[1] - yn_len,point[2] + xn_len))
    ref_points <- rbind(c(point[1] + yn_len,point[2] - xn_len),c(point[1] - yn_len,point[2] + xn_len))

    # use the reference points to return a line
    return(
      ref_points %>% 
        dplyr::as_tibble() %>% 
        dplyr::rename_with(tolower) %>% 
        sf::st_as_sf(coords = c("x", "y"), crs = my_crs, remove = F) %>%
        dplyr::summarise(n=dplyr::n()) %>%
        sf::st_cast("LINESTRING") %>%
        dplyr::ungroup() %>% 
        dplyr::select(-c(n))
    )
}
# get_perp_line(my_line = f_line_temp, interval = 0, proportion = F)

# 5) now get perpendicular lines in dataset which we can iterate over to make cuts
perp_line_sf_temp = 
  # for every 1 m along line length, get a new perp line
  seq(
      from = 0
      , to = sf::st_length(f_line_temp) %>% as.numeric() %>% floor()
      , by = 1
    ) %>% 
  purrr::map(
    get_perp_line
    , my_line = f_line_temp, proportion = F
  ) %>% 
  dplyr::bind_rows() %>% 
  dplyr::mutate(line_n = dplyr::row_number())

perp_line_sf_temp %>% 
    ggplot() +
    geom_sf(color = "cyan", lwd = 0.5) +
    geom_sf(data = f_line_temp, color = "blue", lwd = 1.5) +
    # geom_sf(data = line_pts_temp, color = "red", size = 1.5, fill = NA, shape = 21) +
    geom_sf(data = clump_polys_temp %>% dplyr::filter(clump_id==x$clump_id[1]), fill = NA) +
    geom_sf(data = x, color = "gray") +
    labs(
      subtitle = paste0("example ", x$clump_n_trees_grp[1], " clump group")
      , caption = "*potential cut lines shown in light blue"
    ) +
    theme_void()
```

```{r, include=FALSE, eval=FALSE}
# nah!!!!!!!!!!!!!!!!!!
# what about adding another potential line cut?
perp_line_sf_temp = dplyr::bind_rows(
  ##### perpendicular to f line
    # for every 1 m along line length, get a new perp line
    seq(
        from = 0
        , to = sf::st_length(f_line_temp) %>% as.numeric() %>% floor()
        , by = 1
      ) %>% 
    purrr::map(
      get_perp_line
      , my_line = f_line_temp, proportion = F
    ) %>% 
    dplyr::bind_rows()
  , ##### horizontal to f line
    # for every 1 m along line length, get a new perp line
    seq(
        from = 0
        , to = get_perp_line(my_line = f_line_temp, interval = 0.5, proportion = T) %>% 
          sf::st_length() %>% 
          as.numeric() %>% 
          floor()
        , by = 1
      ) %>% 
    purrr::map(
      get_perp_line
      , my_line = get_perp_line(my_line = f_line_temp, interval = 0.5, proportion = T)
      , proportion = F
    ) %>% 
    dplyr::bind_rows()
) %>% 
dplyr::mutate(line_n = dplyr::row_number())

perp_line_sf_temp %>% 
ggplot() +
    geom_sf(color = "cyan", lwd = 0.2) +
    geom_sf(data = f_line_temp, color = "blue", lwd = 1.5) +
    # geom_sf(data = line_pts_temp, color = "red", size = 1.5, fill = NA, shape = 21) +
    geom_sf(data = clump_polys_temp %>% dplyr::filter(clump_id==x$clump_id[1]), fill = NA) +
    geom_sf(data = x, color = "gray") +
    labs(
      subtitle = paste0("example ", x$clump_n_trees_grp[1], " clump group")
      , caption = "*potential cut lines shown in light blue"
    ) +
    theme_void()
```

intersect the potential cut lines with the clump polygon to identify the length of the line intersection

```{r}
# 6) find intersection of lines with the polygon and add length of intersection to perp line data
perp_line_sf_temp = perp_line_sf_temp %>% 
  dplyr::inner_join(
    # intersect and calc len
    perp_line_sf_temp %>% 
      sf::st_intersection(
        clump_polys_temp %>% 
          dplyr::ungroup() %>% 
          dplyr::select(clump_id) %>% 
          dplyr::filter(clump_id == x$clump_id[1])
      ) %>% 
      dplyr::mutate(len_m = sf::st_length(geometry) %>% as.numeric()) %>% 
      sf::st_drop_geometry()
    , by = "line_n"
  )

perp_line_sf_temp %>% 
  sf::st_intersection(
    clump_polys_temp %>% 
      dplyr::ungroup() %>% 
      dplyr::select(clump_id) %>% 
      dplyr::filter(clump_id == x$clump_id[1])
  ) %>% 
  dplyr::mutate(len_m = sf::st_length(geometry) %>% as.numeric()) %>% 
  ggplot() +
    geom_sf(mapping = aes(color = len_m), lwd = 0.8) +
    scale_color_distiller(palette = "Greys", direction = -1) +
    geom_sf(data = f_line_temp, color = "blue", lwd = 1.5) +
    # geom_sf(data = line_pts_temp, color = "red", size = 1.5, fill = NA, shape = 21) +
    geom_sf(data = clump_polys_temp %>% dplyr::filter(clump_id==x$clump_id[1]), fill = NA) +
    geom_sf(data = x, color = "gray") +
    labs(
      subtitle = paste0("example ", x$clump_n_trees_grp[1], " clump group")
      , color = "cut line\nlength (m)"
    ) +
    theme_void()
  # perp_line_sf_temp %>% ggplot(aes(x = len_m)) + geom_histogram()
```

start cutting at the narrowest places using the shortest cut line intersection length until we get the desired clump size group(s) (i.e. the next smallest clump size)

```{r, include=FALSE, eval=FALSE}
# nah!!!!!!!!!!!!!!!!!!
# joint cut line length to individual trees to prioritize trees with lowest total cut length for removal
# perp_line_sf_temp %>% sf::st_drop_geometry() %>% dplyr::glimpse()
cut_trees_rank_temp = 
  x %>% 
    sf::st_buffer(tree_clump_dist_m/2) %>% 
    sf::st_join(perp_line_sf_temp) %>% 
    sf::st_drop_geometry() %>% 
    dplyr::select(treeID, line_n, len_m) %>% 
    dplyr::group_by(treeID) %>% 
    dplyr::summarise(total_len_m = sum(len_m)) %>% 
    dplyr::ungroup() %>% 
    dplyr::arrange(total_len_m) %>% 
    dplyr::mutate(cut_tree_rank = dplyr::row_number())
# plot it
x %>% 
  dplyr::inner_join(cut_trees_rank_temp) %>% 
  sf::st_buffer(tree_clump_dist_m/2) %>% 
  ggplot() +
    geom_sf(mapping = aes(fill = cut_tree_rank), color = NA) +
    scale_fill_distiller(palette = "Greys", direction = -1) +
    geom_sf(data = f_line_temp, color = "blue", lwd = 1.5) +
    # geom_sf(data = line_pts_temp, color = "red", size = 1.5, fill = NA, shape = 21) +
    geom_sf(data = clump_polys_temp %>% dplyr::filter(clump_id==x$clump_id[1]), fill = NA) +
    geom_sf(data = x, color = "gray") +
    labs(
      subtitle = paste0("example ", x$clump_n_trees_grp[1], " clump group")
      , fill = "tree cut rank"
    ) +
    theme_void()
```

```{r}
# 7) make cuts at the points where there is the least overlap with the clump polygon
  # list of potential line cut + tree combinations
  cut_tree_lines_temp = 
    x %>% 
      sf::st_buffer(tree_clump_dist_m/2) %>% 
      sf::st_join(perp_line_sf_temp) %>% 
      sf::st_drop_geometry() %>% 
      dplyr::group_by(treeID) %>% 
      dplyr::summarise(len_m = mean(len_m, na.rm = T)) %>% 
      dplyr::arrange(len_m, treeID) %>% 
      dplyr::mutate(n = dplyr::row_number())
  ###############################################################
  # while
  ###############################################################
  # cut until the desired clump size is achieved
  while_temp = 1
  i = 1
  while(while_temp==1) {
    # cut trees
    cut_trees_temp = cut_tree_lines_temp %>% 
      dplyr::slice(1:i) %>% 
      dplyr::distinct(treeID)
    
    # get the remaining trees not cut
    trees_remain_temp = x %>% 
      sf::st_drop_geometry() %>% 
      dplyr::anti_join(cut_trees_temp, by = "treeID") %>% 
      dplyr::select(X,Y)
    
    # ensure that there are trees
    if(nrow(trees_remain_temp)==0){
      # there are no more possible cuts :/
      best_cuts = dplyr::tibble(treeID = character())
      # stop it
      while_temp = 0
    }else{
        # cut them from the clump and check the new dbscan
        my_dbscan_temp = trees_remain_temp %>% 
          dbscan::dbscan(eps = tree_clump_dist_m, minPts = 2)
        
        # count the groups
        desired_grps_n_temp = dplyr::tibble(
            dbscan_cluster = my_dbscan_temp$cluster
          ) %>% 
          dplyr::mutate(
            # unique dbscan_cluster for individuals
            clump_id = dplyr::case_when(
              dbscan_cluster == 0 ~ max(my_dbscan_temp$cluster)+dplyr::row_number()
              , T ~ dbscan_cluster
            ) %>% 
            factor()
          ) %>% 
          dplyr::group_by(clump_id) %>% 
          dplyr::summarise(clump_n_trees = dplyr::n()) %>% 
          dplyr::ungroup() %>% 
          # create groups
          dplyr::mutate(
            clump_n_trees_grp = cut(
                clump_n_trees
                ,breaks = c(0,1,4,9,15,Inf)
                , labels = c("Individual","2-4 trees","5-9 trees","10-15 trees",">15 trees")
              ) %>% 
              factor(
                ordered = T
                , levels = c("Individual","2-4 trees","5-9 trees","10-15 trees",">15 trees")
              )
          ) %>% 
          # do we have group sizes we want?
          dplyr::filter(clump_n_trees_grp == ntree_target_temp) %>% 
          nrow()
        ### store best cut list
        if(i==1){
          best_cuts = cut_trees_temp
          best_desired_grps_n_temp = desired_grps_n_temp
        }else if(desired_grps_n_temp>best_desired_grps_n_temp){ # is this better than the best
          best_cuts = cut_trees_temp
          best_desired_grps_n_temp = desired_grps_n_temp
        }else if(
          best_desired_grps_n_temp>0 
          & desired_grps_n_temp<best_desired_grps_n_temp
        ){ # is this worse than the best which was successful?
          # stop it
          while_temp = 0
        }else if( # is this the end?
          i==nrow(cut_tree_lines_temp)
        ){
          # stop it
          while_temp = 0
        }
        ### increment
        i = i+1
    }
  }
# plot it
  x %>% 
    dplyr::inner_join(best_cuts, by = "treeID") %>% 
  ggplot() +
    geom_sf(
      data = # cut line segs
        perp_line_sf_temp %>% 
        sf::st_intersection(
          clump_polys_temp %>% 
            dplyr::ungroup() %>% 
            dplyr::select(clump_id) %>% 
            dplyr::filter(clump_id == x$clump_id[1])
        ) %>% 
        dplyr::mutate(len_m = sf::st_length(geometry) %>% as.numeric())
      , mapping = aes(color = len_m), lwd = 0.8
    ) +
    scale_color_distiller(palette = "Greys", direction = -1) +
    geom_sf(data = f_line_temp, color = "blue", lwd = 1.5) +
    geom_sf(data = clump_polys_temp %>% dplyr::filter(clump_id==x$clump_id[1]), fill = NA) +
    geom_sf(data = x, color = "gray") +
    geom_sf(color = "red") + 
    labs(
      subtitle = paste0("example ", x$clump_n_trees_grp[1], " clump group")
      , color = "cut line\nlength (m)"
      , caption = "*cut trees shown in red"
    ) +
    theme_void()
```

and here are the remaining clump sizes after cutting

```{r}
# get dbscan
  my_dbscan_temp = x %>% 
      sf::st_drop_geometry() %>% 
      dplyr::anti_join(best_cuts, by = "treeID") %>%
      dplyr::select(X,Y) %>% 
      dbscan::dbscan(eps = tree_clump_dist_m, minPts = 2)
# attach dbscan
t_temp = x %>% 
  dplyr::anti_join(best_cuts, by = "treeID") %>% 
  dplyr::mutate(dbscan_cluster = my_dbscan_temp$cluster) %>% 
  dplyr::group_by(dbscan_cluster) %>% 
  dplyr::mutate(
    # unique dbscan_cluster for individuals
    clump_id = dplyr::case_when(
      dbscan_cluster == 0 ~ max(my_dbscan_temp$cluster)+dplyr::row_number()
      , T ~ dbscan_cluster
    ) %>% 
    factor()
  ) %>% 
  dplyr::group_by(clump_id) %>% 
  dplyr::mutate(
    dbscan_cluster = factor(dbscan_cluster)
    , clump_n_trees = dplyr::n()
    , clump_n_trees_grp = cut(
        clump_n_trees
        ,breaks = c(0,1,4,9,15,Inf)
        , labels = c("Individual","2-4 trees","5-9 trees","10-15 trees",">15 trees")
      ) %>% 
      factor(
        ordered = T
        , levels = c("Individual","2-4 trees","5-9 trees","10-15 trees",">15 trees")
      )
  ) %>% 
  dplyr::ungroup()


# plot it
  ggplot() +
    geom_sf(data = f_line_temp, color = "blue", lwd = 1.5) +
    geom_sf(
      data = get_clump_summary(t_temp)
      , mapping = aes(fill = clump_n_trees_grp)
      , color = NA
    ) +
    scale_fill_viridis_d(option="mako", direction = -1, name = "clump size") + 
    geom_sf(data = clump_polys_temp %>% dplyr::filter(clump_id==x$clump_id[1]), fill = NA) +
    geom_sf(data = t_temp, color = "gray") +
    geom_sf(
      data = x %>% 
        dplyr::inner_join(best_cuts, by = "treeID")
      , color = "red"
    ) + 
    labs(
      subtitle = paste0("example ", x$clump_n_trees_grp[1], " clump group\n", "*Residual clump groups highlighted")
      # , color = "cut line\nlength (m)"
      , caption = "*cut trees shown in red"
    ) +
    theme_void()
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(
  id_temp, x, ntree_target_temp
  , dist_temp, f_pts_temp, f_line_temp
  , line_pts_temp, perp_line_sf_temp
  , cut_tree_lines_temp, while_temp, i
  , cut_trees_temp, my_dbscan_temp
  , desired_grps_n_temp, best_cuts, best_desired_grps_n_temp
  , t_temp, st_ends_heading, st_extend_line
  , euclidean_distance, get_perp_line, trees_remain_temp
)
gc()
```

#### Function to cut clumps

put the entire process outlined immediately above into a function to use with the tree list which we'll nest by `clump_id` to cut each clump and then we'll select the desired proportion of clumps

##### define intermediate functions

define intermediate functions

```{r}
##############################################
# working with sf LINESTRINGS
##############################################
  # first two functions borrowed from https://github.com/metafor-ulaval/ALSroads/blob/main/R/line_tools.R
  ########
  # Get heading of both ends of a line
  ########
    st_ends_heading <- function(line){
      M <- sf::st_coordinates(line)
      i <- c(2, nrow(M) - 1)
      j <- c(1, -1)
      
      headings <- mapply(i, j, FUN = function(i, j) {
        Ax = M[i-j,1]
        Ay = M[i-j,2]
        Bx = M[i,1]
        By = M[i,2]
        atan2(Ay-By, Ax-Bx)*180/pi
      })
      names(headings) <- c("head", "tail")
      return(headings)
    }
  ########
  # extend the line on both ends
  ########
    st_extend_line <- function(line, distance, end = "BOTH"){
      if (!(end %in% c("BOTH", "HEAD", "TAIL")) | length(end) != 1) stop("'end' must be 'BOTH', 'HEAD' or 'TAIL'")
    
      M <- sf::st_coordinates(line)[,-3]
      keep <- !(end == c("TAIL", "HEAD"))
      
      ends <- c(1, nrow(M))[keep]
      headings <- st_ends_heading(line)[keep] / 180 * pi
      distances <- if (length(distance) == 1) rep(distance, 2) else distance[1:2]
      
      M[ends, 1:2] <- M[ends, 1:2] + distances[keep] * c(cos(headings), sin(headings))
      newline <- sf::st_linestring(M)
    
      # If input is sfc_LINESTRING and not sfg_LINESTRING
      if (is.list(line)) newline <- sf::st_sfc(newline, crs = sf::st_crs(line))
      
      return(newline)
    }
  ########
  # pass an sf dataframe of points and return a line between the farthest points
  ########
    st_points_to_line <- function(pts, line_ext=0) {
      if(max(class(ttops_temp) %in% c("sf"))!=1){
        stop("must provide an object of class `sf`")
      }
      # find farthest distance between points
      dist_temp = sf::st_distance(pts)
      
      # get the points
      f_pts_temp = 
        pts %>% 
          dplyr::ungroup() %>% 
          dplyr::slice(
            # get the farthest points from distance matrix
            which(dist_temp == max(dist_temp), arr.ind = TRUE)[1,]
          )
      
      # draw a line between the farthest two points
      f_line_temp = f_pts_temp %>% 
          # convert to linestring
          dplyr::ungroup() %>% 
          dplyr::summarise(n=dplyr::n()) %>%
          sf::st_cast("LINESTRING") %>%
          dplyr::ungroup() %>% 
          dplyr::select(-c(n))
      
      # and apply the line extension
        farthest_line = st_extend_line(f_line_temp, distance = line_ext)
      # return
        return(farthest_line)
    }
    # st_points_to_line(ttops_temp %>% dplyr::slice_head(prop = .1), line_ext = 6) %>% 
    #   ggplot() + geom_sf() + geom_sf(data = ttops_temp %>% dplyr::slice_head(prop = .1)) + theme_void()

  ########
  # Function to calculate Euclidean distance between 2 points
  ########
    st_euclidean_distance <- function(p1,p2) {
        return(sqrt((p2[1] - p1[1])^2 + (p2[2] - p1[2])^2))
    }

  ########
  # return a line perpendicular to current line
  ########
  ### https://stackoverflow.com/questions/56771058/perpendicular-lines-at-regular-intervals-along-lines-with-multiple-nodes
    # Function to calculate 2 points on a line perpendicular to another defined by 2 points p1,p2
    # For point at interval, which can be a proportion of the segment length, or a constant
    st_perp_line <- function(interval=0.5, my_line, proportion=TRUE) {
      # get end points of line
      p1 = my_line %>% sf::st_cast("POINT") %>% sf::st_coordinates() %>% .[1,]
      p2 = my_line %>% sf::st_cast("POINT") %>% sf::st_coordinates() %>% .[2,]
      # get length of line to return equal length line
      line_len = sf::st_length(my_line) %>% as.numeric() %>% `/`(2)      
      # get crs of line
      my_crs = sf::st_crs(my_line)
      
      # Calculate x and y distances
      x_len <- p2[1] - p1[1]
      y_len <- p2[2] - p1[2]
      
      # If proportion calculate reference point from tot_length
      if (proportion) {
          point <- c(p1[1]+x_len*interval,p1[2]+y_len*interval)
      }
      # Else use the constant value
      else {
          tot_len <- st_euclidean_distance(p1,p2)
          point <- c(p1[1]+x_len/tot_len*interval,p1[2]+y_len/tot_len*interval)
      }    
      
      # Calculate the x and y distances from reference point to point on line line_len distance away    
      ref_len <- st_euclidean_distance(point,p2)
      xn_len <- (line_len / ref_len) * (p2[1] - point[1])
      yn_len <- (line_len / ref_len) * (p2[2] - point[2])
      
      # Invert the x and y lengths and add/subtract from the refrence point
      # ref_points <- rbind(point,c(point[1] + yn_len,point[2] - xn_len),c(point[1] - yn_len,point[2] + xn_len))
      ref_points <- rbind(c(point[1] + yn_len,point[2] - xn_len),c(point[1] - yn_len,point[2] + xn_len))
      
      # use the reference points to return a line
      return(
        ref_points %>% 
          dplyr::as_tibble() %>% 
          dplyr::rename_with(tolower) %>% 
          sf::st_as_sf(coords = c("x", "y"), crs = my_crs, remove = F) %>%
          dplyr::summarise(n=dplyr::n()) %>%
          sf::st_cast("LINESTRING") %>%
          dplyr::ungroup() %>% 
          dplyr::select(-c(n))
      )
    }
    # st_perp_line(
    #   my_line = st_points_to_line(ttops_temp %>% dplyr::slice_head(prop = .1), line_ext = 6)
    # ) %>% 
    #   ggplot() + 
    #     geom_sf(data = ttops_temp %>% dplyr::slice_head(prop = .1)) + # points
    #     geom_sf(color = "blue") + # perp line
    #     geom_sf( # farthest line
    #       data = st_points_to_line(ttops_temp %>% dplyr::slice_head(prop = .1), line_ext = 6)
    #       , color = "black"
    #     ) + 
    #     theme_void()
```

##### function to pass a clump

generate data using clumping functions above, pass that data, return tree list with cut/keep flag

```{r}
##############################################
# get cut keep tree flag
##############################################
get_keep_tree_flag <- function(
  x # x = data from the get_tree_clumps function filtered for a SINGLE clump_id (meant to be used with nest())
  , clumps # clumps = data from the get_clump_summary function
  , tgt # tgt = data from the get_target_check_prescription function
) {
  # !!! going to have to change the process for clump_n_trees_grp == "Individual"
  if(
    x %>% 
      dplyr::filter(clump_n_trees_grp == "Individual") %>% 
      nrow() > 0
  ){
    stop("cannot cut individual trees...remove from the `x` data")
  }
  # is there more than one clump id
  if(
    x %>% 
      dplyr::distinct(clump_id_duplicate) %>% 
      nrow() > 1
  ){
    stop(
      "please provide data with only a single `clump_id`...or try to nest data:\n"
      , " dplyr::group_by(clump_id) %>% tidyr::nest() %>%\n"
      , "  dplyr::mutate(is_keep_tree = purrr::map(data, get_cut_keep_flag))"
    )
  }
  # get the tree_clump_dist_m distance used with the dbscan in get_tree_clumps
  dist_temp = x$tree_clump_dist_m[1]
  
  # find the next group size for target
  ntree_target_temp = tgt %>%
    dplyr::ungroup() %>% 
    dplyr::arrange(clump_n_trees_grp) %>% 
    dplyr::mutate(l = dplyr::lag(clump_n_trees_grp)) %>%
    dplyr::filter(clump_n_trees_grp == x$clump_n_trees_grp[1]) %>%
    dplyr::pull(l)
  
  # get the farthest line between points
  f_line_temp = st_points_to_line(x, line_ext = dist_temp)
  
  # get perpendicular lines in dataset which we can iterate over to make cuts
  perp_line_sf_temp = 
    # for every 1 m along line length, get a new perp line
    seq(
        from = 0
        , to = sf::st_length(f_line_temp) %>% as.numeric() %>% floor()
        , by = 1
      ) %>% 
    purrr::map(
      st_perp_line
      , my_line = f_line_temp
      , proportion = F
    ) %>% 
    dplyr::bind_rows() %>% 
    dplyr::mutate(line_n = dplyr::row_number())
  
  # find intersection of lines with the polygon and add length of intersection to perp line data
  perp_line_sf_temp = perp_line_sf_temp %>% 
    dplyr::inner_join(
      # intersect and calc len
      perp_line_sf_temp %>% 
        sf::st_intersection(
          clumps %>% 
            dplyr::ungroup() %>% 
            dplyr::select(clump_id) %>% 
            dplyr::filter(clump_id == x$clump_id_duplicate[1])
        ) %>% 
        dplyr::mutate(len_m = sf::st_length(geometry) %>% as.numeric()) %>% 
        sf::st_drop_geometry()
      , by = "line_n"
    )
  
  # make cuts at the points where there is the least overlap with the clump polygon
    # list of potential line cut + tree combinations
    cut_tree_lines_temp = 
      x %>% 
        sf::st_buffer(tree_clump_dist_m/2) %>% 
        sf::st_join(perp_line_sf_temp) %>% 
        sf::st_drop_geometry() %>% 
        dplyr::group_by(treeID) %>% 
        dplyr::summarise(len_m = mean(len_m, na.rm = T)) %>% 
        dplyr::arrange(len_m, treeID) %>% 
        dplyr::mutate(n = dplyr::row_number())
    ###############################################################
    # while
    ###############################################################
    # cut until the desired clump size is achieved
    while_temp = 1
    i = 1
    while(while_temp==1) {
      # cut trees
      cut_trees_temp = cut_tree_lines_temp %>% 
        dplyr::slice(1:i) %>% 
        dplyr::distinct(treeID)
      # get the remaining trees not cut
      trees_remain_temp = x %>% 
        sf::st_drop_geometry() %>% 
        dplyr::anti_join(cut_trees_temp, by = "treeID") %>% 
        dplyr::select(X,Y)
      
      # ensure that there are trees
      if(nrow(trees_remain_temp)==0){
        # there are no more possible cuts :/
        best_cuts = dplyr::tibble(treeID = character())
        # stop it
        while_temp = 0
      }else{
          # cut them from the clump and check the new dbscan
          my_dbscan_temp = trees_remain_temp %>% 
            dbscan::dbscan(eps = tree_clump_dist_m, minPts = 2)
          
          # count the groups
          desired_grps_n_temp = dplyr::tibble(
              dbscan_cluster = my_dbscan_temp$cluster
            ) %>% 
            dplyr::mutate(
              # unique dbscan_cluster for individuals
              clump_id = dplyr::case_when(
                dbscan_cluster == 0 ~ max(my_dbscan_temp$cluster)+dplyr::row_number()
                , T ~ dbscan_cluster
              ) %>% 
              factor()
            ) %>% 
            dplyr::group_by(clump_id) %>% 
            dplyr::summarise(clump_n_trees = dplyr::n()) %>% 
            dplyr::ungroup() %>% 
            # create groups
            dplyr::mutate(
              clump_n_trees_grp = cut(
                  clump_n_trees
                  ,breaks = c(0,1,4,9,15,Inf)
                  , labels = c("Individual","2-4 trees","5-9 trees","10-15 trees",">15 trees")
                ) %>% 
                factor(
                  ordered = T
                  , levels = c("Individual","2-4 trees","5-9 trees","10-15 trees",">15 trees")
                )
            ) %>% 
            # do we have group sizes we want?
            dplyr::filter(clump_n_trees_grp == ntree_target_temp) %>% 
            nrow()
          ### store best cut list
          if(i==1){
            best_cuts = cut_trees_temp
            best_desired_grps_n_temp = desired_grps_n_temp
          }else if(desired_grps_n_temp>=best_desired_grps_n_temp){ # is this better than the best
            best_cuts = cut_trees_temp
            best_desired_grps_n_temp = desired_grps_n_temp
          }else if(
            best_desired_grps_n_temp>0 
            & desired_grps_n_temp<best_desired_grps_n_temp
          ){ # is this worse than the best which was successful?
            # stop it
            while_temp = 0
          }else if( # is this the end?
            i==nrow(cut_tree_lines_temp)
          ){
            # stop it
            while_temp = 0
          }
          ### increment
          i = i+1
      }
    }
  # return it
    # return treelist with cut/keep
    # join to original data and pull
    d_temp = x %>%
      sf::st_drop_geometry() %>%
      dplyr::left_join(
        best_cuts %>% dplyr::mutate(is_keep_tree = 0)
        , by = dplyr::join_by("treeID")
      ) %>%
      dplyr::mutate(is_keep_tree = dplyr::coalesce(is_keep_tree, 1)) %>%
      dplyr::pull(is_keep_tree)
    return(d_temp)
}

# get_keep_tree_flag(
#   x = ttops_temp %>% 
#     dplyr::filter(
#       clump_id == ttops_temp %>% 
#         dplyr::arrange(desc(clump_n_trees)) %>% 
#         dplyr::pull(clump_id) %>% 
#         .[1]
#     )
#   , clumps = clump_polys_temp
#   , tgt = target_data_temp
# )
```

#### Cut one group size example

```{r}
# use target data to get cut trees by clump size group
# !!!! need this first:
  # target_data_temp = get_target_check_prescription(
  #   clump_n_trees_grp_summary_temp
  #   , target_ba = target_ba
  #   , target_qmd = target_qmd
  #   , target_pcts = target_pcts
  # )
cut_grp_ex_temp = ttops_temp %>%
  dplyr::filter(clump_n_trees_grp == ">15 trees") %>%
  dplyr::ungroup() %>% 
  tidyr::nest(.by = c(clump_id)) %>%
  dplyr::mutate(
    is_keep_tree = data %>%
      purrr::map(\(data) get_keep_tree_flag(
          data
          , clumps = clump_polys_temp
          , tgt = target_data_temp
        )
      )
  ) %>%
  tidyr::unnest(cols = c(data, is_keep_tree)) %>%
  sf::st_set_geometry("geom") %>% # set it cuz it got lost
  dplyr::ungroup()
# what?
cut_grp_ex_temp %>% dplyr::glimpse()
```

example group cut and keep trees

```{r}
ggplot() + 
    geom_sf(data = harvests %>% dplyr::filter(suid == my_suid), fill = NA, color = "black") +
    geom_sf(
      data = clump_polys_temp %>% dplyr::filter(clump_n_trees_grp == ">15 trees")
      , mapping = aes(fill = clump_id)
      , color = NA
      , show.legend = F
    ) +
    scale_fill_manual(
      values = 
        viridis::turbo(
          clump_polys_temp %>% dplyr::filter(clump_n_trees_grp == ">15 trees") %>% 
          dplyr::pull(clump_id) %>% 
          unique() %>% length()
        ) %>% sample()
    ) + 
    # tree points
    geom_sf(data = cut_grp_ex_temp, mapping = aes(color = as.factor(is_keep_tree)), size = 0.5) +
    scale_color_manual(values = c("gray", "black")) +
    labs(color = "is keep tree?", caption = "*existing clumps distinguished by color") +
    theme_void() + 
    guides(color = guide_legend(override.aes = list(size = 5)))
```

residual clump group size

```{r}
# get dbscan
  my_dbscan_temp = cut_grp_ex_temp %>% 
      dplyr::filter(is_keep_tree == 1) %>% 
      sf::st_drop_geometry() %>% 
      dplyr::select(X,Y) %>% 
      dbscan::dbscan(eps = tree_clump_dist_m, minPts = 2)
# attach dbscan
t_temp = cut_grp_ex_temp %>% 
  dplyr::filter(is_keep_tree == 1) %>% 
  dplyr::mutate(dbscan_cluster = my_dbscan_temp$cluster) %>% 
  dplyr::group_by(dbscan_cluster) %>% 
  dplyr::mutate(
    # unique dbscan_cluster for individuals
    clump_id = dplyr::case_when(
      dbscan_cluster == 0 ~ max(my_dbscan_temp$cluster)+dplyr::row_number()
      , T ~ dbscan_cluster
    ) %>% 
    factor()
  ) %>% 
  dplyr::group_by(clump_id) %>% 
  dplyr::mutate(
    dbscan_cluster = factor(dbscan_cluster)
    , clump_n_trees = dplyr::n()
    , clump_n_trees_grp = cut(
        clump_n_trees
        ,breaks = c(0,1,4,9,15,Inf)
        , labels = c("Individual","2-4 trees","5-9 trees","10-15 trees",">15 trees")
      ) %>% 
      factor(
        ordered = T
        , levels = c("Individual","2-4 trees","5-9 trees","10-15 trees",">15 trees")
      )
  ) %>% 
  dplyr::ungroup()

# plot it
  ggplot() + 
    geom_sf(data = harvests %>% dplyr::filter(suid == my_suid), fill = NA, color = "black") +
    geom_sf(
      data = clump_polys_temp %>% dplyr::filter(clump_n_trees_grp == ">15 trees")
      , fill = NA
      , show.legend = F
    ) +
    geom_sf(
      data = t_temp %>% sf::st_buffer(tree_clump_dist_m/2)
      , mapping = aes(fill = clump_n_trees_grp)
      , color = NA
    ) +
    scale_fill_viridis_d(option="mako", direction = -1, name = "Residual\nclump size") + 
    # tree points
    geom_sf(data = cut_grp_ex_temp %>% 
        dplyr::filter(is_keep_tree == 0)
        , color = "red"
        , size = 0.5
    ) +
    labs(caption = "*cut trees shown in red")+
    theme_void() 
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(t_temp, my_dbscan_temp)
gc()
```

```{r, include=F, eval=F}
###### !!!!!!!!!!!!!!!!! CUT BY BBOX GRID ????
###### !!!!!!!!!!!!!!!!! CUT BY BBOX GRID ????
clump_polys_temp %>% dplyr::filter(clump_n_trees_grp == ">15 trees") %>% mapview()
# data for passing to function with nest()
id_temp = 45

x = ttops_temp %>% 
  dplyr::filter(clump_n_trees_grp == ">15 trees") %>%
  dplyr::filter(clump_id == id_temp) #45 

ggplot(x) + geom_sf(aes(color = dbh_cm)) +
  geom_sf(data = clump_polys_temp %>% dplyr::filter(clump_id==id_temp), fill = NA) +
  theme_void()

      # get next size group n tree target
      ntree_target_temp = target_data_temp %>%
        dplyr::mutate(l = dplyr::lag(mean_clump_n_trees)) %>%
        dplyr::filter(clump_n_trees_grp == x$clump_n_trees_grp[1]) %>%
        dplyr::pull(l) %>%
        dplyr::coalesce(0)
      # ntree_target_temp
      
      # how many trees versus target?
      sections_temp = dplyr::case_when(
        # if can only divide into 2 sections:
        nrow(x)/ntree_target_temp < 2 ~ 1
        # otherwise 
        , T ~ 2 * round((nrow(x)/ntree_target_temp)/2) # nearest even number
      )
      # sections_temp
      
      # make a grid based on the potential number of sections required
      grid = sf::st_bbox(x) %>% 
        sf::st_make_grid(cellsize = c(
          # cols
          diff(sf::st_bbox(x)[c(1, 3)]) %>% 
            `/`( sections_temp/2 ) %>% 
            # `/`( max(sections_temp/2,2) ) %>% 
            ceiling()
          # rows
          , diff(sf::st_bbox(x)[c(2, 4)]) %>% 
            `/`( sections_temp/2 ) %>% 
            # `/`( max(sections_temp/2,2) ) %>% 
            ceiling()
        )) %>% 
        sf::st_as_sf() %>%
        sf::st_set_geometry("geometry") %>% 
        dplyr::mutate(
          grid_n = dplyr::row_number()
        )
      # add the center to the grid
      grid = grid %>% 
        dplyr::inner_join(
          grid %>% 
            sf::st_centroid() %>%
            dplyr::mutate(
              x_center = sf::st_coordinates(.)[,1]
              , y_center = sf::st_coordinates(.)[,2]
            ) %>% 
            sf::st_drop_geometry()
          , by = dplyr::join_by("grid_n")
        )
      
      plot(grid)
```


```{r, include=F, eval=F}
###### !!!!!!!!!!!!!!!!! CUT BY BBOX LINES ????
###### !!!!!!!!!!!!!!!!! CUT BY BBOX LINES ????
# clump_polys_temp %>% dplyr::filter(clump_n_trees_grp == ">15 trees") %>% mapview()
# data for passing to function with nest()
id_temp = 35

x = ttops_temp %>% 
  dplyr::filter(clump_n_trees_grp == ">15 trees") %>%
  dplyr::filter(clump_id == id_temp) #45 

ggplot(x) + geom_sf(aes(color = dbh_cm)) +
  geom_sf(data = clump_polys_temp %>% dplyr::filter(clump_id==id_temp), fill = NA) +
  theme_void()

# get next size group n tree target
ntree_target_temp = target_data_temp %>%
  dplyr::mutate(l = dplyr::lag(mean_clump_n_trees)) %>%
  dplyr::filter(clump_n_trees_grp == x$clump_n_trees_grp[1]) %>%
  dplyr::pull(l) %>%
  dplyr::coalesce(0)
# ntree_target_temp
      
# how many trees versus target?
sections_temp = dplyr::case_when(
  # if can only divide into 2 sections:
  nrow(x)/ntree_target_temp < 2 ~ 1
  # otherwise 
  , T ~ 2 * round((nrow(x)/ntree_target_temp)/2) # nearest even number
)
# sections_temp

# split the bbox into lines
bbox_temp = sf::st_bbox(x)
# row cuts (distance between xmax-xmin)
col_divide_temp = ( (bbox_temp[3]-bbox_temp[1])/max(sections_temp/2,2) ) %>% ceiling()
# col cuts (distance between ymax-ymin)
row_divide_temp = ( (bbox_temp[4]-bbox_temp[2])/max(sections_temp/2,2) ) %>% ceiling()
# get list of x positions
xvals_temp = seq(from = bbox_temp[1], to = bbox_temp[3], by = col_divide_temp)
# remove the xmax, xmin
xvals_temp = xvals_temp[!xvals_temp %in% c(bbox_temp[3], bbox_temp[1])]
# get list of y positions
yvals_temp = seq(from = bbox_temp[2], to = bbox_temp[4], by = row_divide_temp)
# remove the xmax, xmin
yvals_temp = yvals_temp[!yvals_temp %in% c(bbox_temp[4], bbox_temp[2])]
# create point pairs vertical lines
vert_lines_temp = tidyr::crossing(
    x = xvals_temp
    , y = c(bbox_temp[4], bbox_temp[2])
  ) %>%
  sf::st_as_sf(coords = c("x", "y"), crs = sf::st_crs(x), remove = F) %>%
  dplyr::group_by(x) %>%
  dplyr::summarise(n=dplyr::n()) %>%
  sf::st_cast("LINESTRING") %>%
  dplyr::ungroup() %>% 
  dplyr::rename(id = x) %>% 
  dplyr::mutate(id_type = "x")
# create point pairs horizontal lines
horz_lines_temp = tidyr::crossing(
    x = c(bbox_temp[3], bbox_temp[1])
    , y = yvals_temp
  ) %>%
  sf::st_as_sf(coords = c("x", "y"), crs = sf::st_crs(x), remove = F) %>%
  dplyr::group_by(y) %>%
  dplyr::summarise(n=dplyr::n()) %>%
  sf::st_cast("LINESTRING") %>%
  dplyr::ungroup() %>% 
  dplyr::rename(id = y) %>% 
  dplyr::mutate(id_type = "y")

# spatial data of lines
cut_lines_temp =
  dplyr::bind_rows(vert_lines_temp, horz_lines_temp) %>% 
  # sort it based on length/width
  dplyr::mutate(
    sorter = dplyr::case_when(
      col_divide_temp>=row_divide_temp & id_type == "x" ~ T
      , col_divide_temp<row_divide_temp & id_type == "y" ~ T
      , T ~ F
    )
  ) %>% 
  dplyr::arrange(desc(sorter), id)
# ggplot() +
#   geom_sf(data = cut_lines_temp, aes(color = id_type)) +
#   scale_color_viridis_d(end = 0.6) +
#   geom_sf(data = x) +
#   geom_sf(data = clump_polys_temp %>% dplyr::filter(clump_id==id_temp), fill = NA) +
#   theme_void()


# go through every cut line combination until we get desired clumping

# 1) identify trees to remove based on cut lines
try_n = 1
cut_trees_temp = 
  cut_lines_temp %>% 
    dplyr::filter(dplyr::row_number() %in% c(1:try_n)) %>% # change the second 1 to iterate
    sf::st_buffer(round(tree_clump_dist_m/2,0), endCapStyle = "SQUARE") %>% 
    sf::st_union() %>% 
    sf::st_as_sf() %>% 
    sf::st_join(x %>% dplyr::select(treeID)) %>% 
    sf::st_drop_geometry()
# 2) perform dbscan without cut trees
  ### Place trees into clusters using an inter-tree distance of 6 m
  my_dbscan_temp = x %>% 
    dplyr::anti_join(cut_trees_temp, by = "treeID") %>% 
    sf::st_drop_geometry() %>% 
    dplyr::select(X,Y) %>% 
    dbscan::dbscan(eps = tree_clump_dist_m, minPts = 2)

    ### append cluster ID to trees
    # keep trees
    keep_trees_temp = 
      x %>% 
        dplyr::anti_join(cut_trees_temp, by = "treeID") %>% 
        dplyr::mutate(dbscan_cluster = my_dbscan_temp$cluster) %>% 
        dplyr::group_by(dbscan_cluster) %>% 
        dplyr::mutate(
          # unique dbscan_cluster for individuals
          clump_id = dplyr::case_when(
            dbscan_cluster == 0 ~ max(my_dbscan_temp$cluster)+dplyr::row_number()
            , T ~ dbscan_cluster
          ) %>% 
          factor()
        ) %>% 
        dplyr::group_by(clump_id) %>% 
        dplyr::mutate(
          dbscan_cluster = factor(dbscan_cluster)
          , clump_n_trees = dplyr::n()
          , clump_n_trees_grp = cut(
              clump_n_trees
              ,breaks = c(0,1,4,9,15,Inf)
              , labels = c("Individual","2-4 trees","5-9 trees","10-15 trees",">15 trees")
            ) %>% 
            factor(
              ordered = T
              , levels = c("Individual","2-4 trees","5-9 trees","10-15 trees",">15 trees")
            )
        ) %>% 
        dplyr::ungroup()
    
    # if its the first time or is a better cutting then keep it
    if(try_n==1){
      trees_
    }


ggplot() +
  geom_sf(
    data = cut_lines_temp %>% 
    dplyr::filter(dplyr::row_number() %in% c(1:1)) %>% # change the second 1 to iterate
    sf::st_buffer(round(tree_clump_dist_m/2,0), endCapStyle = "SQUARE") %>% 
    sf::st_union()
  , fill = NA) +
  geom_sf(data = x) +
  geom_sf(data = clump_polys_temp %>% dplyr::filter(clump_id==id_temp), fill = NA) +
  geom_sf(data = 
            cut_lines_temp %>% 
              dplyr::filter(dplyr::row_number() %in% c(1:1)) %>% # change the second 1 to iterate
              sf::st_buffer(round(tree_clump_dist_m/2,0), endCapStyle = "SQUARE") %>% 
              sf::st_union() %>% 
              sf::st_intersection(x)
    , color = "red"
  ) +
  theme_void()


# k = 3
# rows <- input %>% group_by_all() %>% group_split() 
# row_combinations <- t(combn(x = 1:nrow(input), m = k)) %>% as_tibble() 
# row_combinations %>% mutate_all(~ map(., ~ pluck(rows, .x))) %>% unnest()

```

```{r, include=F, eval=F}
###### !!!!!!!!!!!!!!!!! CUT BY RASTER GRID ????
###### !!!!!!!!!!!!!!!!! CUT BY RASTER GRID ????
clump_polys_temp %>% dplyr::filter(clump_n_trees_grp == ">15 trees") %>% mapview()
# data for passing to function with nest()
id_temp = 45

x = ttops_temp %>% 
  dplyr::filter(clump_n_trees_grp == ">15 trees") %>%
  dplyr::filter(clump_id == id_temp) #45 

# ggplot(x) + geom_sf(aes(color = dbh_cm)) + 
#   geom_sf(data = clump_polys_temp %>% dplyr::filter(clump_id==id_temp), fill = NA) + 
#   theme_void()

# get next size group n tree target
ntree_target_temp = target_data_temp %>%
  dplyr::mutate(l = dplyr::lag(mean_clump_n_trees)) %>%
  dplyr::filter(clump_n_trees_grp == x$clump_n_trees_grp[1]) %>%
  dplyr::pull(l) %>%
  dplyr::coalesce(0)

# how many trees versus target?
sections_temp = dplyr::case_when(
  # if can only divide into 2 sections:
  nrow(x)/ntree_target_temp < 2 ~ 1
  # otherwise 
  , T ~ 2 * round((nrow(x)/ntree_target_temp)/2) # nearest even number
)

# make a grid
grid = x %>%
  sf::st_bbox() %>% 
  sf::st_as_sfc() %>% 
  terra::vect() %>% 
  terra::rast(res = round(tree_clump_dist_m/2,0))
values(grid) = 1:terra::ncell(grid)

# divide columns every x col
col_divide_temp = dplyr::case_when(
  terra::ncol(grid) >= terra::nrow(grid) ~ ceiling(terra::ncol(grid)/max(sections_temp/2,2))
  , sections_temp == 2 ~ terra::ncol(grid)+1
  , T ~ ceiling(terra::ncol(grid)/2)
)
# divide rows every x col
row_divide_temp = dplyr::case_when(
  terra::ncol(grid) < terra::nrow(grid) ~ ceiling(terra::nrow(grid)/max(sections_temp/2,2))
  , sections_temp == 2 ~ terra::nrow(grid)+1
  , T ~ ceiling(terra::nrow(grid)/2)
)
# take a cell number and return 0/1 for cut
cut_raster_cells = function(c){
  # if terra::ncol(grid) >= terra::nrow(grid)
  !(terra::ncol(grid) >= terra::nrow(grid) &
    terra::rowFromCell(grid, c)==terra::nrow(grid) # not the last row
  ) &
  # if terra::ncol(grid) < terra::nrow(grid)
  !(terra::ncol(grid) < terra::nrow(grid) &
    terra::colFromCell(grid, c)==terra::ncol(grid) # not the last col
  ) &
  # get row number
  terra::rowFromCell(grid, c)%%row_divide_temp==0 |
  # get col number
  terra::colFromCell(grid, c)%%col_divide_temp==0
}
# set the values of the raster based on the cut raster cells function
values(grid)=cut_raster_cells(1:terra::ncell(grid))

# ggplot() + 
#   geom_tile(
#     data = grid %>% as.data.frame(xy=T) %>% dplyr::rename(f=3)
#     , mapping = aes(x=x,y=y,fill=f)
#   ) +
#   geom_sf(data = x, aes(color = dbh_cm)) + 
#   geom_sf(data = clump_polys_temp %>% dplyr::filter(clump_id==id_temp), fill = NA) + 
#   scale_fill_viridis_d(option = "rocket", begin = 0.7, name = "cut path") +
#   scale_color_viridis_c(option = "mako", direction = -1, end = 0.8, name = "DBH (cm)") +
#   theme_void()

# transform to vector to get lines that we can iterate over for different cut outcomes
grid %>% terra::as.polygons() %>% terra::plot()

ggplot() + 
  geom_tile(
    data = grid %>% as.data.frame(xy=T) %>% dplyr::rename(f=3)
    , mapping = aes(x=x,y=y,fill=f)
  ) +
  geom_sf(data = x, aes(color = dbh_cm)) + 
  geom_sf(data = clump_polys_temp %>% dplyr::filter(clump_id==id_temp), fill = NA) + 
  scale_fill_viridis_d(option = "rocket", begin = 0.7, name = "cut path") +
  scale_color_viridis_c(option = "mako", direction = -1, end = 0.8, name = "DBH (cm)") +
  theme_void()
    

```